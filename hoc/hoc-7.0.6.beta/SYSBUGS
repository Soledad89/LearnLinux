%% /usr/local/src/hoc/hoc-7.0.3.beta/SYSBUGS, Tue Jan 29 07:04:14 2002
%% Edit by Nelson H. F. Beebe <beebe@math.utah.edu>

============
Introduction
============

This file records bugs in operating systems, C/C++ system header
files, C/C++ runtime libraries, and floating-point trap handlers that
have been uncovered during hoc 7 development and testing, and records
architectural deviations from the IEEE 754 Standard.

In the sections below, the vendor, processor, and operating system are
recorded in the first line.  On most systems, gcc and g++ 2.95.x and
3.0.x are available, as are vendor-provided cc, c89, CC (c++, cxx,
xlC, ...), and on some of them, the AT&T/Princeton lcc compiler.




===========================
Standards and architectures
===========================

ANSI, ISO, and IEEE Standards define abstract specifications of
programming languages and floating-point arithmetic systems that
vendors are encouraged to follow, but only market pressures can force
vendors toward Standards conformance.

Examination of a broad range of vendor implementations of
floating-point architectures and programming languages show that all
tend to follow specifications reasonably closely, but important
features are sometimes omitted, or new ones added.

Sadly, in this high-technology industry, few customers are technically
competent, and especially in the desktop computer market, buying
decisions are usually made on price and physical appearance,
completely ignoring issues of standards conformance, correctness,
reliability, maintainability, upgradability, quality of documentation,
...




=================================
Architecture implementation notes
=================================

Computer architectures can be implemented entirely in hardware,
entirely in software, or in a combination of hardware and software,
but apart from speed differences, it is always the architectural
intent that the implementation choice should be transparent to
software.  Thus, the architecture manuals are always the final
authorities.

Floating-point architectures on most RISC systems use a combination of
hardware and software, with subnormal numbers, Infinity, and NaN
relegated to software in run-time interrupt handlers.  The notable
exception is the IBM RS/6000 Power and PowerPC family, which uses a
hardware-only implementation.  The older Power, Power II, and Power
III systems implemented only 64-bit floating-point arithmetic,
providing only instructions to convert to 32-bit form in load and
store instructions.  PowerPC added a full suite of 32-bit
instructions.

The Intel IA-32 (also called x86, after the Intel 8086, 80186, 80286,
80386, 80486, and Pentium chip families) and the Motorola 68881 CISC
architectures, and the HP/Intel IA-64 EPIC (Explicitly Parallel
Instruction set Computer) architecture, also use hardware-only
implementations.

On some RISC architecture models, and IA-64 EPIC, certain complex
low-level operations, like divide, multiply, and square root, are also
left to software.  With EPIC, the required instruction sequences are
expanded in-line and interleaved to achieve software pipelining to try
to avoid bottlenecks from long-running operations.




==========================
Extended-precision support
==========================

For nearly five decades, most floating-point architectures have
included at least two formats, usually called single and double
precision (Fortran REAL and DOUBLE PRECISION, C/C++/Java float and
double).  About 1967, IBM introduced a third format, called quadruple
precision, implemented in hardware in some S/360 models, and called
REAL*16 in Fortran.  As the names suggest, these occupy one, two and
four words of memory.  On virtually all modern computer systems, a
word is 32 bits, but historical systems made other choices, with 4, 8,
12, 16, 18, 24, 32, 36, 40, 48, 60, and 64 bits per word.  Because of
the need for storage of a sign, exponent, and significand,
floating-point requires a reasonably large word, usually at least 32
bits.

The Fortran Standards (1966, 1978, 1990, and 1995) have always
mandated that REAL occupies the same storage unit size as INTEGER, and
DOUBLE PRECISION occupies two such units.  Nevertheless, there has
been at least one system where this requirement was not followed:
Harris systems in the 1980s had 24-bit integers, but used 48-bit and
96-bit floating-point.

The C and C++ standards are looser, requiring only that the storage
sizes for float, double, and long double form a nondecreasing
sequence: thus, a conformant implementation can make them identical.

The Java language is considerably stricter, mandating a subset of IEEE
754 arithmetic, with only 32-bit and 64-bit sizes available, and with
a stricter evaluation order than is required by other programming
language standards.

In the late 1970s, as the IEEE 754 Standard was being developed, it
was suggested by the IEEE 754 committee that it would be numerically
desirable to have somewhat longer precision available for intermediate
computations, so the Standard defined four main formats: single,
single extended, double, and double extended, with quadruple (and
possibly quadruple extended?)  suggested for future implementation,
but not otherwise specified.

Intel took the lead in this, with the Intel 8087 implementing 32-bit
single, 64-bit double, and 80-bit double extended about five years
before the IEEE 754 Standard was formally adopted in 1985.

I know of no systems that have ever implemented the IEEE 754 single
extended format, and it is likely to be dropped from the next revision
of that Standard.

Motorola followed Intel shortly thereafter with the MC 68881 which
offered the same formats as the Intel 8087, though with an entirely
different register model, and with instructions that store the 80-bit
double extended in 96 bits (three words, or 12 8-bit bytes), instead
of in 80 bits as Intel does.

HP/Intel IA-64 continues this tradition, except that the double
extended format uses 82 bits in registers (two extra bits for the
exponent), and is shortened to 32, 64, or 80 bits for storage into
memory.  IA-64 also defines a 128-bit quadruple-precision data format,
but no instructions are defined yet to process such data.

The various RISC architectures (Compaq/DEC Alpha, HP PA-RISC, IBM
Power and PowerPC, Intel i860, SGI MIPS, and Sun SPARC) all provide
32-bit and 64-bit IEEE 754 formats.

PA-RISC and SPARC also define a 128-bit quadruple-precision format
with associated instructions, but except for the Hal/Fujitsu
SPARC64-GP processor, these instructions are emulated in software.

The Alpha architectures defines an IEEE 754 128-bit
quadruple-precision format, but without instructions to process such
data.  C, C++ and Fortran compilers in Compaq OSF/1 5.0 (about 2001)
finally offered such support.  The Alpha architecture also defines
three VAX floating-point formats (32-bit, 64-bit, and 128-bit), and
the hardware implements the first two, but sadly, no high-level
language compiler on either OSF/1 or GNU/Linux gives access to the VAX
formats.

IBM Power and PowerPC, and SGI MIPS offer a peculiar
quadruple-precision format implemented in software as paired doubles,
but unlike historic architectures that used similar pairing, the
exponents are not linked, so the important notion of a machine epsilon
is lost.  Both vendor implementations have been found to be severely
flawed, so hoc does not even attempt to deal with them.  [These flaws
are documented in a paper co-authored with James Ball that is under
review for the journal ACM Transactions on Mathematical Software].

In 1999, IBM extended the S/390 architecture with full support in
hardware for 32-bit, 64-bit, and 128-bit IEEE 754 formats,
supplementing the three older S/360 formats.  Unfortunately, on
GNU/Linux on S/390, only two (32-bit and 64-bit IEEE 754) of the six
formats are accessible in C and C++ (and also Fortran, which is
translated to C before compilation).

C and C++ admit to the existence of a third floating-point format with
their long double type, introduced in the 1989 ANSI/ISO C Standard,
with improved support in the 1999 ISO C Standard.  Unfortunately, this
happened almost a decade after it was available on Intel hardware, and
even today, two decades after the Intel 8087, the 80-bit format still
has limited availability in C and C++.

Intel IA-32 support is even worse with Fortran: I know of only one
compiler (Ryan-McFarland, long extinct) that ever offered a REAL*10
data type for 80-bit IEEE 754 data, and that compiler was otherwise so
flawed as to be useless.  Today, only the Lahey/Fujitsu lf95 Fortran
95 compiler offers extended precision on Intel IA-32 systems, and that
is for a 128-bit IEEE 754 format implemented in software; the 80-bit
format remains entirely inaccessible from Fortran, 22 years after the
first Intel systems shipped, with possibly more than two hundred
million of them shipped to date.

In practice, for hoc, this means that there are four important
floating-point formats: 32-, 64-, 80-, and 128-bit IEEE 754.  Although
hoc has been carefully programmed to permit relatively simple addition
of support for older floating-point architectures, such as DEC VAX,
Cray, and IBM S/360, the hoc developer has no access to any such
system to be able to complete the programming and testing of the
additions.

To make matters more difficult, there are C/C++ compilers that

	* accept a long double type but actually store it as double
          (gcc/g++ on GNU/Linux systems running on non-Intel
          architectures), with a run-time library that conforms to
          this model;

	* accept a long double type but actually store it as double,
          but use a runtime library that has 80-bit long double
          support (Portland Group pgcc and pgCC), making it completely
          useless;

	* reject a long double type;

	* implement a long double type as 80-bit data;

	* implement a long double type as 128-bit data.




==============
Compiler notes
==============

It should be remembered that gcc/g++ use header files that are
provided partly by the gcc/g++ developers, and partly by editing of
vendor native header files.  gcc/g++ typically use the vendor-provided
C library, -lc, and the math library, -lm, although on GNU/Linux and
Apple Darwin (MacOS X) systems, those libraries are from the gcc/g++
distribution.

lcc uses its own header files for all those defined in the 1989
ANSI/ISO C Standard, and vendor-provided header files for all others.
Its run-time libraries -lc and -lm are the vendor-provided ones.

Thus, for gcc/g++ and lcc, it can be difficult to determine whether
the bugs and deficiencies should be ascribed to the gcc/g++/lcc
distributions, or to vendor distributions.




============
System notes
============

------------------------------------------------------------------------
AMD Athlon		GNU/Linux version 2.4.2-2smp (Red Hat 7.1)
Floating-point model: 32-bit, 64-bit, 80-bit IEEE 754

See the Intel Pentium III section below.

------------------------------------------------------------------------
Apple PowerPC G4 267MHz	Darwin 1.3.3
Floating-point model: 32-bit, 64-bit IEEE 754

Limitations:	(1) The single-precision library functions are
		    documented in the UNIX manual pages, but are
		    entirely absent from the run-time library

Bugs:		(1) scalb() is implemented with arguments (double,
                    int) instead of Standard C's (double, double).

Missing function prototypes (g++):
	32-bit:		ALL
	64-bit:		trunc
	128-bit:	ALL

Missing library functions (g++):
	32-bit:		ALL
	64-bit:		trunc
	128-bit:	ALL

------------------------------------------------------------------------
Apple PowerPC G3 267MHz	GNU/Linux 2.2.18-4hpmac (Red Hat Linux/PPC 2000 Q4)
Floating-point model: 32-bit, 64-bit IEEE 754
------------------------------------------------------------------------
Apple Power Mac 233MHz	GNU/Linux 2.2.15pre9
Floating-point model: 32-bit, 64-bit IEEE 754
------------------------------------------------------------------------
Apple PowerPC G4 267MHz	Yellow Dog GNU/Linux 2.0
Floating-point model: 32-bit, 64-bit IEEE 754
		    
Bugs:		(1) sqrtl() is missing from -lm.
		    
------------------------------------------------------------------------
Compaq/DEC Alpha	OSF/1 4.0F
Floating-point model: 32-bit, 64-bit IEEE 754

Limitations:
	(1) Unless code is compiled with additional option (cc, cxx:
	    -ieee; f77, f90, f95: -fpe3, gcc, g++, g77: -mieee),
	    execution is terminated on overflow or invalid (NaN or
	    subnormal), and underflows flush abruptly to zero.
	    Nonstop IEEE 754 behavior is available, but only at
	    significant run-time penalty, since each floating-point
	    instruction must be preceded by a trap barrier instruction
	    to flush the pipeline, allowing a software interrupt
	    handler to correctly identify a faulting instruction, and
	    make a run-time fixup.  hoc's configure script ensures that
	    the required IEEE 754 compiler options are set properly.

Bugs:	(1) ceil(-0), floor(-0), int(-0), trunc(-0) produce incorrect
	    sign of zero (32-bit, 64-bit).
	    
Missing function prototypes (cxx):
	32-bit:		ilogbf
	64-bit:		ilogb
	128-bit:	acoshl acosl asinhl asinl atanhl atanl cbrtl
			ceill copysignl coshl cosl erfcl erfl expl
			expm1l fabsl floorl fmodl hypotl ilogbl j0l
			j1l jnl ldexpl lgammal log10l logl nextafterl
			powl remainderl rintl scalbl sinhl sinl sqrtl
			tanhl tanl truncl y0l y1l ynl

Missing library functions (cxx):
	32-bit:		ilogbf
	64-bit:		ilogb
	128-bit:	acoshl acosl asinhl asinl atanhl atanl cbrtl
			ceill copysignl coshl cosl erfcl erfl expl
			expm1l fabsl floorl fmodl hypotl ilogbl j0l
			j1l jnl ldexpl lgammal log10l logl nextafterl
			powl remainderl rintl scalbl sinhl sinl sqrtl
			tanhl tanl truncl y0l y1l ynl
------------------------------------------------------------------------
Compaq Alpha Sierra	OSF/1 5.0
Floating-point model: 32-bit, 64-bit, 128-bit IEEE 754

Limitations:	See entry for OSF/1 4.0.

Bugs:	(1) Output of long double values with fprintf(), printf(), and
	    sprintf() will not print more than 17 decimal figures,
	    making long double effectively useless for practical
	    computations!

Missing function prototypes (cxx):
	32-bit:		ilogbf
	64-bit:		ilogb
	128-bit:	ilogbl remainderl

Missing library functions (cxx):
	32-bit:		ilogbf
	64-bit:		ilogb
	128-bit:	ilogbl remainderl
------------------------------------------------------------------------
DEC Alpha		GNU/Linux 2.2.19-6.2.1 (Red Hat 6.2)
Floating-point model: 32-bit, 64-bit IEEE 754

Limitations:	See entry for OSF/1 4.0.
	    
Bugs:	(1) Denormalized floats are printed incorrectly: here is a
	    fragment of the output from a test program (see the PROBLEMS
	    file for details, and the program):

		% g++ -mieee foo3.c && ./a.out
		      0 1       0x3f800000_deadbeef_deadbeef_deadbeef
		     -1 0.5     0x3f000000_deadbeef_deadbeef_deadbeef
		     -2 0.25    0x3e800000_deadbeef_deadbeef_deadbeef
		     -3 0.125   0x3e000000_deadbeef_deadbeef_deadbeef
		 ...
		   -125 2.35098870164457501593747307444449136e-38       0x01000000_deadbeef_deadbeef_deadbeef
		   -126 1.17549435082228750796873653722224568e-38       0x00800000_deadbeef_deadbeef_deadbeef
		   -127 1.11253692925360069154511635866620203e-308      0x00400000_deadbeef_deadbeef_deadbeef
		   -128 5.56268464626800345772558179333101016e-309      0x00200000_deadbeef_deadbeef_deadbeef
		...
		   -147 1.06099789548263615755569110743160442e-314      0x00000004_deadbeef_deadbeef_deadbeef
		   -148 5.30498947741318078777845553715802208e-315      0x00000002_deadbeef_deadbeef_deadbeef
	    
	    While the hexadecimal form shows that the arithmetic is
	    correct, the decimal form is wrong!
	    
------------------------------------------------------------------------
HP 9000/712		HP-UX 10.20
Floating-point model: 32-bit, 64-bit IEEE 754

(Mis)features:	(1) PA-RISC uses an inverted convention for quiet
		    versus signaling NaNs, compared to all other RISC
		    systems: the highest stored significand bit is 0
		    for a quiet NaN and 1 for a signaling NaN, instead
		    of the reverse.

Bugs:		(1) cc compiler generates code that loses the sign of
		    negative zero, even though the architecture
		    provides it.
------------------------------------------------------------------------
HP/Intel IA-64		GNU/Linux 2.2.17-14smp (Red Hat 6.2) [via HP NUE emulator on IA-32]
Floating-point model: 32-bit, 64-bit, 80-bit, 82-bit IEEE 754

[So far, my only access to this platform is via the HP NUE IA-64
emulator running on GNU/Linux on Intel IA-32.  hoc builds without
problems.]

Missing function prototypes (g++):
	32-bit:		truncf
	64-bit:		trunc
	80-bit:		ALL

Missing library functions (g++):
	32-bit:
	64-bit:
	128-bit:	ALL

------------------------------------------------------------------------
IBM PowerPC		AIX 4.2
Floating-point model: 32-bit, 64-bit IEEE 754, 128-bit paired double

Limitations:	(1) No float library functions whatever are provided.

Features:	(1) Multiply-add and multiply-subtract instructions
		    compute AX + B and AX - B with just one rounding,
		    and an exact product AX.  This ability was a new
		    idea in 1990 when the POWER architecture was first
		    introduced.  Since then, Hal/Fujitsu SPARC64-GP,
		    IBM S/390 G5 IEEE 754, HP/Intel IA-64, MIPS IV,
		    and National Semiconductor NS32381 have introduced
		    comparable instructions.  HP PA-RISC has similar
		    instructions, but with two roundings.  Compaq/DEC
		    Alpha and Sun SPARC lack them.  However, the Java
		    language forbids the use of such instructions, in
		    its quest to try to obtain bitwise-identical
		    results across all platforms (in practice,
		    unachievable because of differences in low-level
		    rounding algorithms).

------------------------------------------------------------------------
IBM SP/2		AIX 4.3.2.0
Floating-point model: 32-bit, 64-bit IEEE 754, 128-bit paired double

Limitations:	(1) No float library functions provided.

Bugs:		(1) Paired double quadruple-precision is seriously
		    flawed, and unreliable.

Missing function prototypes (xlC):
	32-bit:		ALL
	64-bit:
	128-bit:	acoshl asinhl atanhl cbrtl copysignl expm1l
			hypotl ilogbl j0l j1l jnl nextafterl
			remainderl rintl scalbl truncl y0l y1l ynl

Missing library functions (xlC):
	32-bit:		ALL
	64-bit:
	128-bit:	acoshl asinhl atanhl cbrtl copysignl expm1l
			hypotl ilogbl j0l j1l jnl nextafterl
			remainderl rintl scalbl truncl y0l y1l ynl

------------------------------------------------------------------------
Intel Pentium II	FreeBSD 4.1.1
Floating-point model: 32-bit, 64-bit, 80-bit IEEE 754

Missing function prototypes (CC):
	32-bit:		truncf
	64-bit:		trunc
	80-bit:		acoshl acosl asinhl asinl atanhl atanl cbrtl
			ceill copysignl coshl erfcl erfl expl expm1l
			floorl fmodl hypotl ilogbl j0l j1l jnl ldexpl
			lgammal log10l logl nextafterl powl remainderl
			rintl scalbl sinhl tanhl tanl truncl y0l y1l
			ynl

Missing library functions (CC):
	32-bit:
	64-bit:
	80-bit:

------------------------------------------------------------------------
Intel Pentium III	GNU/Linux 2.2.17-14smp (Red Hat 6.2)
Floating-point model: 32-bit, 64-bit, 80-bit IEEE 754

------------------------------------------------------------------------
Intel Pentium III	GNU/Linux 2.4.9-13smp (Red Hat 7.2)
Floating-point model: 32-bit, 64-bit, 80-bit IEEE 754

Limitations:	(1) No 80-bit support in any Fortran compiler.
		(2) Intel IA-32 architecture implements only one
		    type of NaN: hoc treats both as quiet NaNs.

(Mis)features:	(1) Intel IA-32 architecture returns a negative NaN;
		    hoc hides this by considering its value to have an
		    inverted sign.

Bugs:		(1) Portland Group pgcc and pgCC compilers, and lcc
		    compiler, are seriously broken for NaNs.  Although
		    workarounds have been installed in hoc to overcome
		    these errors, those compiler are not trustworthy for
		    other numerical software.
		(2) gcc/g++ long double signicandl() returns the
		    exponent instead of the significand! (hoc provides a
		    workaround).
		(3) With lcc and --with-float or --with-long-double, 3
	            of the 94 NaN tests failed.  Using --with-double
		    produced successful tests.  Since this compiler does
		    not produce usable debug symbols, I had to resort to
		    insertion of print statements in the code.

		    This led to the source of the failure: in
		    ieee754.c:IsInf(), the statement
		    
		    	else if ((x / BASE) == x)
		    
		    could erroneously evaluate to true for finite
		    nonzero x!
		    
		    Worse, the same hoc code executed repeatedly would
		    sometimes work, and sometimes fail!  

			./hoc
			hoc> isqnan(NaN)
			1
			hoc> isqnan(NaN)
			1
			hoc> isqnan(NaN)
			1
			hoc> isqnan(NaN)
			+Inf
			hoc> isqnan(NaN)
			+Inf

		    This happened on Intel Pentium II, Intel Pentium
		    III, and AMD Athlon systems.
		    
		    I do not understand why this is the case, because
		    the generated assembly code appears to be correct;
		    here is a fragment from a --with-float build:
		    
			flds 20(%ebp)
			flds BASE
			fdivrp %st,%st(1)
			flds 20(%ebp)
			fcompp
			fstsw %ax
			sahf
			jne .LC205

		    For comparision, g++ produces this similar code, and
		    it does not exhibit the failure:

			flds 8(%ebp)
			fdivs BASE
			flds 8(%ebp)
			fucompp
			fnstsw %ax
			andb $68,%ah
			xorb $64,%ah
			jne .L52

Missing function prototypes (g++):
	32-bit:		truncf
	64-bit:		trunc
	80-bit:		truncl

Missing library functions (g++):
	32-bit:
	64-bit:
	80-bit:

------------------------------------------------------------------------
SGI Origin 200		IRIX 6.5
Floating-point model: 32-bit, 64-bit IEEE 754, 128-bit paired double

Limitations:	(1) MIPS architecture implements only one type of NaN:
		    hoc treats both as quiet NaNs.

Bugs:		(1) Paired double quadruple-precision is seriously
		    flawed, and unreliable.

Features:	(1) SGI IRIX is the only system that I know of that
		    that attempts to provide additional information
		    about the significand bits of NaNs.  Here is a small
		    sample:

			% CC sginan.c && ./a.out
			Normal quiet NaNs...
			f.v (e-format) = nan    0x7fbfffff
			f.v (f-format) = nan0x00000007ffffe00   0x7fbfffff
			f.v (g-format) = nan0x00000007ffffe00   0x7fbfffff
			d.v (e-format) = nan    0x7ff7ffff_ffffffff
			d.v (f-format) = nan0x00000007fffffff   0x7ff7ffff_ffffffff
			d.v (g-format) = nan0x00000007fffffff   0x7ff7ffff_ffffffff
			q.v (e-format) = nan    0x7ff7ffff_ffffffff_00000000_00000000
			q.v (f-format) = nan0x00000007fffffff   0x7ff7ffff_ffffffff_00000000_00000000
			q.v (g-format) = nan0x00000007fffffff   0x7ff7ffff_ffffffff_00000000_00000000

			Modified quiet NaNs...
			f.v (e-format) = nan    0x7fb00000
			f.v (f-format) = nan0x000000060000000   0x7fb00000
			f.v (g-format) = nan0x000000060000000   0x7fb00000
			d.v (e-format) = nan    0x7ff00000_ffffffff
			d.v (f-format) = nan0x000000000000fff   0x7ff00000_ffffffff
			d.v (g-format) = nan0x000000000000fff   0x7ff00000_ffffffff
			q.v (e-format) = nan    0x7ff70000_ffffffff_00000000_00000000
			q.v (f-format) = nan0x000000070000fff   0x7ff70000_ffffffff_00000000_00000000
			q.v (g-format) = nan0x000000070000fff   0x7ff70000_ffffffff_00000000_00000000

		 (2) SGI C, C++, and Fortran compilers provide convenient options (-trapuv,
		    -DEBUG:trap_uninitialized) to catch uninitialized
		    variables:

		    % man 5 DEBUG_group
		    ...
		    trap_uninitialized[=setting]
			       Force all uninitialized stack, automatic and dynamically
			       allocated variables to be initialized with 0xFFFA5A5A.
			       setting can be ON or OFF.  When this value is used as a
			       floating point variable, it is treated as a floating point
			       NaN and it causes a floating point trap.  When it is used as
			       a pointer, an address or segmentation violation usually
			       occurs.  This option replaces -trapuv.  The default is
			       setting=OFF.
		    ...



Missing function prototypes (CC):
	32-bit:		acoshf asinhf atanhf cbrtf copysignf erfcf
			erff ilogbf j0f j1f jnf ldexpf lgammaf
			nextafterf remainderf rintf scalbf y0f y1f ynf
	64-bit:		OKAY
	128-bit:	acoshl asinhl atanhl cbrtl expm1l ilogbl
			remainderl

Missing library functions (CC):
	32-bit:
	64-bit:
	128-bit:

------------------------------------------------------------------------
Sun SPARC		GNU/Linux 2.2.19-6.2.1 (Red Hat 6.2)
Floating-point model: 32-bit, 64-bit IEEE 754

Limitations:

	(1) C/C++ long double is silently compiled as double, and this
	    works correclty and transparently with the run-time
	    library. hoc deals with this properly, but there are some
	    test128 failures because the actual precision is lower
	    than claimed.

Bugs:

	(1) QNaN's bit pattern is set incorrectly, evidently by
	    software.  The SPARC Architecture Manual, version 9, says
	    in Section B.2.2 in p. 244:

		For an invalid operation such as sqrt(-1.0) or 0.0 /
		0.0, the result is the quiet NaN with sign = zero,
		exponent = all ones, and fraction = all ones.  The
		sign is zero to distinguish such results from storage
		initialized to all ones.

	    Correct output of a simple test program that prints the
	    hexadecimal value of 0.0/0.0 on Sun Solaris is

		0x7fffffff_ffffffff

	    but on GNU/Linux on SPARC, it prints the incorrect result

		0x7ff80000_00000000

	    The bit (0x...8...._.........) that distinguishes quiet
	    and signaling NaNs is set correctly, but the remaining
	    bits are incorrect.  Of course, computationally, they do
	    not matter, but they could causes tests that compare bit
	    patterns to fail.

	    Correct output on Solaris is:

		% hoc32 -q
		hoc> __hex(0/0); __hex(QNaN); __hex(SNAN); __hex(SNaN)
		0x7fffffff == +QNaN +QNaN
		0x7fffffff == +QNaN +QNaN
		0x7f800001 == +SNaN +SNaN
		0x7f800002 == +SNaN +SNaN

		% hoc64 -q
		hoc> __hex(0/0); __hex(QNaN); __hex(SNAN); __hex(SNaN)
		0x7fffffff_ffffffff == +QNaN +QNaN
		0x7fffffff_ffffffff == +QNaN +QNaN
		0x7ff00000_00000001 == +SNaN +SNaN
		0x7ff00000_00000002 == +SNaN +SNaN

		% hoc128 -q
		hoc> __hex(0/0); __hex(QNaN); __hex(SNAN); __hex(SNaN)
		0x7fffffff_ffffffff_ffffffff_ffffffff == +QNaN +QNaN
		0x7fffffff_ffffffff_ffffffff_ffffffff == +QNaN +QNaN
		0x7fff4000_00000000_00000000_00000001 == +SNaN +SNaN
		0x7fff4000_00000000_00000000_00000002 == +SNaN +SNaN

	    Incorrect output on GNU/Linux is:

		% hoc32 -q
		hoc> __hex(0/0); __hex(QNaN); __hex(SNAN); __hex(SNaN)
		0x7fc00000 == +QNaN +QNaN
		0x7fc00000 == +QNaN +QNaN
		0x7f800001 == +SNaN +SNaN
		0x7f800002 == +SNaN +SNaN

		% hoc64 -q
		hoc> __hex(0/0); __hex(QNaN); __hex(SNAN); __hex(SNaN)
		0x7ff80000_00000000 == +QNaN +QNaN
		0x7ff80000_00000000 == +QNaN +QNaN
		0x7ff00000_00000001 == +SNaN +SNaN
		0x7ff00000_00000002 == +SNaN +SNaN

		% hoc128 -q
		hoc> __hex(0/0); __hex(QNaN); __hex(SNAN); __hex(SNaN)
		0x7ff80000_00000000 == +QNaN +QNaN
		0x7ff80000_00000000 == +QNaN +QNaN
		0x7ff00000_00000001 == +SNaN +SNaN
		0x7ff00000_00000002 == +SNaN +SNaN

	    Since hoc follows the IEEE 754 Standard, which requires
	    that 0/0 produce a quiet NaN, it generates its NaN and
	    QNaN constants that way, and generates SNaN by low-level
	    bit fiddling.  Since the GNU/Linux trap handler is
	    confused, it is not clear that the bug can be programmed
	    around, since it could show up after the execution of
	    almost any floating-point instruction.

Missing function prototypes (g++):
	32-bit:		truncf
	64-bit:		trunc
	128-bit:	acoshl acosl asinhl asinl atanhl atanl cbrtl
			ceill copysignl coshl erfcl erfl expl expm1l
			floorl fmodl hypotl ilogbl j0l j1l jnl ldexpl
			lgammal log10l logl nextafterl powl remainderl
			rintl scalbl sinhl tanhl tanl truncl y0l y1l
			ynl

Missing library functions (g++):
	32-bit:		truncf
	64-bit:		trunc
	128-bit:	acoshl acosl asinhl asinl atanhl atanl cbrtl
			ceill copysignl coshl erfcl erfl expl expm1l
			floorl fmodl hypotl ilogbl j0l j1l jnl ldexpl
			lgammal log10l logl nextafterl powl remainderl
			rintl scalbl sinhl tanhl tanl truncl y0l y1l
			ynl
------------------------------------------------------------------------
Sun SPARC		Solaris 2.7, 2.8
Floating-point model: 32-bit, 64-bit, 128-bit IEEE 754

This system is the only one tested where hoc testing found no
irregularities: kudos to Sun Microsystems!

Missing function prototypes (CC):
	32-bit:		ldexpf truncf
	64-bit:		trunc
	128-bit:	ldexpl truncl

Missing library functions (CC):
	32-bit:		ldexpf truncf
	64-bit:		trunc
	128-bit:	ldexpl truncl

Missing function prototypes (g++):
	32-bit:		acosf acoshf asinf asinhf atanf atanhf cbrtf
			ceilf copysignf coshf erfcf erff expf expm1f
			floorf fmodf hypotf ilogbf j0f j1f jnf ldexpf
			lgammaf log10f logf nextafterf powf remainderf
			rintf scalbf sinhf tanf tanhf truncf y0f y1f
			ynf

	64-bit:		trunc

	128-bit:	acoshl acosl asinhl asinl atanhl atanl cbrtl
			ceill copysignl coshl erfcl erfl expl expm1l
			floorl fmodl hypotl ilogbl j0l j1l jnl ldexpl
			lgammal log10l logl nextafterl powl remainderl
			rintl scalbl sinhl tanhl tanl truncl y0l y1l
			ynl


Missing library functions (g++, with -lsunmath):
	32-bit:		ldexpf truncf
	64-bit:		trunc
	128-bit:	ldexpl truncl
------------------------------------------------------------------------
Missing function prototypes (g++):
	32-bit:
	64-bit:
	128-bit:

Missing library functions (g++):
	32-bit:
	64-bit:
	128-bit:
