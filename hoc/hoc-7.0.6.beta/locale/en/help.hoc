### -*-hoc-*-
### /usr/local/src/hoc/hoc-7.0.0.beta/help.hoc, Sat Dec 29 18:45:28 2001
### Edit by Nelson H. F. Beebe <beebe@math.utah.edu>

### ====================================================================
### NB: Each help function below must output either a horizontal rule,
### or a final empty line, or else call another help_xxx() function,
### which will supply that empty line.  This ensures uniform appearance
### and better readability of the output of help_all().
###
### Unless it is a major sectional heading, help text must start with at
### least one tab character, and no help line should be longer than 80
### characters, after tab expansion (i.e., filling with spaces through
### the next column that is a multiple of 8, counting from 1).
###
### The functions should be ordered alphabetically, unless they call
### other functions, in which case they must come AFTER the called
### functions (because hoc requires definition-before-reference).
###
### To improve readability, empty lines in output documentation should
### be produced by \n\n in a print statement, and that statement should
### itself be followed by an empty line in the procedure body.
### ====================================================================

### Help on miscellaneous functions

proc help_author() \
{
	print "\tauthor() prints information about the program authors.\n"
}

proc help_news() \
{
	print "\tnews() prints news about recent program developments.\n"
}

proc help_now() \
{
	print "\tnow() returns the current date, in the form \"Dec  8 2001\".\n"
	print "\tIf the month day has only one digit, then it is preceded by an\n"
	print "\textra space, so that the format is uniformly \"MMM DD YYYY\".\n\n"
}

### Help for predefined constants

proc __internal_help_hrule() \
{
	print "------------------------------------------------------------------------\n"
}

proc help() \
{
	__internal_help_hrule()
	print "\tAdditional help is available with the function help_NAME(),\n"
	print "\twhere NAME is any named constant, or built-in function, or\n"
	print "\tstatement, or topic:\n\n"

	print "\tNamed constants:\n"
	print "\t\tCATALAN, DEG, E, GAMMA, INF, Inf, Infinity, MAXNORMAL,\n"
	print "\t\tMINNORMAL, MINSUBNORMAL, NAN, NaN, PHI, PI, QNAN,\n"
	print "\t\tQNaN, SNAN, SNaN\n\n"

	print "\tBuilt-in numeric functions:\n"
	print "\t\tabs(), acos(), acosh(), asin(), asinh(), atan(),\n"
	print "\t\tatanh(), cbrt(), ceil(), cos(), cosd(), cosh(), erf(),\n"
	print "\t\terfc(), exp(), expm1(), factorial(), floor(), gamma(),\n"
	print "\t\tgcd(), hypot(), int(), J0(), J1(), Jn(), lcm(),\n"
	print "\t\tlgamma(), ln(), log(), log10(), log1p(), log2(), logb(),\n"
	print "\t\tmacheps(), max(), min(), nint(), rand(), randint(),\n"
	print "\t\trandl(), rint(), rsqrt(), second(), setrand(), sin(),\n"
	print "\t\tsind(), sinh(), sqrt(), systime(), tan(), tand(), tanh(),\n"
	print "\t\ttrunc(), Y0(), Y1(), Yn()\n\n"

	print "\tBuilt-in IEEE 754 test functions:\n"
	print "\t\tcopysign(), fmod(), ilogb(), isfinite(), isinf(),\n"
	print "\t\tisnan(), isnormal(), isqnan(), issnan(), issubnormal(),\n"
	print "\t\tldexp(), nearest(), nextafter(), remainder(), scalb(),\n"
	print "\t\tsignificand()\n\n"

	print "\tString functions:\n"
	print "\t\tgetenv(), index(), length(), printenv(), putenv(),\n"
	print "\t\tstrftime(), substr(), tolower(), toupper()\n\n"

	print "\tOther functions:\n"
	print "\t\tabort(), eval(), load(), logfile(), logon(), logoff(),\n"
	print "\t\tnow(), save(), who(), __msg_translate(), __set_locale()\n\n"

	print "\tStatements:\n"
	print "\t\tassignment expression for function if operator print\n"
	print "\t\tprintf proc read statement while\n\n"

	print "\tTopics:\n"
	print "\t\tconstants, environment, expressions, functions,\n"
	print "\t\tieee_754, limits, locales, operators, random,\n"
	print "\t\tstatements, string_functions, time\n\n"

	print "\tType help_all() for complete details.\n"
	__internal_help_hrule()
}

proc help__() \
{
	print "\t_ is the name of the last result printed.\n\n"

	print "\tIt cannot be reassigned by user code.\n\n"
}

proc help___BANNER__() \
{
	print "\t__BANNER__ is nonzero if welcome banners are to be printed,\n"
	print "\tand zero if they are to be suppressed.\n\n"

	print "\tIt can be reassigned at any time by user code, but of course\n"
	print "\tonly has an effect at startup time.\n\n"
}

proc help___CPU_LIMIT__() \
{
	print "\t__CPU_LIMIT__ is set by cpulimit() to record the current limit\n"
	print "\t(in seconds) on CPU time use.  If cpulimit() is never called,\n"
	print "\tthis variable is never set.\n\n"
}

proc help___DATE__() \
{
	print "\t__DATE__ is the date of job start, in the form \"Dec  8 2001\".\n"
	print "\tIf the month day has only one digit, then it is preceded by an\n"
	print "\textra space, so that the format is uniformly \"MMM DD YYYY\".\n\n"

	print "\tIt cannot be reassigned by user code.\n\n"
}

proc help___FILE__() \
{
	print "\t__FILE__ is the name of the current input file.\n\n"

	print "\tIt cannot be reassigned by user code.\n\n"
}

proc help___IEEE_754__() \
{
	print "\t__IEEE_754__ is 1 if the host supports IEEE 754 arithmetic,\n"
	print "\talthough perhaps only partially, and 0 otherwise.\n\n"

	print "\tIt cannot be reassigned by user code.\n\n"
}

proc help___LINE__() \
{
	print "\t__LINE__ is the line number in the current input file (see\n"
	print "\thelp___FILE__()).  It is reset to 1 at the start of each new\n"
	print "\tinput file.\n\n"

	print "\tIt cannot be reassigned by user code.\n\n"
}

proc help___PACKAGE_BUGREPORT__() \
{
	print "\t__PACKAGE_BUGREPORT__ is the name and address for bug reports.\n\n"

	print "\tIt cannot be reassigned by user code.\n\n"
}

proc help___PACKAGE_DATE__() \
{
	print "\t__PACKAGE_DATE__ is the package release date.\n\n"

	print "\tIt cannot be reassigned by user code.\n\n"
}

proc help___PACKAGE_NAME__() \
{
	print "\t__PACKAGE_NAME__ is the official package name, which may\n"
	print "\tdiffer from the name of the installed executable program.\n\n"

	print "\tIt cannot be reassigned by user code.\n\n"
}

proc help___PACKAGE_STRING__() \
{
	print "\t__PACKAGE_STRING__ is the package name and version number.\n\n"

	print "\tIt cannot be reassigned by user code.\n\n"
}

proc help___PACKAGE_VERSION__() \
{
	print "\t__PACKAGE_VERSION__ is the package version number.\n\n"

	print "\tIt cannot be reassigned by user code.\n\n"
}

proc help___PROMPT__() \
{
	print "\t__PROMPT__ is the current prompt string, used when verbose mode\n"
	print "\t(see help___VERBOSE__()) is in effect.\n\n"

	print "\tIt can be reassigned at any time by user code.\n\n"

	print "\tFor example,\n\n"

	print "\t	__PROMPT__ = \"\\n\\E[7mInput:\\E[0m \"\n\n"

	print "\twill produce a blank line followed by a prompt in inverse video\n"
	print "\tin terminal emulators, such as xterm and DEC VT100, that follow\n"
	print "\tthe ANSI X3.64-1979 or ISO 6429-1983 terminal standards.\n\n"
}

proc help___TIME__() \
{
	print "\t__TIME__ is the local time of job start, in the form \"HH:MM:SS\".\n"
	print "\tIt is NOT updated during execution.  See help_now() instead.\n"
	print "\tIt cannot be reassigned by user code.\n\n"
}

proc help___VERBOSE__() \
{
	print "\t__VERBOSE__ is 1 when input prompts are turned on, and 0 when\n"
	print "\tthey are suppressed (e.g., by the --silent option).\n\n"

	print "\tIt can be reassigned at any time by user code.\n\n"
}

proc help___msg_translate() \
{
	print "\t__msg_translate(msg) looks up the message string, msg, in hoc's\n"
	print "\ttranslation tables, and if a nonempty translation exists,\n"
	print "\treturns that translation; otherwise, it returns its argument,\n"
	print "\tmsg.\n\n"

	print "\tPlease use this function in your own hoc code to ensure that\n"
	print "\tyour messages can be translated without any changes whatsoever\n"
	print "\tto your code.\n\n"
}

proc help___set_locale() \
{
	print "\t__set_locale()(localecode) loads the locale files for the locale\n"
	print "\tidentified by localecode.  This must correspond to a\n"
	print "\tsubdirectory of the hoc system directory, which is\n\n"

	print "\t\t", __SYSHOCDIR__, "\n\n"

	print "\tin this installation.\n\n"

	print "\tSince __set_locale() is a long name, up to three shorthand\n"
	print "\tprocedures are provided for each language: the two-letter\n"
	print "\tcountry code, the native name for the language, and the English\n"
	print "\tname for the language.  Thus, da(), dansk(), and danish() all\n"
	print "\tswitch to the Danish locale, and en(), engelsk(), and english()\n"
	print "\tswitch to the default English locale.\n\n"
}

proc help_CATALAN() \
{
	print "\tCATALAN is Catalan's constant,\n"
	print "\tapproximately ", CATALAN, ".\n"
	print "\tCATALAN is sum(i=0...infinity)((-1)^i/(2*i+1)^2)\n\n"

	print "\tIt cannot be reassigned by user code.\n\n"
}

proc help_DEG() \
{
	print "\tDEG is degrees per radian, 180/PI,\n"
	print "\tapproximately ", DEG, ".\n\n"

	print "\tIt cannot be reassigned by user code.\n\n"
}

proc help_E() \
{
	print "\tE is the base of the natural logarithm,\n"
	print "\tapproximately ", E, ".\n"
	print "\tE is sum(k = 0...Infinity)(1/k!)\n\n"

	print "\tIt cannot be reassigned by user code.\n\n"
}

proc help_GAMMA() \
{
	print "\tGAMMA is the Euler-Mascheroni constant,\n"
	print "\tapproximately ", GAMMA, ".\n"
	print "\tGAMMA is limit(sum(i = 1...n)(1/i) - ln(n), n -> infinity)\n\n"

	print "\tIt cannot be reassigned by user code.\n\n"
}

proc help_Infinity() \
{
	print "\tInfinity is the IEEE-754 floating-point infinity.  It is\n"
	print "\tproduced when a numeric result is too large to represent, such\n"
	print "\tas from overflow, or from nonzero/zero.\n\n"

	print "\tInfinity is a signed value.\n\n"

	print "\tInfinity obeys the usual mathematical properties:\n"
	print "\t\tfinite / Infinity -> 0\n"
	print "\t\tfinite * Infinity -> Infinity\n"
	print "\t\tInfinity / finitepositive -> Infinity\n"
	print "\t\tInfinity / finitenegative -> -Infinity\n"
	print "\t\tInfinity + Infinity -> Infinity\n"
	print "\t\tInfinity * Infinity -> Infinity\n"
	print "\t\tsqrt(Infinity) -> Infinity\n\n"

	print "\tHowever:\n"
	print "\t\tInfinity - Infinity -> NaN\n"
	print "\t\tInfinity / Infinity -> NaN\n\n"

	print "\tInfinity cannot be reassigned by user code.\n\n"
}

proc help_INF() \
{
	print "\tINF is a synonym for Infinity.\n\n"

	help_Infinity()
}

proc help_Inf() \
{
	print "\tInf is a synonym for Infinity.\n\n"

	help_Infinity()
}

proc help_NaN() \
{
	print "\tNaN is the IEEE-754 floating-point Not-a-Number.  It is produced\n"
	print "\twhen a numeric result is not predictable, even in a limiting\n"
	print "\tsense, such as from 0/0, sqrt(x) (when x < 0),\n"
	print "\tInfinity - Infinity, or when NaN appears as the argument to any\n"
	print "\tfunction, or as the operand of a binary operator.\n\n"

	print "\tNaN may be optionally signed.\n\n"

	print "\tNaN has the distinctive property that it is the ONLY IEEE-754\n"
	print "\tfloating-point number that is not equal to anything, not even\n"
	print "\titself!  Thus, (x != x) is true (1) if and only if x is a NaN.\n\n"

	print "\tNaNs may in principle be further distinguished as signaling or\n"
	print "\tquiet.  However, some floating-point architectures do not\n"
	print "\tsupport signaling NaNs, and arithmetic operations produce only\n"
	print "\tquiet NaNs.  Thus, we usually do not make a distinction between\n"
	print "\tthem.\n\n"

	print "\tNaN cannot be reassigned by user code.\n\n"
}

proc help_NAN() \
{
	print "\tNAN is a synonym for NaN.\n\n"

	help_NaN()
}

proc help_PHI() \
{
	print "\tPHI is the golden ratio, (1 + sqrt(5))/2,\n"
	print "\tapproximately ", PHI, ".\n\n"

	print "\tIt cannot be reassigned by user code.\n\n"
}

proc help_PI() \
{
	print "\tPI is the ratio of the circumference of a circle to its\n"
	print "\tdiameter, approximately ", PI, ".\n\n"

	print "\tIt cannot be reassigned by user code.\n\n"
}

proc help_PREC() \
{
	print "\tPREC is the output precision, the number of digits to show in\n"
	print "\toutput floating-point values (default: 17).\n\n"

	print "\tIt can be reassigned at any time by user code.\n\n"
}

proc help_QNaN() \
{
	print "\tQNaN is a quiet NaN.\n\n"

	help_NaN()
}

proc help_QNAN() \
{
	print "\tQNAN is a synonym for QNaN.\n\n"

	help_QNaN()
}

proc help_SNaN() \
{
	print "\tSNaN is a signaling NaN, provided that the host floating-point\n"
	print "\tarchitecture supports one. Some do not (e.g., Intel IA-32 and\n"
	print "\tMIPS), so on those, SNaN is a quiet NaN, and issnan(SNaN) will\n"
	print "\tthen be 0 (false).\n\n"

	print "\tOn this system, issnan(SNaN) reports: ", issnan(SNaN), "\n\n"

	help_NaN()
}

proc help_SNAN() \
{
	print "\tSNAN is a synonym for SNaN.\n\n"

	help_SNaN()
}

### Help for built-in functions

proc help_abort() \
{
	print "\tabort(message) prints message, then aborts evaluation of the\n"
	print "\tcurrent expression, returning to top-level without further\n"
	print "\tprocessing of the remainder of the current statement or\n"
	print "\tfunction/procedure call chain.  The message should include the\n"
	print "\tname of the function calling abort(), since there is currently\n"
	print "\tno function call traceback, and end with a newline.\n\n"
}

proc help_abs() \
{
	print "\tabs(x) returns the absolute value of x.\n\n"
}

proc help_acos() \
{
	print "\tacos(x) returns the arc cosine of x.\n"
	print "\tx must be in [-1...+1].\n\n"
}

proc help_acosh() \
{
	print "\tacosh(x) returns the inverse hyperbolic cosine of x.\n"
	print "\tx must be outside the interval (-1.0...1.0).\n\n"
}

proc help_asin() \
{
	print "\tacos(x) returns the arc cosine of x.\n"
	print "\tx must be in [-1...+1].\n\n"
}

proc help_asinh() \
{
	print "\tasinh(x) returns the inverse hyperbolic sine of x.\n\n"
}

proc help_atan() \
{
	print "\tatan(x) returns the arc tangent of x.\n\n"
}

proc help_atanh() \
{
	print "\tatanh(x) returns the inverse hyperbolic tangent of x.\n\n"
}

proc help_cbrt() \
{
	print "\tcbrt(x) returns the cube root of x.\n\n"
}

proc help_ceil() \
{
	print "\tceil(x) returns the smallest integer greater than or equal to x.\n\n"
}

proc help_copysign() \
{
	print "\tcopysign(x,y) returns a value with the magnitude of x, and the\n"
	print "\tsign of y.\n\n"
}

proc help_cos() \
{
	print "\tcos(x) returns the cosine of x (x in radians).\n"
	print "\tExpect severe accuracy loss for large |x|.\n\n"
}

proc help_cosd() \
{
	print "\tcosd(x) returns the cosine of x (x in degrees).\n"
	print "\tExpect severe accuracy loss for large |x|.\n\n"
}

proc help_cosh() \
{
	print "\tcosh(x) returns the hyperbolic cosine of x.\n\n"
}

proc help_cpulimit() \
{
	## NB: Because this function is experimental, it is not
	## currently mentioned anywhere else in this help file!

	print "\tcpulimit(t) sets the CPU time limit from now to an additional t\n"
	print "\tseconds, sets the system variable __CPU_LIMIT__ to t, and\n"
	print "\treturns the current CPU time limit, which is always measured\n"
	print "\tfrom the START of the job.\n\n"

	print "\tIf the limit is exceeded, execution of the current expression is\n"
	print "\taborted, control returns to the top-level interpreter, and the\n"
	print "\ttime limit is incremented by the current value of __CPU_LIMIT__.\n\n"

	print "\tAlthough t may be fractional, on most operating systems, the\n"
	print "\ttime limit is an integer, so t will be rounded up internally to\n"
	print "\tthe nearest integer before setting the time limit.\n\n"

	print "\tIf resource usage and limits are not supported on the current\n"
	print "\tplatform, this function has no effect, other than setting\n"
	print "\t__CPU_LIMIT__, and returning Infinity.\n\n"

	print "\tBy default, there is no time limit for the job (although some\n"
	print "\toperating systems may impose such limits).\n\n"

	print "\tNegative, zero, and NaN arguments are treated like Infinity.\n\n"

	print "\tNB: This function is EXPERIMENTAL, and may be withdrawn in\n"
	print "\tfuture versions.\n\n"
}

proc help_endinput() \
{
	print "\tendinput() sets an internal flag that terminates reading of the\n"
	print "\tcurrent file at the time the next input line is requested.\n\n"

	print "\tThus, an input line containing\n\n"

	print "\t\tendinput(); x = 3\n\n"

	print "\twill complete the assignment to x, whereas the assignment would\n"
	print "\tnot be reached with input like this:\n\n"

	print "\t\tendinput()\n"
	print "\t\tx = 3\n\n"

	print "\tThis function can be conveniently used to avoid loading the\n"
	print "\tremainder of large packages if a flag has been set to show that\n"
	print "\tthe package has already been loaded:\n\n"

	print "\t\tif (defined(foo_has_been_loaded)) endinput()\n"
	print "\t\t... long package follows ...\n"
	print "\t\tfoo_has_been_loaded = 1\n\n"
}

proc help_erf() \
{
	print "\terf(x) returns the error function of x.\n\n"
}

proc help_erfc() \
{
	print "\terfc(x) returns the complementary error function of x.\n\n"
}

proc help_errbits() \
{
	print "\terrbits(x,y), with y an approximation to x, returns the number\n"
	print "\tof bits that y is in error by.\n\n"
}

proc help_eval() \
{
	print "\teval(string) pushes its argument string, which must contain\n"
	print "\tvalid hoc code, onto the input stack so that it will be\n"
	print "\tevaluated next.  The size of the input stack is limited only by\n\n"
	print "\tavailable memory.\n\n"

	print "\tThis function makes it possible for hoc programs to construct\n"
	print "\tnew hoc code on-the-fly and then run it.\n\n"
}

proc help_exp() \
{
	print "\texp(x) returns the exponential function of x, E^x.\n\n"
}

proc help_expm1() \
{
	print "\texpm1(x) returns the exponential function of x, less 1: E^x - 1.\n\n"

	print "\tFor small x, exp(x) is approximately 1, so there is serious\n"
	print "\tsubtraction loss in directly using exp(x) - 1; expm1(x) avoids\n"
	print "\tthis loss.\n\n"

	print "\tFrom Sun Solaris documentation: ``The expm1() and log1p()\n"
	print "\tfunctions are useful for financial calculations of\n"
	print "\t((1 + x)^n - 1) / x, namely:\n\n"

	print "\t	expm1(n * log1p(x))/x\n\n"

	print "\twhen x is very small (for example, when performing calculations\n"
	print "\twith a small daily interest rate).  These functions also\n"
	print "\tsimplify writing accurate inverse hyperbolic functions.''\n\n"
}

proc help_exponent() \
{
	print "\texponent(x) returns the base-2 exponent of x, such that\n\n"

	print "\t\tx == significand(x) * 2^exponent(x)\n\n"

	print "\twhere |significand(x)| is in [1...2).\n\n"

	print "\tFor IEEE 754 arithmetic, normal numbers have exponent(x) in\n"
	print "\t[-1022...1023] and subnormal numbers, if supported, have\n"
	print "\texponent(x) in [-1074...1023].\n\n"

	print "\tWARNING: The power 2^exponent(x) will underflow to zero for IEEE\n"
	print "\t754 subnormal numbers, so for such numbers, the right-hand side\n"
	print "\tmust be computed with suitable scaling, like this:\n\n"

	print "\t\t(significand(x) * 2^(exponent(x) + 52)) * 2^(-52)\n\n"
}


proc help_factorial() \
{
	print "\tfactorial(n) returns n! = n*(n-1)*(n-2)*...*1, where\n"
	print "\t1! == 0! == 1.   Negative arguments generate a call to abort().\n\n"
}

proc help_floor() \
{
	print "\tfloor(x) returns the greatest integer less than or equal to x.\n\n"
}

proc help_fmod() \
{
	print "\tfmod(x,y) returns the remainder of the division of x by y.\n\n"
}

proc help_gamma() \
{
	print "\tgamma(x) returns the Gamma (generalized factorial) function\n"
	print "\tof x.\n\n"
}

proc help_gcd() \
{
	print "\tgcd(x,y) returns the greatest common divisor of x and y.\n\n"
}

proc help_getenv() \
{
	print "\tgetenv(envvar) returns the string value of the environment\n"
	print "\tvariable envvar, or an empty string if it is not defined.\n\n"
}

proc help_hexfp() \
{
	print "\thexfp(x) returns a string containing the hexadecimal\n"
	print "\tfloating-point representation of x, in the form\n\n"

	print "\t\t\"+0x1.hhhhh...p+ddddd\"\n\n"

	print "\tTrailing zeros in the fraction, and leading zeros in the\n"
	print "\texponent, are dropped, and the sign is always included.\n\n"

	print "\tSee also help_hexint(), help_number(), and help_string().\n\n"
}

proc help_hexint() \
{
	print "\thexint(x) returns a string containing the hexadecimal integer\n"
	print "\trepresentation of x, if that is possible, in the form\n\n"

	print "\t\t\"+0xhhhhh...\"\n\n"

	print "\tLeading zeros are dropped, and the sign is always included.\n\n"

	print "\tIf x is too big to represent as an exact integer, then the\n"
	print "\tfloating-point representation, hexfp(x), is returned instead.\n\n"

	print "\tSee also help_hexfp(), help_number(), and help_string().\n\n"
}

proc help_hypot() \
{
	print "\thypot(x,y) function computes the length of the hypotenuse of a\n"
	print "\tright-angled triangle, sqrt(x^2 + y^2), but without accuracy\n"
	print "\tloss or range limitation from premature overflow or underflow.\n\n"

	print "\tThis function has possibly unexpected behavior for exceptional\n"
	print "\targuments: when either argument is Infinity, then the result is\n"
	print "\tInfinity, EVEN IF the other argument is a NaN!  The explanation\n"
	print "\tis found on the 4.3BSD manual page:\n\n"

	print "\t\t... programmers on machines other than a VAX (it has no\n"
	print "\t\tinfinity) might be surprised at first to discover that\n"
	print "\t\thypot(+infinity,NaN) = +infinity.  This is intentional;\n"
	print "\t\tit happens because hypot(infinity,v) = +infinity for all\n"
	print "\t\tv, finite or infinite.  Hence hypot(infinity,v) is\n"
	print "\t\tindependent of v.  Unlike the reserved operand on a VAX,\n"
	print "\t\tthe IEEE NaN is designed to disappear when it turns out\n"
	print "\t\tto be irrelevant, as it does in hypot(infinity,NaN). ...\n\n"
}

proc help_ilogb() \
{
	print "\tilogb(x) returns the exponent part of x, that is, int(log2(x)).\n\n"
}

proc help_int() \
{
	print "\tint(x) returns the integer part (truncated toward zero) of x.\n\n"
}

proc help_index() \
{
	print "\tindex(s,t) returns the index of string t in string s, counting\n"
	print "\tfrom 1, or 0 if t is not found in s.\n\n"
}

proc help_isfinite() \
{
	print "\tisfinite(x) returns 1 (true) if x is finite and otherwise,\n"
	print "\t0 (false).\n\n"
}

proc help_isinf() \
{
	print "\tisinf(x) returns 1 (true) if x is Infinite, and otherwise,\n"
	print "\t0 (false).\n\n"
}

proc help_isnan() \
{
	print "\tisnan(x) returns 1 (true) if x is a NaN, and otherwise,\n"
	print "\t0 (false).\n\n"
}

proc help_isnormal() \
{
	print "\tisnormal(x) returns 1 (true) if x is finite and normalized and\n"
	print "\tnot subnormal, and otherwise, 0 (false).\n\n"
}

proc help_isqnan() \
{
	print "\tisqnan(x) returns 1 (true) if x is a quiet NaN, and otherwise,\n"
	print "\t0 (false).\n\n"

	print "\tOn some architectures (e.g., Intel x86 and MIPS), there is\n"
	print "\tonly one type of NaN.  isqnan(x) is then defined to return 1\n"
	print "\t(true) if x is a NaN.\n\n"
}

proc help_issnan() \
{
	print "\tissnan(x) returns 1 (true) if x is a signaling NaN, and\n"
	print "\totherwise, 0 (false).\n\n"

	print "\tOn some architectures (e.g., Intel x86 and MIPS), there is\n"
	print "\tonly one type of NaN.  issnan(x) is then defined to return 1\n"
	print "\t(true) if x is a NaN.\n\n"

	print "\tYou can test whether your system has both quiet and signaling\n"
	print "\tNaNs like this: issnan(NaN).  The result is 0 (false) if\n"
	print "\tdistinct NaN types are available, and 1 (true) if not.\n\n"
}

proc help_issubnormal() \
{
	print "\tissubnormal(x) returns 1 (true) if x is subnormal (formerly,\n"
	print "\tdenormalized), and otherwise, 0 (false).\n\n"
}

proc help_J0() \
{
	print "\tJ0(x) returns the Bessel function of the first kind of order 0\n"
	print "\tof x.\n\n"
}

proc help_J1() \
{
	print "\tJ1(x) returns the Bessel function of the first kind of order 1\n"
	print "\tof x.\n\n"
}

proc help_Jn() \
{
	print "\tJn(n,x) returns the Bessel function of the first kind of\n"
	print "\tintegral order n of x.\n\n"
}

proc help_lcm() \
{
	print "\tlcm(x,y) returns the least common multiple of int(x) and int(y).\n\n"
}

proc help_ldexp() \
{
	print "\tldexp(x,y) returns x * 2^(int(y)).\n\n"
}

proc help_length() \
{
	print "\tlength(s) returns the length of string s.\n\n"
}

proc help_lgamma() \
{
	print "\tlgamma(x) returns the natural logarithm of gamma(x).\n\n"

	print "\tBecause gamma(x) has poles at zero and at negative integer\n"
	print "\tvalues, and grows factorially with increasing x, it reaches the\n"
	print "\tfloating-point overflow limit fairly quickly.  For 64-bit IEEE\n"
	print "\t754 arithmetic, this happens at approximately x = 206.779.\n"
	print "\tHowever, lgamma(x) is representable almost to the overflow\n"
	print "\tlimit.  In 64-bit IEEE 754 arithmetic, this happens at\n"
	print "\tapproximately x = 2.55e+306 (the overflow limit is 1.80e+308).\n\n"

	print "\tUnfortunately, there is mathematically-unavoidable accuracy loss\n"
	print "\twhen gamma(x) is computed from exp(lgamma(x)), so you should\n"
	print "\tavoid the logarithmic form unless you really need large\n"
	print "\targuments that would cause overflow.\n\n"
}

proc help_ln() \
{
	print "\tln(x) returns the natural (base-E) logarithm of x.\n\n"
}

proc help_load() \
{
	print "\tload(\"filename\") reads input from the specified file.  The\n"
	print "\tfile can be prepared by hand, or by the save() command.\n\n"
}

proc help_locales() \
{
	print "\thoc supports multiple locales, or language environments.\n"
	print "\tChanging the locale potentially changes all text strings that\n"
	print "\thoc can display, although much translation work remains needs to\n"
	print "\tbe done to complete the job.\n\n"

	print "\tAt present, all hoc documentation is written in one of the\n"
	print "\tISO8559-n 8-bit character set encodings.  In order to achieve\n"
	print "\tcorrect character display, your terminal emulator must be using\n"
	print "\tfonts in the corresponding encoding.  Few terminal emulators\n"
	print "\tprovide dynamic changing of fonts, so you will like have to\n"
	print "\tselect an appropriate font set when you start the terminal\n"
	print "\tsession.\n\n"

	print "\tThese locales, and expected encodings, are currently recognized:\n\n"

	print "\t\tda\tDanish\t\tISO8859-1 (Latin 1)\n"
	print "\t\tde\tGerman\t\tISO8859-1 (Latin 1)\n"
	print "\t\ten\tEnglish\t\tISO8859-1 (Latin 1)\n"
	print "\t\tes\tSpanish\t\tISO8859-1 (Latin 1)\n"
	print "\t\tfr\tFrench\t\tISO8859-1 (Latin 1)\n"
	print "\t\thr\tCroatian\tISO8859-2 (Latin 2)\n"
	print "\t\tpt\tPortuguese\tISO8859-1 (Latin 1)\n"
	print "\t\ttr\tTurkish\t\tISO8859-9 (Latin 5)\n\n"

	print "\tFor demonstration purposes, the top-level welcome banner, the\n"
	print "\thelp() function, and a small number of other functions are\n"
	print "\tprovided in several languages.  For at least Danish and French,\n"
	print "\tall of hoc's internal messages are also translated.\n\n"

	print "\t****************************************************************\n"
	print "\t****************************************************************\n"
	print "\t** If you can help with new or improved translations for      **\n"
	print "\t** existing languages, or for as-yet-unsupported languages,   **\n"
	print "\t** please contact the program maintainer (help_author() for   **\n"
	print "\t** details).  You do not need to be a computer programmer,    **\n"
	print "\t** only skilled in English and one or more other languages.   **\n"
	print "\t** hoc has been carefully designed to allow such work to be   **\n"
	print "\t** done in small steps, with a fallback to the original       **\n"
	print "\t** English text until a translation is available.             **\n"
	print "\t****************************************************************\n"
	print "\t****************************************************************\n\n"

	print "\tA locale can be selected at startup time by defining one of the\n"
	print "\tenvironment variables LC_ALL, LC_MESSAGES, or LANG to a locale\n"
	print "\tcode, which is often the ISO two-letter country code.  In a\n"
	print "\tUNIX-like system, this can be done in all shells just for the\n"
	print "\tcurrent hoc session like this example for French:\n\n"

	print "\t\tenv LANG=fr hoc\n\n"

	print "\tYou can also permanently set locale variables in your shell\n"
	print "\tstartup files, but this can have far-reaching consequences,\n"
	print "\tsince many programs may then behave differently.\n\n"

	print "\thoc also allows the locale to be changed dynamically with the\n"
	print "\t__set_locale() function.  Since that is a long name, up to\n"
	print "\tthree shorthand procedures are provided for each language: the\n"
	print "\ttwo-letter country code, the native name for the language, and\n"
	print "\tthe English name for the language.  Thus, da(), dansk(), and\n"
	print "\tdanish() all switch to the Danish locale, and en(), engelsk(),\n"
	print "\tand english() switch to the default English locale.\n\n"
}


proc help_log() \
{
	print "\tlog(x) returns the natural (base-E) logarithm of x.\n\n"
}

proc help_log1p() \
{
	print "\tlog1p(x) returns log(1 + x), but without accuracy loss for\n"
	print "\tsmall |x|.  x must be in (-1.0,infinity].\n\n"
}

proc help_log2() \
{
	print "\tlog2(x) returns the logarithm to the base 2 of x.\n\n"
}

proc help_log10() \
{
	print "\tlog10(x) returns the logarithm to the base 10 of x.\n\n"
}

proc help_logb() \
{
	print "\t\nlogb(b,x) returns the logarithm to the base b of x.\n\n"
}

proc help_logfile() \
{
	print "\tlogfile(\"filename\") logs the session on the specified file,\n"
	print "\twhich, for security reasons, MUST be a new file.  It is a normal\n"
	print "\ttext that you can edit, print, and view.\n\n"

	print "\tInput is recorded verbatim.  Output is recorded in comments.\n"
	print "\tThis permits the logfile to be read by hoc later, allowing a\n"
	print "\tsession to be replayed.\n\n"

	print "\tIf a logfile is already opened, it is closed before opening\n"
	print "\tthe new one.\n\n"

	print "\tLogging may be turned on and off with logon() and logoff().\n\n"
}

proc help_logoff() \
{
	print "\tlogoff() suspends logging to any open log file.  It is NOT an\n"
	print "\terror if there is no current log file.\n\n"
}

proc help_logon() \
{
	print "\tlogon() restores logging to any open log file.  It is NOT an\n"
	print "\terror if there is no current log file.\n\n"
}

proc help_macheps() \
{
	print "\tmacheps(x) returns the generalized machine epsilon of x, the\n"
	print "\tsmallest number which, when added to x, produces a sum that\n"
	print "\tstill differs from x: (x + macheps(x)) != x.\n\n"

	print "\tmacheps(1.0) is the normal machine epsilon.\n\n"

	print "\tmacheps(-x) is macheps(x)/base, or equivalently, the smallest\n"
	print "\tnumber that can be subtracted from x with the result still\n"
	print "\tdifferent from x.\n\n"

	print "\tmacheps(0.0) is the smallest representable floating-point\n"
	print "\tnumber.  Depending on the host system, it may be a normal\n"
	print "\tnumber, or a subnormal number (type help_subnormal() for\n"
	print "\tdetails).\n\n"
}

proc help_max() \
{
	print "\tmax(x,y) returns the larger of x and y.\n\n"

	print "If either argument is a NaN, the result is a NaN.\n\n"
}

proc help_maxnormal() \
{
	print "\tmaxnormal() returns the maximum positive normal number.\n\n"
}

proc help_min() \
{
	print "\tmin(x,y) returns the smaller of x and y.\n\n"

	print "If either argument is a NaN, the result is a NaN.\n\n"
}

proc help_minnormal() \
{
	print "\tminnormal() returns the minimum positive normal number.\n\n"
}

proc help_nearest() \
{
	print "\tnearest(x,y) returns the next different machine number nearest\n"
	print "\tx, in the direction of the infinity with the same sign as y.\n\n"
}

proc help_nextafter() \
{
	print "\tnextafter(x,y) returns the nearest machine number nearest x, in\n"
	print "\tthe direction of the infinity with the same sign as y.\n\n"
}

proc help_nint() \
{
	print "\tnint(x) returns the nearest integer to x, rounding away from\n"
	print "\tzero in case of a tie.\n\n"
}

proc help_rand() \
{
	print "\trand() returns a pseudo-random number uniformly distributed\n"
	print "\ton (0...1).  Unless the seed is changed (see help_setrand()),\n"
	print "\tsuccessive runs of the same program will generate the same\n"
	print "\tsequence of pseudo-random numbers.\n\n"

	print "\tSee help_randint() for uniformly-distributed integers in an\n"
	print "\tinterval, and help_randl() for logarithmically-distributed\n"
	print "\tpseudo-random numbers.\n\n"

	print "\tThe pseudo-random generator algorithm is platform-independent,\n"
	print "\tallowing reproduction of the same number sequence on any\n"
	print "\tcomputer architecture.\n\n"
}

proc help_randint() \
{
	print "\trandint(x,y) returns a pseudo-random integer uniformly\n"
	print "\tdistributed on [int(x)...int(y)].  Unless the seed is changed\n"
	print "\t(see help_setrand()), successive runs of the same program will\n"
	print "\tgenerate the same sequence of pseudo-random numbers.\n\n"

	print "\tThe pseudo-random generator algorithm is platform-independent,\n"
	print "\tallowing reproduction of the same number sequence on any\n"
	print "\tcomputer architecture.\n\n"
}

proc help_randl() \
{
	print "\trandl(x) returns a pseudo-random number logarithmically\n"
	print "\tdistributed on (1,exp(x)).  Unless the seed is changed\n"
	print "\t(see help_setrand()), successive runs of the same program\n"
	print "\twill generate the same sequence of pseudo-random numbers.\n\n"

	print "\tThis function can be used to generate logarithmic distributions\n"
	print "\ton any interval: a*randl(ln(b/a)) is logarithmically distributed\n"
	print "\ton (a...b).\n\n"

	print "\tThe pseudo-random generator algorithm is platform-independent,\n"
	print "\tallowing reproduction of the same number sequence on any\n"
	print "\tcomputer architecture.\n\n"
}

proc help_remainder() \
{
	print "\tremainder(x,y) returns the remainder r = x - n*y, where n is the\n"
	print "\tintegral value nearest the exact value x/y.  When |n - x/y| =\n"
	print "\t1/2, the value of n is chosen to be even.\n\n"
}

proc help_rint() \
{
	print "\trint(x) returns the integral value nearest x in the direction of\n"
	print "\tthe current IEEE 754 rounding mode.\n\n"
}

proc help_rsqrt() \
{
	print "\trsqrt(x) returns the reciprocal square root, 1/sqrt(x).\n\n"
}

proc help_save() \
{
	print "\tsave(\"filename\",\"prefix\") saves the state of the current\n"
	print "\tsession in the specified file, which, for security reasons,\n"
	print "\tMUST be a new file.\n\n"

	print "\tIf the prefix string is not empty, then only symbols whose\n"
	print "\tinitial characters match the prefix string are saved.\n\n"

	print "\tSymbols are output in strict alphabetical order\n\n"

	print "\tReserved symbol names (those beginning with two or more\n"
	print "\tunderscores) are not saved.  Predefined immutable names are\n"
	print "\talso excluded.\n\n"

	print "\tThe saved file is a normal text file that can be later read by\n"
	print "\thoc on any platform.\n\n"

	print "\t[NB: A temporary implementation restriction also excludes\n"
	print "\tuser-defined immutable names, and all functions and\n"
	print "\tprocedures.]\n\n"
}

proc help_scalb() \
{
	print "\tscalb(x,y) returns x * 2^(int(y)).\n\n"
}

proc help_second() \
{
	print "\tsecond() returns the CPU time in job seconds since some fixed\n"
	print "\ttime in the past.  Take the difference of two bracketing calls\n"
	print "\tto get the elapsed CPU time for a block of code.  For example,\n\n"

	print "\t\tPREC = 3\n"
	print "\t\tx = 1\n"
	print "\t\tt = second()\n"
	print "\t\tfor (k = 1; k < 1000000; ++k) x *= 1\n"
	print "\t\tsecond() - t\n"
	print "\t\t4.73\n\n"
}

proc help_setrand() \
{
	print "\tsetrand(x), where x should be a large integer, sets the seed of\n"
	print "\tthe pseudo-random number generator to x, and returns the old\n"
	print "\tseed.\n\n"

	print "\tAs a special case, when x is zero, x is ignored, and a new seed\n"
	print "\tis constructed from a random number multiplied by either the\n"
	print "\tcalendar time (if available), or the process number (if\n"
	print "\tavailable), or the next pseudo-random number.\n\n"

	print "\tIf setrand(x) is never called, then rand(), randint(), and\n"
	print "\trandl(x) will each return the same sequence of pseudo-random\n"
	print "\tnumbers: see help_rand(), help_randint(), and help_randl().\n\n"

	print "\tThe pseudo-random generator algorithm is platform-independent,\n"
	print "\tallowing reproduction of the same number sequence on any\n"
	print "\tcomputer architecture.\n\n"
}

proc help_significand() \
{
	print "\tsignificand(x) returns the significand of x, s, such that\n"
	print "\tx = s * 2^n, with |s| in [1...2), and n an integer.\n\n"

	print "\tSee help_exponent() for how to extract the exponent, n.\n\n"
}

proc help_sin() \
{
	print "\tsin(x) returns the sin of x (x in radians).\n"
	print "\tExpect severe accuracy loss for large |x|.\n\n"
}

proc help_sind() \
{
	print "\tsind(x) returns the sin of x (x in degrees).\n"
	print "\tExpect severe accuracy loss for large |x|.\n\n"
}

proc help_sinh() \
{
	print "\tsinh(x) returns the hyperbolic sin of x.\n\n"
}

proc help_minsubnormal() \
{
	print "\tminsubnormal() returns the minimum positive subnormal number.\n"
	print "\tIf subnormals are not supported, then it returns the minimum\n"
	print "\tnormal number instead.\n\n"
}

proc help_printenv() \
{
	print "\tprintenv(prefix) prints the names and values of all environment\n"
	print "\tvariables whose names match that prefix.  Use printenv(\"\")\n"
	print "\tto match all names.\n\n"
}

proc help_putenv() \
{
	print "\tputenv(envvar,newval) replaces the current string value of the\n"
	print "\tenvironment variable envvar with newval, and returns its old\n"
	print "\tvalue.\n\n"

	print "\tThis affects subsequent calls to getenv(), but does NOT affect\n"
	print "\tthe environment of the parent process.\n\n"

	print "\tYou can use this function to set locale environment variables\n"
	print "\tthat control the output of dates and times, in order to get\n"
	print "\tinternationalized output from strftime().\n\n"
}

proc help_sqrt() \
{
	print "\tsqrt(x) returns the square root of x.\n"
	print "\tx must be in [-0...Infinity].\n\n"

	print "\tSpecial case:\n"
	print "\t\tsqrt(-0) -> -0\n\n"
}

proc help_strftime() \
{
	print "\tstrftime(format,time) converts a numeric time measured in\n"
	print "\tseconds since the epoch (usually obtained from systime()) to a\n"
	print "\tformatted string determined by one or more of these format\n"
	print "\titems:\n\n"

	print "\t\t%A\tthe locale's full weekday name.\n\n"

	print "\t\t%a\tthe locale's abbreviated weekday name.\n\n"

	print "\t\t%B\tthe locale's full month name.\n\n"

	print "\t\t%b\tthe locale's abbreviated month name.\n\n"

	print "\t\t%c\tthe locale's appropriate date and time\n"
	print "\t\t\trepresentation.\n\n"

	print "\t\t%d\tthe day of the month as a decimal number\n"
	print "\t\t\t(01--31).\n\n"

	print "\t\t%H\tthe hour (24-hour clock) as a decimal number\n"
	print "\t\t\t(00--23).\n\n"

	print "\t\t%I\tthe hour (12-hour clock) as a decimal number\n"
	print "\t\t\t(01--12).\n\n"

	print "\t\t%j\tthe day of the year as a decimal number\n"
	print "\t\t\t(001--366).\n\n"

	print "\t\t%M\tthe minute as a decimal number (00--59).\n\n"

	print "\t\t%m\tthe month as a decimal number (01--12).\n\n"

	print "\t\t%p\tthe locale's equivalent of either ``AM'' or\n"
	print "\t\t\t``PM''.\n\n"

	print "\t\t%S\tthe second as a decimal number (00--60).\n\n"

	print "\t\t%U\tthe week number of the year (Sunday as the\n"
	print "\t\t\tfirst day of the week) as a decimal number\n"
	print "\t\t\t(00--53).\n\n"

	print "\t\t%W\tthe week number of the year (Monday as the\n"
	print "\t\t\tfirst day of the week) as a decimal number\n"
	print "\t\t\t(00--53).\n\n"

	print "\t\t%w\tthe weekday (Sunday as the first day of the\n"
	print "\t\t\tweek) as a decimal number (0--6).\n\n"

	print "\t\t%X\tthe locale's appropriate time representation.\n\n"

	print "\t\t%x\tthe locale's appropriate date representation.\n\n"

	print "\t\t%Y\tthe year with century as a decimal number.\n\n"

	print "\t\t%y\tthe year without century as a decimal number\n"
	print "\t\t\t(00--99).\n\n"

	print "\t\t%Z\tthe time zone name.\n\n"

	print "\t\t%%\t`%'.\n\n"
}

proc help_substr() \
{
	print "\tsubstr(s,start,len) returns a substring of string s beginning\n"
	print "\tat character start (counting from 1), of length at most len.\n"
	print "\tIf start is outside the string, it is moved to the nearest\n"
	print "\tendpoint, WITHOUT adjusting len.  Fewer than len characters\n"
	print "\twill be returned if the substring extends outside the original\n"
	print "\tstring.\n\n"
}

proc help_systime() \
{
	print "\tsystime() returns the calendar time in seconds since the epoch.\n"
	print "\tOn UNIX systems, the epoch starts on January 1, 1970 00:00:00\n"
	print "\tUTC.  Other operating systems make different choices.  It can be\n"
	print "\tconverted to a formatted time string with strftime().\n\n"
}

proc help_tan() \
{
	print "\ttan(x) returns the tangent of x (x in radians).\n"
	print "\tExpect severe accuracy loss for large |x|.\n\n"
}

proc help_tand() \
{
	print "\ttand(x) returns the tangent of x (x in degrees).\n"
	print "\tExpect severe accuracy loss for large |x|.\n\n"
}

proc help_tanh() \
{
	print "\ttanh(x) returns the hyperbolic tangent of x.\n\n"
}

proc help_tolower() \
{
	print "\ttolower(s) returns a copy of string s with uppercase letters\n"
	print "\tconverted to lowercase, and all other characters unchanged.\n\n"

	print "\tWhich characters are considered uppercase depends on the locale.\n"
	print "\tOn UNIX, this is determined by the LC_CTYPE environment\n"
	print "\tvariable.\n\n"
}

proc help_toupper() \
{
	print "\ttoupper(s) returns a copy of string s with lowercase letters\n"
	print "\tconverted to uppercase, and all other characters unchanged.\n\n"

	print "\tWhich characters are considered lowercase depends on the locale.\n"
	print "\tOn UNIX, this is determined by the LC_CTYPE environment\n"
	print "\tvariable.\n\n"
}

proc help_trunc() \
{
	print "\ttrunc(x) returns the integer part of x, with the fractional part\n"
	print "\tdiscarded.\n\n"
}

proc help_who() \
{
	print "\twho(prefix) prints all symbols whose initial characters match\n"
	print "\tthe prefix string, grouped by category.  To print all symbols,\n"
	print "\tuse an empty prefix: who(\"\").\n\n"
}

proc help_Y0() \
{
	print "\tY0(x) returns the Bessel function of the second kind of order 0\n"
	print "\tof x, for x >= 0.  This function is also called Weber's\n"
	print "\tfunction.\n\n"
}

proc help_Y1() \
{
	print "\tY1(x) returns the Bessel function of the second kind of order 1\n"
	print "\tof x, for x >= 0.  This function is also called Weber's\n"
	print "\tfunction.\n\n"
}

proc help_Yn() \
{
	print "\tYn(n,x) returns the Bessel function of the second kind of\n"
	print "\tintegral order n of x, for x >= 0.  This function is also called\n"
	print "\tWeber's function.\n\n"
}

### Help for statements

proc help_assignment() \
{
	print "\tAssignment statement: assign an expression to a variable,\n"
	print "\toverwriting any previous value.\n\n"

	print "\tSyntax:\n"
	print "\t\tvariable = expression\n"
	print "\t\tvariable := expression\n\n"

	print "\tExamples:\n"
	print "\t\tx = 2.71828\n"
	print "\t\ty = E\n"
	print "\t\tz = log2(x - y)\n"
	print "\t\tPi := 3.141592653589793238462643383279502884197\n\n"

	print "\tThe := form defines an immutable named constant: such a name\n"
	print "\tcannot be assigned to again in the same job.\n\n"
}

proc help_arithmetic() \
{
	print "\tAll hoc expressions are evaluated in double-precision\n"
	print "\tarithmetic.\n\n"

	print "\tOn most modern systems, this is 64-bit IEEE 754 arithmetic,\n"
	print "\twith 53 bits for the significand (almost 16 decimal figures),\n"
	print "\t11 bits for the exponent (giving a decimal range of about\n"
	print "\t2.23e-308 ... 1.80e+308), and 1 bit for the sign.\n\n"

	print "\tWhen subnormal (formerly, denormalized) numbers are supported,\n"
	print "\tthe range is extended down to about 4.94e-324, with decreasing\n"
	print "\tprecision.\n\n"

	print "\tOn IEEE 754 systems, Not-a-Number (NaN) and Infinity are also\n"
	print "\tavailable (type help_NaN() and help_Infinity() for details).\n\n"

	print "\tOn some IEEE 754 systems, subnormal numbers are also supported\n"
	print "\t(type help_subnormal() for details).\n\n"
}

proc help_expression() \
{
	help_arithmetic()
	print "\tThe expression grammar is:\n\n"

	print "\t\texpr:\t\tnumber\n"
	print "\t\t\t\t|\tvariable\n"
	print "\t\t\t\t|\t( expr )\n"
	print "\t\t\t\t|\texpr binary-operator expr\n"
	print "\t\t\t\t|\tunary-operator expr\n"
	print "\t\t\t\t|\tfunction ( arguments )\n\n"

	print "\tType help_operators() for help on operators\n\n"

	print "\tSome common older floating-point architectures include:\n\n"

	print "\t* Compaq/DEC VAX (64-bit arithmetic, 1-bit sign, with two\n"
	print "\t  formats: D-floating (8-bit exponent, 56-bit significand, 1\n"
	print "\t  hidden bit), and G-floating (11-bit exponent, 53-bit\n"
	print "\t  significand, 1 hidden bit)).\n\n"

	print "\t* Cray (64-bit arithmetic, 1-bit sign, 15-bit exponent, 48-bit\n"
	print "\t  significand, no hidden bit).\n\n"

	print "\t* IBM S/390 (64-bit arithmetic, 1-bit sign, 7-bit exponent,\n"
	print "\t  56-bit significand with wobbling precision from base-16\n"
	print "\t  (hexadecimal) normalization, no hidden bit).  [In 1999, IBM\n"
	print "\t  introduced the G5 processors in the S/390 product line,\n"
	print "\t  adding full support for IEEE 754 arithmetic as well.]\n\n"
}

proc help_for() \
{
	print "\tFor-loop statement: iterate with a loop variable while a\n"
	print "\tcondition is true:\n\n"

	print "\tSyntax:\n"
	print "\t\tfor (assignment; conditional-expr; step-expr) statement\n\n"

	print "\tThe initial assignment is done once.  The conditional-expr\n"
	print "\texpression is tested for nonzero (true) before entering the\n"
	print "\tloop.  The step-expr expression is executed at the end of the\n"
	print "\tloop body, before starting the next iteration.\n\n"

	print "\tExample:\n"
	print "\t\tfor (k = 0; k < 5; ++k) print k, \"\\n\"\n\n"
}

proc help_func() \
{
	print "\tFunction statement: define a value-returning function:\n\n"

	print "\tSyntax:\n"
	print "\t\tfunc name () statement\n"
	print "\t\tfunc name () { statements }\n\n"

	print "\tArguments are not explicitly named in the parameter list, but\n"
	print "\tappear in the body as $1, $2, ..., according to their position\n"
	print "\tin the function call arguments. A return statement MUST\n"
	print "\tterminate execution of the function body.\n\n"

	print "\tArguments with string values must be named with two dollar\n"
	print "\tsigns: $$1 instead of $1.\n\n"

	print "\tFunctions may be recursive, but the recursion depth is limited\n"
	print "\tto about a thousand.  The real limit is set not by hoc itself,\n"
	print "\tbut rather by the host operating system's process stacksize\n"
	print "\tlimit.  On UNIX-like systems, you can use the limit(1) or\n"
	print "\tulimit(1) commands to adjust the stacksize limit.\n\n"

	print "\tBuilt-in functions may NOT be redefined.  User-defined ones may.\n\n"

	print "\tExample:\n\n"

	print "\t\tfunc max() \\\n"
	print "\t\t{\n"
	print "\t\t\tif (isnan($1)) \\\n"
	print "\t\t\t\treturn ($1)\n"
	print "\t\t\tif (isnan($2)) \\\n"
	print "\t\t\t\treturn ($2)\n"
	print "\t\t\tif ($1 > $2) \\\n"
	print "\t\t\t\treturn ($1) \\\n"
	print "\t\t\telse \\\n"
	print "\t\t\t\treturn ($2)\n"
	print "\t\t}\n\n"

	print "\tThis example shows the care that must usually be taken to deal\n"
	print "\twith IEEE 754 special values.  The if-else statement available\n"
	print "\tin most programming languages has only two outcomes, but in\n"
	print "\tIEEE 754 arithmetic, there is a third possibility: unordered.\n"
	print "\tThe code must therefore first handle that by the isnan()\n"
	print "\ttests.\n\n"
}

proc help_if() \
{
	print "\tif statement: conditional statement.\n\n"

	print "\tSyntax:\n"
	print "\t\tif (expression) statement [else statement]\n"
	print "\t\tif (expression) { statements } [else { statements }]\n\n"

	print "\tExample:\n"
	print "\t\tif (r < 3.14159) print \"smaller than PI\\n\" \\\n"
	print "\t\telse print \"ERROR!\\n\"\n"
	print "\t\tif (E < PI) print \"E is smaller than PI\\n\"\n\n"
}

proc help_help() \
{
	__internal_help_hrule()
	print "\tHelp is available via these functions:\n\n"

	print "\t\thelp(), help_CATALAN(), help_DEG(), help_E(),\n"
	print "\t\thelp_GAMMA(), help_INF(), help_Infinity(), help_J0(),\n"
	print "\t\thelp_J1(), help_Jn(), help_NAN(), help_PHI(), help_PI(),\n"
	print "\t\thelp_PREC(), help_Y0(), help_Y1(), help_Yn(), help__(),\n"
	print "\t\thelp___BANNER__(), help___DATE__(), help___FILE__(),\n"
	print "\t\thelp___IEEE_754__(), help___LINE__(),\n"
	print "\t\thelp___PACKAGE_BUGREPORT__(), help___PACKAGE_DATE__(),\n"
	print "\t\thelp___PACKAGE_NAME__(), help___PACKAGE_STRING__(),\n"
	print "\t\thelp___PACKAGE_VERSION__(), help___PROMPT__(),\n"
	print "\t\thelp___TIME__(), help___VERBOSE__(). help_abort(),\n"
	print "\t\thelp_abs(), help_acos(), help_acosh(), help_all(),\n"
	print "\t\thelp_arithmetic(), help_asin(), help_asinh(),\n"
	print "\t\thelp_assignment(), help_atan(), help_atanh(),\n"
	print "\t\thelp_cbrt(), help_ceil(), help_comments(),\n"
	print "\t\thelp_constants(), help_copysign(), help_cos(),\n"
	print "\t\thelp_cosd(), help_cosh(), help_erf(), help_erfc(),\n"
	print "\t\thelp_errbits(), help_eval(), help_exp(), help_expm1(),\n"
	print "\t\thelp_exponent(), help_expression(), help_expressions(),\n"
	print "\t\thelp_factorial(), help_floor(), help_fmod(), help_for(),\n"
	print "\t\thelp_func(), help_functions(), help_gcd(),\n"
	print "\t\thelp_getenv(), help_help(), help_hypot(),\n"
	print "\t\thelp_ieee_754(), help_if(), help_ilogb(), help_index(),\n"
	print "\t\thelp_int(), help_isfinite(), help_isinf(), help_isnan(),\n"
	print "\t\thelp_isnormal(), help_isqnan(), help_issnan(),\n"
	print "\t\thelp_issubnormal(), help_lcm(), help_ldexp(),\n"
	print "\t\thelp_length(), help_lgamma(), help_ln(), help_load(),\n"
	print "\t\thelp_log(), help_log10(), help_log1p(), help_log2(),\n"
	print "\t\thelp_logb(), help_logfile(), help_logoff(),\n"
	print "\t\thelp_logon(), help_macheps(), help_max(),\n"
	print "\t\thelp_maxnormal(), help_min(), help_minnormal(),\n"
	print "\t\thelp_minsubnormal(), help_nearest(), help_nextafter(),\n"
	print "\t\thelp_nint(), help_now(), help_number(),\n"
	print "\t\thelp_number_syntax(), help_numbers(), help_operators(),\n"
	print "\t\thelp_print(), help_printenv(), help_printf(),\n"
	print "\t\thelp_println(), help_proc(), help_putenv(), help_rand(),\n"
	print "\t\thelp_randint(), help_randl(), help_read(),\n"
	print "\t\thelp_remainder(), help_rint(), help_rsqrt(),\n"
	print "\t\thelp_save(), help_scalb(), help_second(),\n"
	print "\t\thelp_setrand(), help_significand(), help_sin(),\n"
	print "\t\thelp_sind(), help_sinh(), help_sqrt(), help_statement(),\n"
	print "\t\thelp_statements(), help_strftime(), help_string(),\n"
	print "\t\thelp_string(), help_string_expressions(),\n"
	print "\t\thelp_string_functions(), help_string_syntax(),\n"
	print "\t\thelp_strings(), help_substr(), help_systime(),\n"
	print "\t\thelp_tan(), help_tand(), help_tanh(), help_time(),\n"
	print "\t\thelp_tolower(), help_toupper(), help_trunc(),\n"
	print "\t\thelp_variables(), help_while(), help_who()\n"
	__internal_help_hrule()
}

proc help_operators() \
{
	__internal_help_hrule()
	print "Help on operators:\n\n"

	print "\tThe operators are, in order of decreasing precedence:\n\n"

	print "\t^\t\t\texponentiation (Fortran **), right\n"
	print "\t\t\t\tassociative\n\n"

	print "\t++  --\t\t\tincrement, decrement (either prefix or\n"
	print "\t\t\t\tpostfix)\n\n"

	print "\t!  -\t\t\tunary logical and arithmetic negation\n\n"

	print "\t*  /\t\t\tmultiplication, division\n\n"

	print "\t+  -\t\t\taddition, subtraction\n\n"

	print "\t>  >=  <  <=  ==  !=\trelational operators: greater, greater\n"
	print "\t\t\t\tor equal, less, less or equal, equal,\n"
	print "\t\t\t\tnot equal\n\n"

	print "\t&&\t\t\tlogical AND (both operands always\n"
	print "\t\t\t\tevaluated)\n\n"

	print "\t||\t\t\tlogical OR (both operands always\n"
	print "\t\t\t\tevaluated)\n\n"

	print "\t=  :=\t\t\tassignment, permanent assignment (both\n"
	print "\t\t\t\tright associative)\n\n"
}

proc help_print() \
{
	print "\tprint statement: print one or more items to stdout\n\n"

	print "\tSyntax:\n"
	print "\t\tprint item[, item]*\n\n"

	print "\tItems are either strings, or numeric expressions. Newline (\\n)\n"
	print "\tmust be supplied where needed: it is never supplied by default.\n\n"

	print "\tExample:\n"
	print "\t\tprint \"Pi is approximately \", PI, \"\\n\"\n\n"
}

proc help_printf() \
{
	print "\tprintf statement: print one or more items to stdout under format\n"
	print "\tcontrol.\n\n"

	print "\tSyntax:\n\n"

	print "\t\tprintf \"format\", item[, item]*\n\n"

	print "\tItems are either strings, or numeric expressions. Newline (\\n)\n"
	print "\tmust be supplied where needed: it is never supplied by default.\n\n"

	print "\tExample:\n"
	print "\t\tprintf \"Pi is approximately %.4f\\n\", PI, \\\n"
	print "\t\t\t\" (to five figures)\\n\"\n\n"

	print "\tWARNING: printf is not yet fully implemented: it acts like print\n"
	print "\tfor now.\n\n"
}

proc help_println() \
{
	print "\tprintln statement: print one or more items to stdout, with\n"
	print "\tfollowing newline.\n\n"

	print "\tSyntax:\n"
	print "\t\tprintln item[, item]*\n\n"

	print "\tItems are either strings, or numeric expressions.\n\n"

	print "\tExample:\n"
	print "\t\tprintln \"Pi is approximately \", PI, \".\"\n\n"
}

proc help_proc() \
{
	print "\tProcedure statement: define a non-value-returning procedure.\n\n"

	print "\tSyntax:\n"
	print "\t\tproc name () statement\n"
	print "\t\tproc name () { statements }\n\n"

	print "\tArguments are not explicitly named in the parameter list, but\n"
	print "\tappear in the body as $1, $2, ..., according to their position\n"
	print "\tin the procedure call arguments.  A procedure does not return a\n"
	print "\tvalue.\n\n"

	print "\tArguments with string values must be named with two dollar\n"
	print "\tsigns: $$1 instead of $1.\n\n"

	print "\tFunctions may be recursive, but the recursion depth is limited\n"
	print "\tto about a thousand.  The real limit is set not by hoc itself,\n"
	print "\tbut rather by the host operating system's process stacksize\n"
	print "\tlimit.  On UNIX-like systems, you can use the limit(1) or\n"
	print "\tulimit(1) commands to adjust the stacksize limit.\n\n"

	print "\tExample:\n"
	print "\t\tproc sample () \\\n"
	print "\t\t{\n"
	print "\t\t\tprint \"Your sample message goes here\\n\"\n"
	print "\t\t}\n\n"
}

proc help_read() \
{
	print "\tread(x) attempts to read into the variable x a value from stdin.\n"
	print "\tThe value must be either a number, or a quoted string, or an\n"
	print "\texisting variable or named constant.\n\n"

	print "\tThe return value is 1 on success, or 0 on end-of-file; the\n"
	print "\tfunction aborts for any other error condition.\n\n"

	print "\tSyntax:\n"
	print "\t\tread (variable)\n\n"

	print "\tExample:\n"
	print "\t\tread (x)\n\n"
}

proc help_statement() \
{
	print "\tStatements are terminated by a newline or semicolon.\n"
	print "\tContinue long statements with backslash-newline.\n\n"

	print "\tWherever a statement can appear, a braced statement block can\n"
	print "\ttoo.\n\n"

	print "\t\tfor (assignment; conditional-expr; expr) statement\n\n"

	print "\t\tfunc name () statement\n"
	print "\t\tif (expression) then statement [ else statement ]\n"
	print "\t\tprint item [, item, [, item ...]]\n"
	print "\t\tprintf \"format\" [, item [, item, [, item ...]]]\n"
	print "\t\tproc name () statement\n"
	print "\t\tread (variable)\n"
	print "\t\twhile (expression) statement\n\n"

	print "\tType help_expression() for help on expressions.\n\n"
}

proc help_while() \
{
	print "\twhile loop: iterate while a condition is true:\n\n"

	print "\tSyntax:\n"
	print "\t\twhile (conditional-expression) statement\n\n"

	print "\tExample:\n"
	print "\t\twhile (read(x)) print x, x^2, x^3, \"\\n\"\n\n"
}

### Help on general topics

proc help_comments() \
{
	__internal_help_hrule()
	print "Help on comments:\n\n"

	print "\tComments start from # (sharp) and continue to end of line.\n"
	print "\tBlank lines are treated like empty comments.\n\n"
}

proc help_constants() \
{
	__internal_help_hrule()
	print "Help on constants:\n\n"

	help_CATALAN()
	help_DEG()
	help_E()
	help_GAMMA()
	help_Infinity()
	help_NaN()
	help_PHI()
	help_PI()
	help_PREC()
}

proc help_environment() \
{
	__internal_help_hrule()
	print "Help on environment:\n\n"

	help_getenv()
	help_printenv()
	help_putenv()
}

proc help_expressions() \
{
	__internal_help_hrule()
	print "Help on expressions:\n\n"

	help_expression()
}

proc help_functions_non_ieee_754() \
{
	__internal_help_hrule()
	print "Help on non-IEEE-754 functions:\n\n"

	help_abort()	# this is a proc, not a function
	help_abs()
	help_acos()
	help_acosh()
	help_asin()
	help_asinh()
	help_atan()
	help_atanh()
	help_cbrt()
	help_ceil()
	help_cos()
	help_cosd()
	help_cosh()
	help_erf()
	help_erfc()
	help_errbits()
	help_eval()
	help_exp()
	help_expm1()
	help_factorial()
	help_floor()
	help_gamma()
	help_gcd()
	help_hypot()
	help_int()
	help_J0()
	help_J1()
	help_Jn()
	help_lcm()
	help_lgamma()
	help_ln()
	help_load()
	help_log()
	help_log10()
	help_log1p()
	help_log2()
	help_logfile()
	help_logoff()
	help_logon()
	help_macheps()
	help_max()
	help_maxnormal()
	help_min()
	help_minnormal()
	help_nint()
	help_now()
	help_rand()
	help_randint()
	help_randl()
	help_remainder()
	help_rint()
	help_rsqrt()
	help_save()
	help_second()
	help_setrand()
	help_sin()
	help_sind()
	help_sinh()
	help_sqrt()
	help_strftime()
	help_systime()
	help_tan()
	help_tand()
	help_tanh()
	help_trunc()
	help_Y0()
	help_Y1()
	help_Yn()
}

proc help_functions_ieee_754() \
{
	__internal_help_hrule()
	print "Help on IEEE 754 functions:\n\n"

	help_copysign()
	help_exponent()
	help_fmod()
	help_ilogb()
	help_isfinite()
	help_isinf()
	help_isnan()
	help_isnormal()
	help_isqnan()
	help_issnan()
	help_issubnormal()
	help_ldexp()
	help_minsubnormal() # NB: help_maxnormal() and help_minnormal() are in help_functions_non_ieee_754()
	help_nearest()
	help_nextafter()
	help_scalb()
	help_significand()
}

proc help_functions() \
{
	help_functions_non_ieee_754()
	help_functions_ieee_754()
}

proc help_random() \
{
	__internal_help_hrule()
	print "Help on pseudo-random number:\n\n"

	help_rand()
	help_randint()
	help_randl()
	help_setrand()
}

proc help_subnormal() \
{
	print "\tThe IEEE 754 floating-point number format generally requires\n"
	print "\tthat numbers be normalized, that is, nonzero significands are\n"
	print "\trequired to start with a one bit.\n\n"

	print "\tWhen subnormal (formerly, denormalized) numbers are supported,\n"
	print "\tthis restriction is relaxed, and the numbers can become\n"
	print "\tsmaller than the smallest normal number by acquiring leading\n"
	print "\tzero bits, at the expense of precision loss.\n\n"

	print "\tIn IEEE 754 double-precision arithmetic, the smallest normal\n"
	print "\tnumber is 2^-1022 (approximately 2.23e-308), and subnormals\n"
	print "\tallow representation of numbers down to 2^-1074 (approximately\n"
	print "\t4.94e-324) before underflow to zero occurs.\n\n"

	print "\tSome computers do not support subnormal numbers: check whether\n"
	print "\tyours does by evaluating 2^-1023 in hoc.  This will be\n"
	print "\tapproximately 1.11e-308 if subnormals are supported, and 0 if\n"
	print "\tnot.\n\n"
}

proc help_ieee_754() \
{
	__internal_help_hrule()
	print "Help on IEEE 754 floating-point arithmetic:\n\n"

	help_Infinity()
	help_NaN()
	help_subnormal()
	help_functions_ieee_754()
}

proc help_number() \
{
	print "\tnumber(s) converts the string s to a number and returns it.\n\n"

	print "\ts should contain either a hexadecimal floating-point number, a\n"
	print "\thexadecimal integer, a decimal floating-point number, a decimal\n"
	print "\tinteger, or a representation of NaN or Infinity.\n\n"

	print "\tIf s contains a number followed by unrecognizable text, the\n"
	print "\tnumber is converted and returned, and the following text is\n"
	print "\tsilently ignored.  Otherwise, the return value is 0, and the\n"
	print "\ttext is silently ignored.  Thus, number(\"123abc\") returns 123,\n"
	print "\tand number(\"abc\") returns 0.\n\n"

	print "\tThis function is an inverse of hexfp(), hexint(), and string():\n\n"

	print "\t\tnumber(hexfp(x))  == x	[for all numeric x]\n"
	print "\t\tnumber(hexint(x)) == x	[for all numeric x]\n"
	print "\t\tnumber(string(x)) == x	[for all numeric x]\n\n"

	print "\tSee also help_hexint(), help_hexfp(), and help_string().\n\n"
}

proc help_number_syntax() \
{
	print "\tAll numbers in hoc are stored as double-precision floating-point\n"
	print "\tvalues.\n\n"

	print "\tOn systems with IEEE 754 arithmetic, such numbers are capable of\n"
	print "\trepresenting integers of up to 53 bits exactly, excluding the\n"
	print "\tsign bit.  This is an integer range of -(2^53) ...  2^53, or\n"
	print "\t-9,007,199,254,740,992 ...  9,007,199,254,740,992.\n\n"

	print "\tNumbers may be signed, and may optionally contain a decimal\n"
	print "\tpoint, and a power-of-ten exponent, which consists of the letter\n"
	print "\te (or E) followed by an optionally-signed integer.  No other\n"
	print "\texponent letters are recognized.\n\n"

	print "\tA hexadecimal floating-point number format, introduced in the\n"
	print "\tlatest ISO C Standard, ``ISO/IEC 9899:1999 (E) Programming\n"
	print "\tlanguages --- C'', usually known by its short name, C99, is also\n"
	print "\tsupported, and implemented by portable private code in hoc.\n"
	print "\tThis format consists of an optional sign, then 0x or 0X,\n"
	print "\tfollowed by one or more hexadecimal digits (0--9 A--F a--f)\n"
	print "\tcontaining at most one hexadecimal point, optionally followed by\n"
	print "\ta binary (power-of-two) exponent consisting of p or P followed\n"
	print "\tby an optionally-signed decimal integer.  Thus, -0x1.00000p8,\n"
	print "\t-0x100, -0x100000p-12, -0x10p+4, -0x1p+8, -0x1p00008, and -0x1p8\n"
	print "\tall represent the decimal number -256.\n\n"

	print "\tThe hexadecimal format, while awkward for humans, has the\n"
	print "\tadvantage of guaranteeing exact input/output conversions on all\n"
	print "\tplatforms, and hoc consequently uses this format in files\n"
	print "\tcreated by the save() command.\n\n"
}

proc help_numbers() \
{
	__internal_help_hrule()
	print "Help on numbers:\n\n"

	help_number()
	help_number_syntax()
	help_arithmetic()
}

proc help_statements() \
{
	__internal_help_hrule()
	print "Help on statements:\n\n"

	## preliminaries
	help_statement()

	### actual statements
	help_assignment()
	help_for()
	help_func()
	help_if()
	help_print()
	help_printf()
	help_println()
	help_proc()
	help_read()
	help_while()
}

proc help_string() \
{
	print "\tstring(x) returns a string containing the decimal representation\n"
	print "\tof x, either in integer form (if x is exactly representable that\n"
	print "\tway), or in floating-point form.\n\n"

	print "\tSee also help_hexfp(), help_hexint(), and help_number().\n\n"
}

proc help_string_syntax() \
{
	print "\tCharacter strings are delimited by quotation marks: \"...\".\n\n"

	print "\tWithin a string, characters occupy 8 bits, and all character\n"
	print "\tvalues from 1 to 255 are legal.  Value 0 (NUL) is reserved for a\n"
	print "\tstring terminator, as in the C and C++ programming languages.\n\n"

	print "\tNonprintable characters in strings may be represented as escape\n"
	print "\tsequences, as in Standard C and C++:\n\n"

	print "\t\t\\a\talert (bell)\n"
	print "\t\t\\b\tbackspace\n"
	print "\t\t\\f\tformfeed\n"
	print "\t\t\\n\tnewline (linefeed)\n"
	print "\t\t\\r\tcarriage return\n"
	print "\t\t\\t\thorizontal tab\n"
	print "\t\t\\v\tvertical tab\n"
	print "\t\t\\o\toctal character, value o (o = 0...7)\n"
	print "\t\t\\oo\toctal character, value oo\n"
	print "\t\t\\ooo\toctal character, value ooo\n"
	print "\t\t\\xhh...\thexadecimal char, value hh... (0...9 a...f\n"
	print "\t\tA...F)\n\n"

	print "\tNotice that octal character values use at most three octal\n"
	print "\tdigits, while hexadecimal values may use an unlimited number of\n"
	print "\thexadecimal digits.\n\n"

	print "\tOne convenient additional escape sequence is recognized:\n\n"

	print "\t\t\\E	escape (\\033)\n\n"

	print "\tOtherwise, a backslash removes any special interpretation of the\n"
	print "\tfollowing character, so to get a literal backslash, use two: \\\\.\n\n"

	print "\tStrings may normally not cross line breaks, unless they end with\n"
	print "\tbackslash-newline.\n\n"
}

proc help_string_expressions() \
{
	help_string_syntax()

	print "\tThe string expression grammar is:\n\n"

	print "\tstrexpr:\tstringconstant\n"
	print "\t\t|\tstringvariable\n"
	print "\t\t|\tstrexpr strexpr\n\n"

	print "\tThat is, string expressions are blank-separated lists of\n"
	print "\tconstants and variables with string values, as in Standard C and\n"
	print "\tC++.  The value of the expression is the concatenation of the\n"
	print "\tlist elements: \"abc\" \"def\" \"...\" \"xyz\" evaluates to\n"
	print "\t\"abcdef...xyz\".\n\n"

	print "\tA variable becomes a stringvariable simply by being assigned\n"
	print "\ta string expression.\n\n"
}

proc help_string_functions() \
{
	print "\tBuilt-in functions for string processing are:\n"
	print "\t\tgetenv(), index(), hexfp(), hexint(), length(),\n"
	print "\t\tnumber(), printenv(), putenv(), strftime(), string(),\n"
	print "\t\tsubstr(), tolower(), toupper()\n\n"
}

proc help_strings() \
{
	__internal_help_hrule()
	print "Help on strings:\n\n"

	help_string_expressions()
	help_string_functions()
}

proc help_time() \
{
	__internal_help_hrule()
	print "Help on time:\n\n"

	help_now()
	help_second()
	help_strftime()
	help_systime()
}

proc help_variables() \
{
	__internal_help_hrule()
	print "Help on variables:\n\n"

	print "\tVariables consist of an initial letter or underscore, followed\n"
	print "\tby zero or more letters, digits, or underscores.\n\n"

	print "\tLetter case is significant in variable names.\n\n"

	print "\tThe special variable _ holds the result of the last expression\n"
	print "\tevaluated.  It may not be assigned to.  Its result will change\n"
	print "\tat each subsequent expression.\n\n"

	print "\tIt is an unenforced hoc convention that constants are spelled in\n"
	print "\tUPPERCASE.\n\n"

	print "\tAll variables are scalars: there are no array variables in hoc.\n\n"

	print "\tAll variables, even those defined inside functions, are global.\n"
	print "\tPlease follow the convention that variables that begin with two\n"
	print "\tleading underscores are for implementation use inside library\n"
	print "\tfunctions.\n\n"
}

proc help_all() \
{
	help_comments()
	help_numbers()
	help_strings()
	help_constants()
	help_variables()
	help_expressions()
	help_functions_non_ieee_754()
	help_functions_ieee_754()
	help_operators()
	help_statements()
	help_time()
	__internal_help_hrule()
}
