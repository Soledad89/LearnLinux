head	1.25;
access;
symbols;
locks
	beebe:1.25; strict;
comment	@ * @;


1.25
date	2002.08.08.22.18.07;	author beebe;	state Exp;
branches;
next	1.24;

1.24
date	2002.08.08.01.23.56;	author beebe;	state Exp;
branches;
next	1.23;

1.23
date	2002.08.06.13.28.48;	author beebe;	state Exp;
branches;
next	1.22;

1.22
date	2002.08.01.16.35.06;	author beebe;	state Exp;
branches;
next	1.21;

1.21
date	2002.08.01.12.21.59;	author beebe;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.31.17.25.07;	author beebe;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.30.16.45.18;	author beebe;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.28.18.25.39;	author beebe;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.27.17.41.21;	author beebe;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.26.14.31.06;	author beebe;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.24.14.47.24;	author beebe;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.20.23.25.14;	author beebe;	state Exp;
branches;
next	1.13;

1.13
date	2002.06.22.23.09.03;	author beebe;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.15.22.41.00;	author beebe;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.19.00.59.42;	author beebe;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.18.21.45.49;	author beebe;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.27.18.12.53;	author beebe;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.16.18.47.48;	author beebe;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.11.02.20.13;	author beebe;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.05.14.41.11;	author beebe;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.04.17.44.36;	author beebe;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.01.14.53.29;	author beebe;	state Exp;
branches;
next	1.3;

1.3
date	2001.12.12.01.28.20;	author beebe;	state Exp;
branches;
next	1.2;

1.2
date	98.03.05.18.27.53;	author beebe;	state Exp;
branches;
next	1.1;

1.1
date	98.03.05.18.19.59;	author beebe;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Add grammar rule to allow functions to return strings.  Remove
no-longer-used nbuf in yygetid().
@
text
@%{
#include "hoc.h"

#define __my_yylex			/* for SGI yacc and C++ */

#if defined(YYDEBUG)
extern int yydebug;
#else
#define YYDEBUG 0	/* so this works with byacc, bison, and yacc */
#endif

/* We need larger internal yacc tables to get consistent results across
   platforms for test/long-operand.hoc */
#define YYMAXDEPTH	8000
#define YYSTACKSIZE	8000

#if defined(HAVE_CTYPE_H)
#include <ctype.h>
#endif

#if defined(HAVE_ERRNO_H)
#include <errno.h>
#endif

#if defined(HAVE_LOCALE_H)
#include <locale.h>
#endif

#if defined(HAVE_SETJMP_H)
#include <setjmp.h>
#endif

#if defined(HAVE_SIGNAL_H)
#include <signal.h>
#endif

#if defined(__cplusplus) || defined(c_plusplus)
extern "C" int yylex ARGS((void));
extern "C" void fpecatch ARGS((int dummy));
extern "C" void intcatch ARGS((int dummy));
extern "C" void xcpucatch ARGS((int dummy));
#else
int yylex ARGS((void));
void fpecatch ARGS((int dummy));
void intcatch ARGS((int dummy));
void xcpucatch ARGS((int dummy));
#endif

#if defined(_AIX)
#undef YYCONST
#define YYCONST
EXTERN void yyerror ARGS((YYCONST char *)); /* otherwise used before prototyped on this system, sigh...*/
#endif

#if defined(HAVE_STDIO_H)
#include <stdio.h>
#endif

#if defined(HAVE_STDLIB_H)
#include <stdlib.h>
#endif

#if defined(HAVE_STRING_H)
#include <string.h>
#endif

#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif

#if !defined(R_OK)
#define R_OK 04
#endif

#if !defined(HOCRC)
#define HOCRC	".hocrc"
#endif

#if !defined(SYSHOCDIR)
#define SYSHOCDIR	"/usr/local/share/lib/hoc/hoc-" PACKAGE_VERSION "/"
#endif

#if !defined(SYSHOCHLPBASE)
#define SYSHOCHLPBASE	"help.hoc"
#endif

#if !defined(SYSHOCHLP)
#define SYSHOCHLP SYSHOCDIR "/" SYSHOCHLPBASE
#endif

#if !defined(SYSHOCRCBASE)
#define SYSHOCRCBASE	"hoc.rc"
#endif

#if !defined(SYSHOCRC)
#define SYSHOCRC SYSHOCDIR "/" SYSHOCRCBASE
#endif

#if !defined(SYSHOCXLTBASE)
#define SYSHOCXLTBASE	"translations.hoc"
#endif

#if !defined(SYSHOCXLT)
#define SYSHOCXLT SYSHOCDIR "/" SYSHOCXLTBASE
#endif

#if defined(DEBUG_CODE)
const char *code_argname;
int	debug_code = 0;			/* turn on manually in a debugger seesion */
#define code(c)		(code_argname = #c, (code)(c))
#endif

#define	code2(c1,c2)		code(c1); (void)code(c2)
#define	code3(c1,c2,c3)		code2(c1,c2); (void)code(c3)
#define	code4(c1,c2,c3,c4)	code3(c1,c2,c3); (void)code(c4)
#define CODE(c1)		(void)code(c1)
#define CODE2(c1,c2)		(void)code2(c1,c2)
#define CODE3(c1,c2,c3)		(void)code3(c1,c2,c3)
#define CODE4(c1,c2,c3,c4)	(void)code4(c1,c2,c3,c4)
#define QUOTATION_MARK	'"'

extern const char *	elementsep;	/* defined in io.c */

int			indef;			/* needed in code.c too */
int			inloop;			/* needed in code.c too */
const char *		syshocdir = SYSHOCDIR;

static int		this_c = '\n';		/* file global: used in warning(), yygetid(), yylex() */
static int		infile_count = 0;
static int		in_argnamelist = 0;
static int		in_global_stmt = 0;
static int		ndefns = 0;
static size_t		numargs = 0;
static size_t		maxargs = 0;
static size_t		numglobals = 0;
static size_t		maxglobals = 0;
static Symbol **	argnamelist = (Symbol**)NULL;
static Symbol **	globallist = (Symbol**)NULL;
static const char *	hocrc = HOCRC;
static const char *	syshochlp = SYSHOCHLP;
static const char *	syshochlpbase = SYSHOCHLPBASE;
static const char *	syshocrc = SYSHOCRC;
static const char *	syshocrcbase = SYSHOCRCBASE;
static const char *	syshocxlt = SYSHOCXLT;
static const char *	syshocxltbase = SYSHOCXLTBASE;
static const char *	this_procname;

extern FILE *		Fopen ARGS((const char *, const char *, const char **));
extern FILE *		Freopen ARGS((const char *, const char *, FILE*, const char **));

int			main ARGS((int, char *[]));
const char *		yygetstr ARGS((void));		/* used in code.c:varread() */
void			set_filename ARGS((const char *)); /* used in string.c:Load() */

static void		addarg ARGS((Symbol *));
static void		addglobal ARGS((Symbol *));
static void             author_and_die ARGS((void));
static int		backslash ARGS((int));
static void             bump_lineno ARGS((void));
static void             copyright_and_die ARGS((void));
static void             defnonly ARGS((const char *));
static void		do_define ARGS((const char *));
static void		do_one_init_file ARGS((const char *));
static void		do_undefine ARGS((const char *));
static void             do_init_files ARGS((void));
static void             do_post_args ARGS((int *, char *[]));
static void             do_pre_args ARGS((const int *, const char *[]));
static void		error ARGS((const char *, const char *));
static int              follow ARGS((int, int, int));
static void		free_argnamelist ARGS((void));
static void		free_globallist ARGS((void));
static const char *     get_locale_filename ARGS((const char *, const char *));
static const char *     get_locale_name ARGS((void));
static void             help_and_die ARGS((void));
static void             init_lineno ARGS((void));
static void		init_locale ARGS((void));
static void		init_readline ARGS((void));
static void             looponly ARGS((const char *));
static int		is_global ARGS((Symbol *));
static int		nth_arg ARGS((Symbol *));
static void		run ARGS((void));
static void             show ARGS((const char *[]));
static const char *	symtype ARGS((Symbol *));
static void             usage ARGS((void));
static void             usage_and_die ARGS((const char *));
static void             version_and_die ARGS((void));
static Symbol *		yygetlocal ARGS((const char *));

%}

%union {
	Symbol	*sym;	/* symbol table pointer */
	Inst	*inst;	/* machine instruction */
	long	narg;	/* number of arguments */
}

%token	<sym>	BLTIN0 BLTIN1 BLTIN1I BLTIN1S BLTIN2 BLTIN2S BREAK
%token	<sym>	CONTINUE ELSE FOR FUNC FUNCTION GLOBAL IF NUMBER PRINT
%token	<sym>	PRINTF PRINTLN PROC PROCEDURE READ RETURN SPRINTF
%token	<sym>	STRBLTIN0 STRBLTIN1 STRBLTIN1N STRBLTIN2 STRBLTIN2SN
%token	<sym>	STRBLTIN3SNN STRING STRVAR UNDEF VAR WHILE

%token	<narg>	ARG STRARG

%type	<inst>	anyexpr expr stmt asgn prlist prflist sprflist stmtlist
%type	<inst>	cond while for if begin end
%type	<inst>	strasgn strexpr string

%type	<sym>	keyword otherword procname

%type	<narg>	arglist

%right	'=' ADDEQ SUBEQ MULEQ DIVEQ MODEQ CONSTEQ

%left	OR
%left	AND
%left	GT GE LT LE EQ NE LTGT
%left	'+' '-'
%left	'*' '/' '%'
%left	UNARYMINUS UNARYPLUS NOT INC DEC

%right	TO_POWER
%%
list:	  /* nothing */
	| list eos
	| list defn eos
	| list asgn eos		{ CODE2(xpop, STOP); return 1; }
	| list strasgn eos	{ CODE2(xpop, STOP); return 1; }
	| list stmt eos		{ CODE(STOP); return 1; }
	| list expr eos		{ CODE2(printtop, STOP); return 1; }
	| list strexpr eos	{ CODE2(printtopstring, STOP); return 1; }
	| list error eos 	{ yyerrok; }
	;

eos:	  '\n'
	| ';'
	;

asgn:	  VAR '=' expr		{ CODE3(varpush,(Inst)$1,assign); $$=$3; }
	| VAR CONSTEQ expr	{ CODE3(varpush,(Inst)$1,const_assign); $$=$3; }
	| VAR ADDEQ expr	{ CODE3(varpush,(Inst)$1,addeq); $$=$3; }
	| VAR SUBEQ expr	{ CODE3(varpush,(Inst)$1,subeq); $$=$3; }
	| VAR MULEQ expr	{ CODE3(varpush,(Inst)$1,muleq); $$=$3; }
	| VAR DIVEQ expr	{ CODE3(varpush,(Inst)$1,diveq); $$=$3; }
	| VAR MODEQ expr	{ CODE3(varpush,(Inst)$1,modeq); $$=$3; }
	| STRVAR '=' expr	{ CODE3(varpush,(Inst)$1,assign); $$=$3; }
	| STRVAR CONSTEQ expr	{ CODE3(varpush,(Inst)$1,const_assign); $$=$3; }
	| STRVAR ADDEQ expr	{ CODE3(varpush,(Inst)$1,addeq); $$=$3; }
	| STRVAR SUBEQ expr	{ CODE3(varpush,(Inst)$1,subeq); $$=$3; }
	| STRVAR MULEQ expr	{ CODE3(varpush,(Inst)$1,muleq); $$=$3; }
	| STRVAR DIVEQ expr	{ CODE3(varpush,(Inst)$1,diveq); $$=$3; }
	| STRVAR MODEQ expr	{ CODE3(varpush,(Inst)$1,modeq); $$=$3; }
	| ARG '=' expr   	{ defnonly("$"); CODE2(argassign,(Inst)$1); $$=$3;}
	| ARG ADDEQ expr 	{ defnonly("$"); CODE2(argaddeq,(Inst)$1); $$=$3;}
	| ARG SUBEQ expr 	{ defnonly("$"); CODE2(argsubeq,(Inst)$1); $$=$3;}
	| ARG MULEQ expr 	{ defnonly("$"); CODE2(argmuleq,(Inst)$1); $$=$3;}
	| ARG DIVEQ expr 	{ defnonly("$"); CODE2(argdiveq,(Inst)$1); $$=$3;}
	| ARG MODEQ expr 	{ defnonly("$"); CODE2(argmodeq,(Inst)$1); $$=$3;}
	;

strasgn:  STRVAR '=' strexpr		{ CODE3(varpush,(Inst)$1,str_assign); $$=$3; }
	| STRVAR CONSTEQ strexpr	{ CODE3(varpush,(Inst)$1,const_str_assign); $$=$3; }
	| STRARG '=' strexpr	   	{ defnonly("$"); CODE2(argassign,(Inst)$1); $$=$3;}
	| ARG '=' strexpr	   	{ defnonly("$"); CODE2(argassign,(Inst)$1); $$=$3;}
	| VAR '=' strexpr		{ CODE3(varpush,(Inst)$1,str_assign); $$=$3; }
	| VAR CONSTEQ strexpr		{ CODE3(varpush,(Inst)$1,const_str_assign); $$=$3; }
	;

stmt:	  expr				{ CODE(xpop); }
	| strexpr			{ CODE(xpop); }
	| BREAK				{ looponly("break"); $$ = code(breakstmt); }
	| CONTINUE			{ looponly("continue"); $$ = code(continuestmt); }
	| RETURN			{ defnonly("return"); $$ = code(procret); }
	| RETURN expr			{ defnonly("return"); $$=$2; CODE(funcret); }
	| RETURN strexpr		{ defnonly("return"); $$=$2; CODE(funcret); }
	| PROCEDURE begin '(' arglist ')'	{ $$ = $2; CODE3(call, (Inst)$1, (Inst)$4); }
	| PRINT prlist			{ $$ = $2; }
	| PRINTF prflist		{ $$ = $2; }
	| PRINTLN prlist		{ $$ = $2; CODE(prnl); }
	| GLOBAL			{ in_global_stmt = 1; }
		globalnames		{ in_global_stmt = 0; }
	| while '(' cond ')' { inloop++; } stmt { inloop--; } end {
		($1)[1] = (Inst)$6;	/* body of loop */
		($1)[2] = (Inst)$8; }	/* end, if cond fails */
	| for '(' cond ';' cond ';' cond ')' { inloop++; } stmt { inloop--; } end {
		($1)[1] = (Inst)$5;	/* condition */
		($1)[2] = (Inst)$7;	/* post loop */
		($1)[3] = (Inst)$10;	/* body of loop */
		($1)[4] = (Inst)$12; }	/* end, if cond fails */
	| if '(' cond ')' stmt end {	/* else-less if */
		($1)[1] = (Inst)$5;	/* thenpart */
		($1)[3] = (Inst)$6; }	/* end, if cond fails */
	| if '(' cond ')' stmt end ELSE stmt end {	/* if with else */
		($1)[1] = (Inst)$5;	/* thenpart */
		($1)[2] = (Inst)$8;	/* elsepart */
		($1)[3] = (Inst)$9; }	/* end, if cond fails */
	| '{' stmtlist '}'		{ $$ = $2; }
	;
cond:	   expr 			{ CODE(STOP); }
	;
while:	  WHILE				{ $$ = code3(whilecode,STOP,STOP); }
	;
for:	  FOR				{ $$ = code(forcode); CODE4(STOP,STOP,STOP,STOP); }
	;
if:	  IF				{ $$ = code(ifcode); CODE3(STOP,STOP,STOP); }
	;
begin:	  /* nothing */			{ $$ = progp; }
	;
end:	  /* nothing */			{ CODE(STOP); $$ = progp; }
	;

/* This list of hoc language keywords must be kept synchronized with
the keywords[] table in init.c! */
keyword:  PROC
	| FUNC
	| RETURN
	| IF
	| ELSE
	| WHILE
	| FOR
	| PRINT
	| READ
	| BREAK
	| CONTINUE
	| PRINTF
	| PRINTLN
	| SPRINTF
	;

otherword: BLTIN0
	| BLTIN1
	| BLTIN1I
	| BLTIN1S
	| BLTIN2
	| BLTIN2S
	| FUNCTION
	| PROCEDURE
	| STRBLTIN0
	| STRBLTIN1
	| STRBLTIN1N
	| STRBLTIN2
	| STRBLTIN2SN
	| STRBLTIN3SNN
	| STRVAR
	| UNDEF
	| VAR
	;

stmtlist: /* nothing */				{ $$ = progp; }
	| stmtlist eos
	| stmtlist stmt
	;

anyexpr:	expr
	| strexpr
	;

string:   STRING				{ $$ = code2(const_str_push, (Inst)$1); }
	| STRVAR				{ $$ = code3(varpush, (Inst)$1, streval); }
	| STRARG				{ defnonly("$$"); $$ = code2(strarg, (Inst)$1); }
	| strasgn
	| '(' strexpr ')'			{ $$ = $2; }
	| READ '(' STRVAR ')'			{ $$ = code2(varread, (Inst)$3); }
	| STRBLTIN0 '(' ')'			{ $$ = code2(strbltin0, (Inst)$1->u.sptr0); }
	| STRBLTIN1 '(' anyexpr ')'		{ $$ = $3; CODE2(strbltin1, (Inst)$1->u.sptr1); }
	| STRBLTIN1N '(' anyexpr ')'		{ $$ = $3; CODE2(strbltin1n, (Inst)$1->u.sptr1n); }
	| STRBLTIN2 '(' anyexpr ',' anyexpr ')'	{ $$ = $3; CODE2(strbltin2, (Inst)$1->u.sptr2); }
	| STRBLTIN2SN '(' anyexpr ',' anyexpr ')' { $$ = $3; CODE2(strbltin2sn, (Inst)$1->u.sptr2sn); }
	| STRBLTIN3SNN '(' anyexpr ',' anyexpr ',' anyexpr ')' { $$ = $3; CODE2(strbltin3snn, (Inst)$1->u.sptr3snn); }
	;

strexpr:  string
	| expr NUMBER				{ CODE3(constpush, (Inst)$2, str_concat); }
	| expr VAR				{ CODE3(constpush, (Inst)$2, str_concat); }
	| expr ARG				{ CODE3(arg, (Inst)$2, str_concat); }
	| expr string				{ CODE(str_concat); }
	| strexpr NUMBER			{ CODE3(constpush, (Inst)$2, str_concat); }
	| strexpr VAR				{ CODE3(constpush, (Inst)$2, str_concat); }
	| strexpr ARG				{ CODE3(arg, (Inst)$2, str_concat); }
	| strexpr string			{ CODE(str_concat); }
	| SPRINTF sprflist			{ $$ = $2; }
	;

expr:	  NUMBER				{ $$ = code2(constpush, (Inst)$1); }
	| VAR					{ $$ = code3(varpush, (Inst)$1, eval); }
	| ARG					{ defnonly("$"); $$ = code2(arg, (Inst)$1); }
	| asgn
	| FUNCTION begin '(' arglist ')'	{ $$ = $2; CODE3(call,(Inst)$1,(Inst)$4); }
	| READ '(' VAR ')'			{ $$ = code2(varread, (Inst)$3); }
	| BLTIN0 '(' ')'              		{ $$ = code2(bltin0, (Inst)$1->u.ptr0); }
	| BLTIN1 '(' anyexpr ')'         	{ $$ = $3; CODE2(bltin1, (Inst)$1->u.ptr1); }
	| BLTIN1I '(' keyword ')'		{ $$ = code3(bltin1i, (Inst)$1->u.ptr1i, (Inst)$3); }
	| BLTIN1I '(' otherword ')'		{ $$ = code3(bltin1i, (Inst)$1->u.ptr1i, (Inst)$3); }
	| BLTIN1S '(' anyexpr ')'         	{ $$ = $3; CODE2(bltin1s, (Inst)$1->u.ptr1s); }
	| BLTIN2 '(' anyexpr ',' anyexpr ')'	{ $$ = $3; CODE2(bltin2, (Inst)$1->u.ptr2); }
	| BLTIN2S '(' anyexpr ',' anyexpr ')'	{ $$ = $3; CODE2(bltin2s, (Inst)$1->u.ptr2s); }
	| '(' expr ')'				{ $$ = $2; }
	| expr '+' expr				{ CODE(add); }
	| expr '-' expr				{ CODE(sub); }
	| expr '*' expr				{ CODE(mul); }
	| expr '/' expr				{ CODE(divop); }	/* ansi has a div fcn! */
	| expr '%' expr				{ CODE(mod); }
	| expr TO_POWER expr			{ CODE(power); }
	| '-' expr   %prec UNARYMINUS  		{ $$=$2; CODE(negate); }
	| '+' expr   %prec UNARYMINUS  		{ $$=$2; CODE(noop); }
	| expr GT expr				{ CODE(gt); }
	| expr GE expr				{ CODE(ge); }
	| expr LT expr				{ CODE(lt); }
	| expr LTGT expr			{ CODE(ltgt); }
	| expr LE expr				{ CODE(le); }
	| expr EQ expr				{ CODE(eq); }
	| expr NE expr				{ CODE(ne); }
	| expr AND expr				{ CODE(And); }
	| expr OR expr				{ CODE(Or); }
	| NOT expr				{ $$ = $2; CODE(Not); }
	| INC VAR				{ $$ = code2(preinc,(Inst)$2); }
	| DEC VAR				{ $$ = code2(predec,(Inst)$2); }
	| VAR INC				{ $$ = code2(postinc,(Inst)$1); }
	| VAR DEC				{ $$ = code2(postdec,(Inst)$1); }
	| string GT string			{ CODE(str_gt); }
	| string GE string			{ CODE(str_ge); }
	| string LT string			{ CODE(str_lt); }
	| string LE string			{ CODE(str_le); }
	| string EQ string			{ CODE(str_eq); }
	| string NE string			{ CODE(str_ne); }
	;

arglist:  /* nothing */ 			{ $$ = 0; }
	| expr					{ $$ = 1; }
	| strexpr				{ $$ = 1; }
	| arglist ',' expr			{ $$ = $1 + 1; }
	| arglist ',' strexpr			{ $$ = $1 + 1; }
	;

prlist:	  expr					{ CODE(prexpr); }
	| strexpr				{ CODE(prstr); }
	| prlist ',' expr			{ CODE2(prsep,prexpr); }
	| prlist ',' strexpr			{ CODE2(prsep,prstr); }
	;

prflist: strexpr				{ CODE(prfmt); }
	| prflist ',' expr			{ CODE(prexpr); }
	| prflist ',' strexpr			{ CODE(prstr); }
	;

sprflist: strexpr				{ CODE(sprfmt); }
	| sprflist ',' expr			{ CODE2(sprexpr,sprjoin); }
	| sprflist ',' strexpr			{ CODE2(sprstr,sprjoin); }
	;

defn:	  FUNC procname				{ $2->type = FUNCTION; indef = 1; }
	    beginargs '(' argnames ')' endargs
	    stmt				{ CODE(procret); define($2); }
	    enddefn
	| PROC procname				{ $2->type = PROCEDURE; indef = 1; }
	    beginargs '(' argnames ')' endargs
	    stmt				{ CODE(procret); define($2); }
	    enddefn
	;

procname: VAR
	| FUNCTION
	| PROCEDURE
	;

beginargs: /* nothing */			{
							this_procname = yylval.sym->name;
							free_argnamelist();
							free_globallist();
							ndefns++;
							in_argnamelist = 1;
						}

endargs: /* nothing */				{ in_argnamelist = 0; }

enddefn: /* nothing */				{ indef = 0; free_argnamelist(); free_globallist(); }

argnames:	/* nothing */
	| VAR					{ addarg($1); }
	| STRVAR				{ addarg($1); }
	| argnames ',' VAR			{ addarg($3); }
	| argnames ',' STRVAR			{ addarg($3); }
	;

globalnames:	/* nothing */
	| VAR					{ addglobal($1); }
	| STRVAR				{ addglobal($1); }
	| globalnames ',' VAR			{ addglobal($3); }
	| globalnames ',' STRVAR		{ addglobal($3); }
	;
%%
	/* end of grammar */

#ifndef YYCONST
#define YYCONST				/* symbol used by Sun Solaris yacc */
#endif

#if defined(__osf__)
EXTERN void yyerror ARGS((YYCONST char *));	/* keep C++ compilers happy */
#endif

#include "readline.h"

#undef getc
#define getc(fpin)			irl_getchar(fpin)
#undef ungetc
#define ungetc(c,fpin)			irl_unget_char(c)
#undef fscanf
#define fscanf(fpin,format,pdata)	irl_fscanf(fpin,format,pdata)

#define ARGMATCH(arg,option,minmatch) (strncmp(arg,option,MAX(strlen(arg),minmatch)) == 0)
#undef MAX				/* because some systems define this already */
#define MAX(a,b)	(((a) > (b)) ? (a) : (b))
#define OPTCHAR		'-'

extern FILE *fplog;

int cd_pwd_enabled = 1;	  		/* reset by --no-cd and --secure command-line options */
int file_trace_enabled = 1;		/* reset by --secure command-line option */
int load_enabled = 1;			/* reset by --no-load and --secure command-line options */
int logfile_enabled = 1;		/* reset by --no-logfile and --secure command-line options */
int save_enabled = 1;			/* reset by --no-save and --secure command-line options */
int use_readline = 1;			/* reset by --no-readline command-line option */
static int print_banner = 1;   		/* reset by --no-banner command-line option */
static int read_help_file = 1;		/* reset by --no-help-file command-line option */
static int read_site_file = 1;		/* reset by --no-site-file command-line option */
static int read_translation_file = 1;	/* reset by --no-translation-file command-line option */
static int read_user_file = 1;		/* reset by --no-user-file command-line option */
static int verbose_mode = 1;   		/* reset by --silent command-line option */

static jmp_buf		begin;
static int		gargc;
static char		**gargv;	/* global argument list */
static const char	*infile;	/* input file name */
static int		lineno = 1;
const char		*progname;

FILE			*fin;		/* input file pointer (also used in code.c and string.c) */

static void
addarg(Symbol *s)
{
	while (numargs >= maxargs)
		argnamelist = (Symbol**)egrow((void*)argnamelist, &maxargs, sizeof(argnamelist[0]));
	argnamelist[numargs++] = s;
}

static void
addglobal(Symbol *s)
{
	while (numglobals >= maxglobals)
		globallist = (Symbol**)egrow((void*)globallist, &maxglobals, sizeof(globallist[0]));
	globallist[numglobals++] = s;
}

static void
author_and_die(void)
{
	static const char *text[] =
	{
		PACKAGE_NAME, " was written by\n\n",

		"\tBrian W. Kernighan and Rob Pike\n\n",

		"and described in their book:\n\n",

		"\tThe UNIX Programming Environment\n",
		"\tPrentice-Hall\n",
		"\t1984\n",
		"\tpp. xii + 357\n",
		"\tISBN 0-13-937699-2 (hardcover), 0-13-937681-X (paperback)\n",
		"\tLCCN QA76.76.O63 K48 1984\n\n",

		"Extensions for IEEE 754 arithmetic, help, additional constants,\n",
		"statements, and functions, initialization files, internationalization,\n",
		"and GNU readline support were added by:\n\n",

		"\t", PACKAGE_BUGREPORT, "\n\n",

		"The extended hoc master Internet source distribution site is at:\n\n",

		"\tftp://ftp.math.utah.edu/pub/hoc\n",
		"\thttp://www.math.utah.edu/pub/hoc/\n\n",

		(const char *)NULL,
	};
	show(text);
	exit(EXIT_SUCCESS);
}

static int
backslash(int c)	/* get next char with \'s interpreted */
{
	static char transtab[] = "a\007b\bf\fn\nr\rt\tv\v"; /* K&R and Standard C escapes */

#define is_odigit(x) (isdigit(x) && (x != '8') && (x != '9'))

	if (c != '\\')
		return c;
	c = getc(fin);
	if (c == '\n')
		bump_lineno();
	if (islower(c) && (strchr(transtab, c) != (char *)NULL))
		return strchr(transtab, c)[1];
	else if (c == 'E')		/* \E -> ESCape */
	{
		/* NB: Standard C reserves uppercase escapes to
		   implementation-specific extensions */

		return ('\033');	/* ASCII ESCape */
	}
	else if (is_odigit(c))
	{		 /* \o, \oo, \ooo -> octal character number */
		int n;
		int value;

		n = 0;
		value = 0;
		while (is_odigit(c) && ((++n) <= 3))
		{
			value = 8*value + (c - (int)'0');
			c = getc(fin);
		}
		(void)ungetc(c,fin);
		return (value);
	}
	else if (c == (int)'x')
	{	/* \xhhhh... (any number of h's) -> hexadecimal character number */
		int value;

		value = 0;
		c = getc(fin);
		while (isxdigit(c))
		{
			if (isupper(c))
				c = tolower(c);
			if (((int)'a' <= c) && (c <= (int)'f'))
				value = 16*value + (c - (int)'a' + 10);
			else if (isdigit(c))
				value = 16*value + (c - (int)'0');
			c = getc(fin);
		}
		(void)ungetc(c,fin);
		return (value);
	}
	return c;

#undef is_odigit
}

static void
bump_lineno(void)
{
#if 0
	/* temporarily suppressed: see io.c:run3() header comments for why */

	static fp_t * pdlineno = (fp_t*)NULL;

	if (pdlineno == (fp_t*)NULL)
	{
		Symbol *s;

		s = lookup("__LINE__");
		if (s == (Symbol*)NULL)
			s = install_number("__LINE__", FP(0.0));
		make_immutable(s); /* to prevent user code assignments */
		pdlineno = &s->u.val;
	}
	lineno++;
	*pdlineno = (fp_t)lineno;	/* update __LINE__ value in symbol table */
#else
	/* We need this alternate version of line number incrementing to match code in io.c:run3() */
	Symbol *s;
	s = lookup("__LINE__");
	if (s == (Symbol*)NULL)
		s = install_number("__LINE__", FP(0.0));
	if (lineno == -1)		/* special case of new input file */
		s->u.val = (fp_t)lineno;
	s->u.val += FP(1.0);
	lineno = (int)(s->u.val);
#endif
}

static void
copyright_and_die(void)
{
	static const char *text[] =
	{
		"\n",
		"=================================================================\n",
		"Copyright (C) AT&T 1995\n",
		"All Rights Reserved\n\n",

		"Permission to use, copy, modify, and distribute this software and\n",
		"its documentation for any purpose and without fee is hereby\n",
		"granted, provided that the above copyright notice appear in all\n",
		"copies and that both that the copyright notice and this\n",
		"permission notice and warranty disclaimer appear in supporting\n",
		"documentation, and that the name of AT&T or any of its entities\n",
		"not be used in advertising or publicity pertaining to\n",
		"distribution of the software without specific, written prior\n",
		"permission.\n\n",

		"AT&T DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n",
		"INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.\n",
		"IN NO EVENT SHALL AT&T OR ANY OF ITS ENTITIES BE LIABLE FOR ANY\n",
		"SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n",
		"WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER\n",
		"IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,\n",
		"ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF\n",
		"THIS SOFTWARE.\n",
		"=================================================================\n\n",

		(const char *)NULL,
	};
	show(text);
	exit(EXIT_SUCCESS);
}

static void
defnonly(const char *s)	/* warn if illegal definition */
{
	if (!indef)
		execerror(s, "used outside definition");
}

static void
do_define(const char *s)
{	/* expect name (== name=1) or name=numericvalue or name=name or name="string" */
	/* (= may be replaced by := for permanent assignments) */
	char *equals;
	char *t;

	t = (char *)dupstr(s);
	equals = strchr(t,'=');
	if (equals == (char *)NULL)
	{
		if (is_immutable(t))
			error("illegal reassignment to immutable named constant", s);
		else
			(void)update_number(t,FP(1.0));	/* -Dname means -Dname=1 */
	}
	else					/* have -Dname=something or -Dname:=permanent-something */
	{
		char *value;
		int immutable;

		immutable = (equals[-1] == ':');

		if (immutable)
			equals[-1] = '\0';
		else
			equals[0] = '\0';

		if (is_immutable(t))
			error("illegal reassignment to immutable named constant", s);

		value = equals + 1;
		if (*value == QUOTATION_MARK) /* have name="value" */
		{
			char *q;

			value++;
			q = strchr(value, QUOTATION_MARK);
			if (q == (const char *)NULL)
				error("unclosed quotation mark in command-line option", s);
			else if (q[1] == '\0')
			{
				const char *v;

				*q = '\0';
				v = Expand(value);
				if (immutable)
					(void)update_const_string(t,v);
				else
					(void)update_string(t,v);
				efree((void *)v);
			}
			else
				error("unrecognized string in definition", s);
		}
		else if (IsIdStart(*value)) /* have name=name */
		{
			Symbol *sp;

			sp = lookup(value);
			if (sp == (Symbol*)NULL)
				error("unknown symbol in definition", s);
			else if (sp->type == VAR)
			{
				if (immutable)
					(void)update_const_number(t, sp->u.val);
				else
					(void)update_number(t, sp->u.val);
			}
			else if (sp->type == STRVAR)
			{
				if (immutable)
					(void)update_const_string(t, sp->u.str);
				else
					(void)update_string(t, sp->u.str);
			}
			else
				error("illegal symbol in definition", s);
		}
		else /* expect name=numeric-value */
		{
			char *endptr;
			fp_t d;

			d = strton(value, &endptr);
			if (*endptr == '\0')
			{
				if (immutable)
					(void)update_const_number(t, d);
				else
					(void)update_number(t, d);
			}
			else
				error("unrecognized number in definition", s);
		}
	}
	efree((void *)t);
}

static void
do_init_files(void)
{
	/* Process the optional startup files in documented
	   (in "man hoc") order of use:
		(1) system hoc.rc
		(2) locale hoc.rc
		(3) system help.hoc
		(4) locale help.hoc
		(5) system translations.hoc
		(6) locale translations.hoc
		(7) user .hocrc
	*/

	const char *p;

	if (read_site_file)
	{
		do_one_init_file(syshocrc);
		p = get_locale_filename(syshocdir, syshocrcbase);
		do_one_init_file(p);
		efree((void*)p);
	}

	if (read_help_file)
	{
		do_one_init_file(syshochlp);
		p = get_locale_filename(syshocdir, syshochlpbase);
		do_one_init_file(p);
		efree((void*)p);
	}

	if (read_translation_file)
	{
		do_one_init_file(syshocxlt);
		p = get_locale_filename(syshocdir, syshocxltbase);
		do_one_init_file(p);
		efree((void*)p);
	}

#if defined(HAVE_UNIX_HOME_DIRECTORY)
	if (read_user_file)
	{
		const char * userhocrc;
		const char * home;

		home = getenv("HOME");
		if (home == (const char *)NULL)
			return;
		userhocrc = concat3(home, "/", hocrc);
		do_one_init_file(userhocrc);
		efree((void *)userhocrc);
	}
#endif
}

static void
do_one_init_file(const char *filename)
{
	const char *new_filename;

	/* If filename is readable, attempt to open it and process it.  Otherwise,
	   return silently. */
	if ((filename != (const char *)NULL) && (access(filename, R_OK) == 0))
	{
		fin = Fopen(filename, "r", &new_filename);
		if (fin == (FILE*)NULL)
		{
			(void)fprintf(stderr,
				      msg_translate("%s: can't open %s\n"),
				      progname, filename);
			efree((void *)new_filename);
		}
		else
		{
			set_filename(new_filename);
			efree((void *)new_filename);
			run();
			(void)fclose(fin);
			fin = (FILE*)NULL;
		}
	}
}

static void
do_post_args(int *pargc, char * argv[])
{
	int k, m;
	char *p;

	/* Process command-line arguments after initialization files
	   have been read.  Any options that are recognized are
	   removed from argv[], and *pargc is reduced accordingly. */

	for (k = 1; k < *pargc; ++k)
	{
		p = argv[k];
		if (p[0] == OPTCHAR)
		{
			p++;
			if (p[0] == OPTCHAR)
				++p;	/* support GNU/POSIX style --option */

			if (STREQUAL(p,"")) /* ignore "-" option (meaning, stdin) */
			{
				if (p == (argv[k] + 2))
					p[-1] = '\0'; /* convert "--" to "-" */
				continue;
			}
			else if (*p == 'D')
				noop();	/* already handled in do_pre_args() */
			else if (*p == 'U')
				noop();	/* already handled in do_pre_args() */
			else if (ARGMATCH(p,"author",1))
				author_and_die();
			else if (ARGMATCH(p,"copyright",1))
				copyright_and_die();
			else if (ARGMATCH(p,"?",1))
				help_and_die();
			else if (ARGMATCH(p,"help",1))
				help_and_die();
			else if (ARGMATCH(p,"no-banner",4))
			{
				print_banner = 0;
				(void)update_number("__BANNER__", (fp_t)print_banner);
			}
			else if (ARGMATCH(p,"no-cd",4))
				cd_pwd_enabled = 0;
			else if (ARGMATCH(p,"no-help-file",4))
				read_help_file = 0;
			else if (ARGMATCH(p,"no-load",6))
				load_enabled = 0;
			else if (ARGMATCH(p,"no-logfile",6))
				logfile_enabled = 0;
			else if (ARGMATCH(p,"no-readline",4))
			{
				use_readline = 0;
				(void)update_number("__READLINE__", (fp_t)use_readline);
			}
			else if (ARGMATCH(p,"no-save",5))
				save_enabled = 0;
			else if (ARGMATCH(p,"no-site-file",5))
				read_site_file = 0;
			else if (ARGMATCH(p,"no-translation-file",4))
				read_translation_file = 0;
			else if (ARGMATCH(p,"no-user-file",4))
				read_user_file = 0;
			else if (ARGMATCH(p,"quick",1))
			{
				read_help_file = 0;
				read_site_file = 0;
				read_translation_file = 0;
				read_user_file = 0;
			}
			else if (ARGMATCH(p,"secure",2))
			{
				cd_pwd_enabled = 0;
				load_enabled = 0;
				logfile_enabled = 0;
				save_enabled = 0;
				file_trace_enabled = 0;
			}
			else if (ARGMATCH(p,"silent",1)) /* NB: can be abbreviated to 1 char */
			{
				verbose_mode = 0;
				(void)update_number("__VERBOSE__", (fp_t)verbose_mode);
			}
			else if (ARGMATCH(p,"trace-file-opening",1))
				(void)update_number("__DEBUG_OPEN__", FP(1.0));
			else if (ARGMATCH(p,"version",1))
				version_and_die();
			else
				usage_and_die(argv[k]);
			/* Remove the option from the argument list */
			for (m = k + 1; m < (*pargc); ++m)
				argv[m-1] = argv[m];
			(*pargc)--;
			k--;	/* avoid missing the next argument */
		}
	}
	argv[*pargc] = (char *)NULL;	/* ANSI C89 Section 2.1.2.2.1: ``argv[argc] shall be a NULL pointer'' */

#if !defined(HAVE_GNU_READLINE)
	use_readline = 0;
	(void)update_number("__READLINE__", (fp_t)use_readline);
#endif

	make_immutable(lookup("__READLINE__"));	/* this decision may someday be changed */
}

static void
do_pre_args(const int *pargc, const char * argv[])
{
	int k;
	const char *p;

	(void)update_string("__FILE__", "command-line"); /* in case error() is called */

	/* Process those command-line arguments that need to be seen
	   before initialization files are read.  No errors are raised
	   here for unrecognized arguments; that will be done in
	   do_post_args().  *pargc and argv[] are left intact. */

	for (k = 1; k < *pargc; ++k)
	{
		p = argv[k];
		if (p[0] == OPTCHAR)
		{
			p++;
			if (p[0] == OPTCHAR)
				++p; /* support GNU/POSIX style --option */

			if (ARGMATCH(p,"no-banner",4))
			{
				print_banner = 0;
				(void)update_number("__BANNER__", (fp_t)print_banner);
			}
			else if (ARGMATCH(p,"no-help-file",4))
				read_help_file = 0;
			else if (ARGMATCH(p,"no-logfile",6))
				logfile_enabled = 0;
			else if (ARGMATCH(p,"no-readline",4))
			{
				use_readline = 0;
				(void)update_number("__READLINE__", (fp_t)use_readline);
			}
			else if (ARGMATCH(p,"no-site-file",5))
				read_site_file = 0;
			else if (ARGMATCH(p,"no-translation-file",4))
				read_translation_file = 0;
			else if (ARGMATCH(p,"no-user-file",4))
				read_user_file = 0;
			else if (ARGMATCH(p,"quick",1))
			{
				read_help_file = 0;
				read_site_file = 0;
				read_translation_file = 0;
				read_user_file = 0;
			}
			else if (ARGMATCH(p,"silent",1)) /* can be abbreviated to 1 character */
			{
				verbose_mode = 0;
				(void)update_number("__VERBOSE__", (fp_t)verbose_mode);
			}
			else if (ARGMATCH(p,"trace-file-opening",1))
				(void)update_number("__DEBUG_OPEN__", FP(1.0));
			else if (*p == 'D')
				do_define(p+1);
			else if (*p == 'U')
				do_undefine(p+1);
		}
	}
}

static void
do_undefine(const char *s)
{
	if (!delete_symbol(lookup(s)))
		error("deletion failed for symbol", s);
}

static void
error(const char *s, const char *t)
{
	warning(s,t);
	exit(EXIT_FAILURE);
}

void
execerror(const char * s, const char * t)	/* recover from run-time error */
{
	warning(s, t);
	(void)fseek(fin, 0L, 2);	/* flush rest of file */
	longjmp(begin, 0);
}

#if defined(__sgi)
#include <sys/fpu.h>

static void
flush_to_zero(int on_off)		/* see "man sigfpe" on SGI IRIX 6.x for documentation */
{
	union fpc_csr n;

	n.fc_word = get_fpc_csr();
	n.fc_struct.flush = (on_off ? 1 : 0);
	set_fpc_csr(n.fc_word);
}
#endif

static int
follow(int expect, int ifyes, int ifno)	/* look ahead for >=, etc. */
{
	int ch = getc(fin);

	if (ch == expect)
		return ifyes;
	(void)ungetc(ch, fin);
	return ifno;
}

void
fpecatch(int dummy)	/* catch floating point exceptions */
{
	execerror("floating point exception", (const char *)NULL);
}

static void
free_argnamelist(void)
{
	efree((void*)argnamelist);
	argnamelist = (Symbol**)NULL;
	numargs = 0;
	maxargs = 0;
}

static void
free_globallist(void)
{
	efree((void*)globallist);
	globallist = (Symbol**)NULL;
	numglobals = 0;
	maxglobals = 0;
}

static const char *
get_locale_filename(const char *dirname, const char *basename)
{
	/* Given dirname = "/x/y/z" and basename == "foo.bar", return a dynamic
	   copy of "/x/y/z/locale/LOCALENAME/foo.bar", where LOCALENAME is
	   obtained from get_locale_name() */
	const char *locale;

	locale = get_locale_name();
	if (locale == (const char *)NULL)
		return ((const char *)NULL);
	else
		return (concat5(dirname, "/locale/", locale, "/", basename));
}

static const char *
get_locale_name(void)
{
	/* According to "man 3c setlocale", the language of text
	messages is determined by the locale variable LC_MESSAGES: its
	value is set by the first-defined of three environment
	variables.  Return a static copy of the value. */

	const char *locale_name;

	locale_name = getenv("LC_ALL");
	if (locale_name == (const char *)NULL)
		locale_name = getenv("LC_MESSAGES");
	if (locale_name == (const char *)NULL)
		locale_name = getenv("LANG");
	return (locale_name);
}

const char *
get_prompt(void)
{
	Symbol *s;

	s = lookup("__PROMPT__");
	if (s == (Symbol*)NULL)
		s = install_string("__PROMPT__", (PACKAGE_NAME "> "));
	return (s->u.str);
}

int
get_verbose(void)
{
	Symbol *s;

	s = lookup("__VERBOSE__");
	if (s == (Symbol*)NULL)
		(void)install_number("__VERBOSE__", (fp_t)verbose_mode);
	else
		verbose_mode = (s->u.val != FP(0.0));
	return (verbose_mode);
}

static void
help_and_die(void)
{
	static const char *text[] =
	{
		"\n",
		"For additional help, try ", PACKAGE_NAME, "'s help() command, or in a shell,\n",
		"use the UNIX manual page command, man ", PACKAGE_NAME, ".\n",

		(const char *)NULL,
	};

	usage();
	show(text);
	exit(EXIT_SUCCESS);
}

static void
init_fp_system(void)
{
	/* Do an system-dependent initializations of the
	   floating-point arithmetic system to enable full IEEE 754
	   support, if possible. */

#if defined(__sgi)
	flush_to_zero(0);		/* to get support for subnormals! */
#endif

}

static void
init_limits(void)
{
	/* Set all of the dynamic table sizes so that they can be
	   queried even before their corresponding arrays have been
	   allocated. */
	(void)update_const_number("__MAX_FRAME__", FP(0.0));
	(void)update_const_number("__MAX_LINE__", FP(0.0));
	(void)update_const_number("__MAX_NAME__", FP(0.0));
	(void)update_const_number("__MAX_PROG__", FP(0.0));
	(void)update_const_number("__MAX_PUSHBACK__",FP(0.0));
	(void)update_const_number("__MAX_STACK__", FP(0.0));
	(void)update_const_number("__MAX_STRING__", FP(0.0));
	(void)update_const_number("__MAX_TOKEN__", FP(0.0));
}

static void
init_lineno(void)
{
	EOF_flag = 0;

	/* Because hoc evaluation happens AFTER complete lines have
	   been read, we start lineno at 0, so that, e.g.,

		println __LINE__

	on line 1 will print 1, not 2. */

	lineno = -1;
	bump_lineno();
}

static void
init_locale(void)
{
#if defined(HAVE_LOCALE_H)
	/* These calls internationalize the hoc language!  However, in
	   order for existing programs to work, numbers MUST use a
	   decimal point, NOT a comma (or other character).  Without
	   this setting, strtod(), fscanf(), and *printf() all alter
	   number formats to locale-specific conventions.  Similarly,
	   settings other than "C" would violate assumptions about
	   sorting in the who() function, and time stamps in the now()
	   function. */

	const char *locale_name;

	locale_name = get_locale_name();
	if (locale_name != (const char *)NULL)
		(void)setlocale(LC_ALL, locale_name);
	(void)setlocale(LC_COLLATE,	"C");
	(void)setlocale(LC_CTYPE,	"C");
	(void)setlocale(LC_MONETARY,	"C");

#if defined(LC_MESSAGES)		/* POSIX.2 extension beyond C89, C++98, and C99 */
	(void)setlocale(LC_MESSAGES,	"C");
#endif

	(void)setlocale(LC_NUMERIC,	"C");
	(void)setlocale(LC_TIME,	"C");
#endif /* defined(HAVE_LOCALE_H) */
}

static void
init_readline(void)
{
#if defined(HAVE_GNU_READLINE)
	(void)rl_bind_key ('\t', rl_insert);	/* TAB is normal, NOT filename completer */
	(void)rl_bind_key ('\033', rl_complete); /* put filename completion on ESCape */
	irl_fd_stdin = dup(fileno(stdin)); /* save handle for original stdin */
#endif
}

static void
init_symbols(void)
{
	(void)update_number("__BANNER__", (fp_t)print_banner); /* so -no-banner setting is available to user code */
	(void)update_number("__READLINE__", (fp_t)use_readline); /* so -no-readline setting is available to user code */
	(void)update_number("__VERBOSE__",(fp_t)verbose_mode); /* so -silent setting is available to user code */

#if defined(HAVE_IEEE_754)
	(void)install_const_number("__IEEE_754__", FP(1.0));
#else
	(void)install_const_number("__IEEE_754__", FP(0.0));
#endif

#if defined(HAVE_ACOSH)
	(void)install_const_number("__NATIVE_ACOSH__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_ACOSH__", FP(0.0));
#endif

#if defined(HAVE_ACOSH)
	(void)install_const_number("__NATIVE_ACOSH__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_ACOSH__", FP(0.0));
#endif

#if defined(HAVE_ASINH)
	(void)install_const_number("__NATIVE_ASINH__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_ASINH__", FP(0.0));
#endif

#if defined(HAVE_ATANH)
	(void)install_const_number("__NATIVE_ATANH__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_ATANH__", FP(0.0));
#endif

#if defined(HAVE_CBRT)
	(void)install_const_number("__NATIVE_CBRT__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_CBRT__", FP(0.0));
#endif

#if defined(HAVE_CEIL)
	(void)install_const_number("__NATIVE_CEIL__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_CEIL__", FP(0.0));
#endif

#if defined(HAVE_COPYSIGN)
	(void)install_const_number("__NATIVE_COPYSIGN__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_COPYSIGN__", FP(0.0));
#endif

#if defined(HAVE_ERF)
	(void)install_const_number("__NATIVE_ERF__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_ERF__", FP(0.0));
#endif

#if defined(HAVE_ERFC)
	(void)install_const_number("__NATIVE_ERFC__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_ERFC__", FP(0.0));
#endif

#if defined(HAVE_EXPM1)
	(void)install_const_number("__NATIVE_EXPM1__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_EXPM1__", FP(0.0));
#endif

#if defined(HAVE_FLOOR)
	(void)install_const_number("__NATIVE_FLOOR__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_FLOOR__", FP(0.0));
#endif

#if defined(HAVE_FMOD)
	(void)install_const_number("__NATIVE_FMOD__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_FMOD__", FP(0.0));
#endif

#if defined(HAVE_GAMMA)
	(void)install_const_number("__NATIVE_GAMMA__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_GAMMA__", FP(0.0));
#endif

#if defined(HAVE_GETGID)
	(void)install_const_number("__NATIVE_GETGID__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_GETGID__", FP(0.0));
#endif

#if defined(HAVE_GETPID)
	(void)install_const_number("__NATIVE_GETPID__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_GETPID__", FP(0.0));
#endif

#if defined(HAVE_GETPPID)
	(void)install_const_number("__NATIVE_GETPPID__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_GETPPID__", FP(0.0));
#endif

#if defined(HAVE_GETUID)
	(void)install_const_number("__NATIVE_GETUID__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_GETUID__", FP(0.0));
#endif

#if defined(HAVE_HYPOT)
	(void)install_const_number("__NATIVE_HYPOT__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_HYPOT__", FP(0.0));
#endif

#if defined(HAVE_ILOGB)
	(void)install_const_number("__NATIVE_ILOGB__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_ILOGB__", FP(0.0));
#endif

#if defined(HAVE_J0)
	(void)install_const_number("__NATIVE_J0__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_J0__", FP(0.0));
#endif

#if defined(HAVE_J1)
	(void)install_const_number("__NATIVE_J1__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_J1__", FP(0.0));
#endif

#if defined(HAVE_JN)
	(void)install_const_number("__NATIVE_JN__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_JN__", FP(0.0));
#endif

#if defined(HAVE_LDEXP)
	(void)install_const_number("__NATIVE_LDEXP__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_LDEXP__", FP(0.0));
#endif

#if defined(HAVE_LGAMMA)
	(void)install_const_number("__NATIVE_LGAMMA__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_LGAMMA__", FP(0.0));
#endif

#if defined(HAVE_LOG1P)
	(void)install_const_number("__NATIVE_LOG1P__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_LOG1P__", FP(0.0));
#endif

#if defined(HAVE_NEAREST)
	(void)install_const_number("__NATIVE_NEAREST__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_NEAREST__", FP(0.0));
#endif

#if defined(HAVE_NEXTAFTER)
	(void)install_const_number("__NATIVE_NEXTAFTER__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_NEXTAFTER__", FP(0.0));
#endif

#if defined(HAVE_REMAINDER)
	(void)install_const_number("__NATIVE_REMAINDER__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_REMAINDER__", FP(0.0));
#endif

#if defined(HAVE_RINT)
	(void)install_const_number("__NATIVE_RINT__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_RINT__", FP(0.0));
#endif

#if defined(HAVE_RSQRT)
	(void)install_const_number("__NATIVE_RSQRT__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_RSQRT__", FP(0.0));
#endif

#if defined(HAVE_SCALB)
	(void)install_const_number("__NATIVE_SCALB__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_SCALB__", FP(0.0));
#endif

#if defined(HAVE_SIGNIFICAND)
	(void)install_const_number("__NATIVE_SIGNIFICAND__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_SIGNIFICAND__", FP(0.0));
#endif

#if defined(HAVE_SNPRINTF)
	(void)install_const_number("__NATIVE_SNPRINTF__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_SNPRINTF__", FP(0.0));
#endif

#if defined(HAVE_STRFTIME)
	(void)install_const_number("__NATIVE_STRFTIME__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_STRFTIME__", FP(0.0));
#endif

#if defined(HAVE_STRTOLD)
	(void)install_const_number("__NATIVE_STRTOLD__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_STRTOLD__", FP(0.0));
#endif

#if defined(HAVE_TRUNC)
	(void)install_const_number("__NATIVE_TRUNC__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_TRUNC__", FP(0.0));
#endif

#if defined(HAVE_Y0)
	(void)install_const_number("__NATIVE_Y0__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_Y0__", FP(0.0));
#endif

#if defined(HAVE_Y1)
	(void)install_const_number("__NATIVE_Y1__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_Y1__", FP(0.0));
#endif

#if defined(HAVE_YN)
	(void)install_const_number("__NATIVE_YN__", FP(1.0));
#else
	(void)install_const_number("__NATIVE_YN__", FP(0.0));
#endif

	(void)install_const_string("__PACKAGE_BUGREPORT__",	PACKAGE_BUGREPORT);
	(void)install_const_string("__PACKAGE_DATE__",		PACKAGE_DATE);
	(void)install_const_string("__PACKAGE_NAME__",		PACKAGE_NAME);
	(void)install_const_string("__PACKAGE_STRING__",	PACKAGE_STRING);
	(void)install_const_string("__PACKAGE_VERSION__",	PACKAGE_VERSION);

	/* Record the initialization file directories and names for
	   use in the language-changing procedures */

	(void)install_const_string("__HOCRC__",		hocrc);
	(void)install_const_string("__SYSHOCDIR__",	syshocdir);
	(void)install_const_string("__SYSHOCHLPBASE__",	syshochlpbase);
	(void)install_const_string("__SYSHOCHLP__",	syshochlp);
	(void)install_const_string("__SYSHOCRCBASE__",	syshocrcbase);
	(void)install_const_string("__SYSHOCRC__",	syshocrc);
	(void)install_const_string("__SYSHOCXLTBASE__",	syshocxltbase);
	(void)install_const_string("__SYSHOCXLT__",	syshocxlt);

	{
		const char *p1;
		const char *p2;
		const char *p3;
		const char *p4;
		(void)install_const_string("__SYSHOCPATH__",
					   p1 = concat5((p2 = concat2(syshocdir, "/site")),
							elementsep,
							(p3 = concat2((p4 = parentdir(syshocdir)), "/site")),
							elementsep,
							syshocdir));
		efree((void *)p1);
		efree((void *)p2);
		efree((void *)p3);
		efree((void *)p4);
	}

	if (getenv(HOCPATH) == (const char *)NULL) /* then supply HOCPATH=".:" */
	{
		const char *p;

		p = concat2(".", elementsep);
		efree((void*)Putenv(HOCPATH, p));
		efree((void*)p);
	}

#if defined(HAVE_GETGID)
	(void)update_const_number("__GID__", (fp_t)getgid());
#else
	(void)update_const_number("__GID__", FP(0.0));
#endif

#if defined(HAVE_GETPID)
	(void)update_const_number("__PID__", (fp_t)getpid());
#else
	(void)update_const_number("__PID__", FP(0.0));
#endif

#if defined(HAVE_GETPPID)
	(void)update_const_number("__PPID__", (fp_t)getppid());
#else
	(void)update_const_number("__PPID__", FP(0.0));
#endif

#if defined(HAVE_GETUID)
	(void)update_const_number("__UID__", (fp_t)getuid());
#else
	(void)update_const_number("__UID__", FP(0.0));
#endif

}

void
intcatch(int dummy)	/* catch interrupts */
{
	execerror("interrupt", (const char *)NULL);
}

static int
is_global(Symbol *s)
{
	int k;

	if ((s != (Symbol*)NULL) && ((s->type == STRVAR) || (s->type == VAR)) && s->builtin)
		return (1);  /* builtin constants are always global */
	for (k = 0; k < numglobals; ++k)
	{
		if (globallist[k] == s)
			return (1);
	}
	return (0);			/* not found */
}

int
main(int argc, char * argv[])	/* hoc7 */
{
	static int first = 1;

	init_limits();			/* this MUST be first! */

#if YYDEBUG
	yydebug = 3;
#endif
	progname = argv[0];
#if 0
	prog = (Inst *)egrow((Inst *)prog, &max_prog, sizeof(prog[0]));
#else
#if 0
	max_prog = 32767;
#else
	max_prog = 8 * 1024 * 1024;
#endif
	prog = (Inst *)emalloc(max_prog * sizeof(prog[0]));
	(void)update_const_number("__MAX_PROG__", (fp_t)max_prog);
#endif
	progp = progbase = &prog[0];

	init_fp_system();
	init_readline();
	init_locale();
	init_builtins();
	init_lineno();
	init_symbols();
	sanity_check();
	do_pre_args(&argc,(const char **)argv);
	do_init_files();
	do_post_args(&argc,argv);
	if (argc == 1) {	/* fake an argument list */
		static char stdhyphen[] = "-";
		static char *stdinonly[] = { stdhyphen, (char *)NULL };

		gargv = stdinonly;
		gargc = 1;
	} else if (first) {	/* for interrupts */
		first = 0;
		gargv = argv+1;
		gargc = argc-1;
	}
	while (moreinput())
		run();
	(void)signal(SIGINT, SIG_IGN);
	irl_free();
	free_symbol_table();
	efree((void*)prog);
	return (EXIT_SUCCESS);
}

int
moreinput(void)
{
	const char *new_filename;

	if (gargc-- <= 0)
		return 0;
	if ((fin != (FILE*)NULL) && (fin != stdin))
	{
		(void)fclose(fin);
		fin = (FILE*)NULL;
	}
	infile = *gargv++;
	if (infile == (const char *)NULL) /* skip over holes from command-line options */
		return moreinput();
	else if (STREQUAL(infile, "-")) {
		fin = stdin;
		new_filename = infile = (const char *)NULL;
#if defined(HAVE_GNU_READLINE)
		(void)dup2(irl_fd_stdin,fileno(stdin)); /* restore original stdin */
	} else if ((fin=Freopen(infile, "r", stdin, &new_filename)) == (FILE*)NULL) {
#else
	} else if ((fin=Fopen(infile, "r", &new_filename)) == (FILE*)NULL) {
#endif
		(void)fprintf(stderr,  msg_translate("%s: can't open %s\n"), progname, infile);
		efree((void *)new_filename);
		return moreinput();
	}
	set_filename((infile == (const char *)NULL) ? "/dev/stdin" : new_filename);
	efree((void *)new_filename);
	return 1;
}

static void
run(void)	/* execute until EOF */
{
	Symbol *sp;
	(void)setjmp(begin);
	(void)signal(SIGINT, intcatch);
	(void)signal(SIGFPE, fpecatch);

#if defined(SIGXCPU)
	(void)signal(SIGXCPU, xcpucatch);
#endif

	sp = lookup("__CPU_LIMIT__");
	if (sp != (Symbol*)NULL)
		(void)CPULimit(sp->u.val);
	for (initcode(); yyparse(); initcode())
		execute(progbase);
}

void
set_filename(const char *filename)
{
	Symbol *s;
	char temp[sizeof("__FILE__") + sizeof("18446744073709551616" /* 2^64 */) + 2];

	infile_count++;
	SNPRINTF4(temp, sizeof(temp), "__FILE__[%02d]", infile_count);
	(void)install_const_string(temp,filename);

	s = lookup("__FILE__");
	if (s == (Symbol*)NULL)
	{
#if 0
		/* temporarily suppressed: see io.c:run3() header comments for why */
		(void)install_const_string("__FILE__",filename);
#else
		(void)install_string("__FILE__",filename);
#endif
	}
	else
		(void)set_string(s,filename);
	init_lineno();
}

static void
looponly(const char *s)	/* warn if break/continue statement illegally placed */
{
	if (!inloop)
		execerror(s, "illegal outside loop body");
}

static int
nth_arg(Symbol *s)
{	/* return argument number (1, 2, 3, ...), or 0 if not found */
	int k;

	for (k = 0; k < numargs; ++k)
	{
		if (argnamelist[k] == s)
			return (k+1);
	}
	return (0);			/* not found */
}

static void
show(const char *text[])
{
	size_t k;

	for (k = 0; text[k] != (const char *)NULL; ++k)
		(void)fprintf(stderr,"%s", msg_translate(text[k]));
}

static const char *
symtype(Symbol *s)
{
	switch ((s == (Symbol*)NULL) ? -1 : (s->type))
	{
	case ADDEQ:		return ("ADDEQ");
	case AND:		return ("AND");
	case ARG:		return ("ARG");
	case BLTIN0:		return ("BLTIN0");
	case BLTIN1:		return ("BLTIN1");
	case BLTIN1I:		return ("BLTIN1I");
	case BLTIN1S:		return ("BLTIN1S");
	case BLTIN2:		return ("BLTIN2");
	case BLTIN2S:		return ("BLTIN2S");
	case BREAK:		return ("BREAK");
	case CONSTEQ:		return ("CONSTEQ");
	case CONTINUE:		return ("CONTINUE");
	case DEC:		return ("DEC");
	case DIVEQ:		return ("DIVEQ");
	case ELSE:		return ("ELSE");
	case EQ:		return ("EQ");
	case FOR:		return ("FOR");
	case FUNC:		return ("FUNC");
	case FUNCTION:		return ("FUNCTION");
	case GE:		return ("GE");
	case GT:		return ("GT");
	case IF:		return ("IF");
	case INC:		return ("INC");
	case LE:		return ("LE");
	case LT:		return ("LT");
	case LTGT:		return ("LTGT");
	case MODEQ:		return ("MODEQ");
	case MULEQ:		return ("MULEQ");
	case NE:		return ("NE");
	case NOT:		return ("NOT");
	case NUMBER:		return ("NUMBER");
	case OR:		return ("OR");
	case PRINT:		return ("PRINT");
	case PRINTF:		return ("PRINTF");
	case PRINTLN:		return ("PRINTLN");
	case PROC:		return ("PROC");
	case PROCEDURE:		return ("PROCEDURE");
	case READ:		return ("READ");
	case RETURN:		return ("RETURN");
	case SPRINTF:		return ("SPRINTF");
	case STRARG:		return ("STRARG");
	case STRBLTIN0:		return ("STRBLTIN0");
	case STRBLTIN1:		return ("STRBLTIN1");
	case STRBLTIN1N:	return ("STRBLTIN1N");
	case STRBLTIN2:		return ("STRBLTIN2");
	case STRBLTIN2SN:	return ("STRBLTIN2SN");
	case STRBLTIN3SNN:	return ("STRBLTIN3SNN");
	case STRING:		return ("STRING");
	case STRVAR:		return ("STRVAR");
	case SUBEQ:		return ("SUBEQ");
	case TO_POWER:		return ("POWER");
	case UNARYMINUS:	return ("UNARYMINUS");
	case UNARYPLUS:		return ("UNARYPLUS");
	case UNDEF:		return ("UNDEF");
	case VAR:		return ("VAR");
	case WHILE:		return ("WHILE");
	default:		return ("UNKNOWN");
	}
}

static void
usage(void)
{
	static const char *text[] =
	{
		"Usage:\n",
		"\t",
		"",
		"\t[ --author ] [ --? ] [ --copyright] [ --Dname ]\n",
		"\t\t[ --Dname=number ] [ --Dname=\"string\" ]\n",
		"\t\t[ --Dname=symbol ] [ --help ] [ --no-banner ]\n",
		"\t\t[ --no-cd ] [ --no-help-file ] [ --no-load ]\n",
		"\t\t[ --no-logfile ] [ --no-readline ] [ --no-save ]\n",
		"\t\t[ --no-site-file ] [ --no-translation-file ]\n",
		"\t\t[ --no-user-file ] [ --quick ] [ --secure ]\n",
		"\t\t[ --silent ] [ --trace-file-opening ][ --Uname ]\n",
		"\t\t[ --version ]\n",
		"\t\tinput-file(s) [ -- ] more-input-file(s)\n\n",
		"Options may be prefixed with either one or two hyphens.\n",
		(const char *)NULL,
	};
	text[2] = progname;		/* cannot be done at compile time */
	show(text);
}

static void
usage_and_die(const char *bad_option)
{
	(void)fprintf(stderr, msg_translate("Unrecognized option: [%s]\n"), bad_option);
	usage();
	exit(EXIT_FAILURE);
}

static void
version_and_die(void)
{
	static const char *text[] =
	{
		"This is ", PACKAGE_NAME,
		" version ", PACKAGE_VERSION,
		" of ", PACKAGE_DATE, ".\n\n",
		"Report bugs to ", PACKAGE_BUGREPORT, "\n",
		(const char *)NULL,
	};
	show(text);
	exit(EXIT_SUCCESS);
}

void
warning(const char *s, const char *t)	/* print warning message */
{
	const char *current_filename;
	(void)fflush(stdout);		/* force out any buffered data */
	(void)fflush(stderr);

	s = msg_translate(s);		/* internationalize the output */
	t = msg_translate(t);

#if 1
	/* Use GNU and UNIX standard
		file:lineno:message
	format instead of old style
		program:message [in file] near line nnn */

	current_filename = get_string("__FILE__");

	(void)fprintf(stderr, "\n");	/* ensure that message starts on a new line! */
	(void)fprintf(stderr, "%s:%d:%s", current_filename, lineno, s);
	if (t != (const char *)NULL)
		(void)fprintf(stderr, " %s", t);
	(void)fprintf(stderr, "\n");

	if (logfile_enabled && (fplog != (FILE*)NULL))
	{
		(void)fprintf(fplog, "#-? %s:%d:%s", current_filename, lineno, s);
		if (t != (const char *)NULL)
			(void)fprintf(fplog, " %s", t);
		(void)fprintf(fplog, "\n");
	}
#else
	(void)fprintf(stderr, "%s: %s", progname, s);
	if (t)
		(void)fprintf(stderr, " %s", t);
	if (infile)
		(void)fprintf(stderr, " in %s", infile);
	(void)fprintf(stderr, " near line %d\n", lineno);
#endif

	while (this_c != '\n' && this_c != EOF)
		if((this_c = getc(fin), this_c) == '\n')	/* flush rest of input line */
			bump_lineno();
		else if (this_c == EOF && errno == EINTR) {
			clearerr(stdin);	/* ick! */
			errno = 0;
		}
	(void)fflush(stderr);
}

void
yyerror(YYCONST char * s)	/* report compile-time error */
{
/*rob
	warning(s, (const char *)NULL);
	longjmp(begin, 0);
rob*/
	execerror(s, (const char *)NULL);
}

Symbol *
yygetid(void)		/* get identifier, installing it in the symbol table if necessary */
{
	Symbol *s;
	static char *sbuf = (char *)NULL;
	static size_t max_sbuf = 0;
	size_t n;

	if (max_sbuf == (size_t)0)	/* guarantee that buffer exists so NUL can be stored */
		sbuf = (char *)emalloc(max_sbuf = (size_t)8);

	this_c = getc(fin);
	n = 0;
	do
	{
		if ((n + 2) > max_sbuf)
		{
			sbuf = (char *)egrow((void *)sbuf, &max_sbuf, sizeof(sbuf[0]));
			(void)update_const_number("__MAX_NAME__", (fp_t)max_sbuf);
		}
		sbuf[n++] = this_c;
	} while ((this_c=getc(fin)) != EOF && IsIdMiddle(this_c));
	(void)ungetc(this_c, fin);
	sbuf[n] = '\0';
	if (indef)			/* variable in func/proc definition */
		s = yygetlocal(sbuf);
	else				/* not in func/proc definition */
	{
		s = lookup(sbuf);
		if (s == (Symbol*)NULL)	/* new global variable */
			s = install(sbuf, UNDEF, FP(0.0));
	}

#if defined(DEBUG_YYLEX)
	(void)fprintf(stderr,"yygetid() -> [%s] [%s]\n", s->name, symtype(s));
#endif

	return (s);
}

static Symbol *
yygetlocal(const char *name)
{
	/* map variable names in func/proc declaration and body to private local variables */
	const char *p;
	Symbol *s;

	/* Local variables are stored in the symbol table with names
	   that are both unique (by virtue of a sequence number that
	   increments for each new function/procedure (re)definition),
	   and unlikely for user-level code to reference accidentally
	   (by including a nonalphabetic character in their names)
	   [although who() can expose them, and symstr() and symnum()
	   can extract their values].  For debugging convenience, we
	   also include the function/procedure name.  Function
	   is_local() in symbol.c, and the PREDIFF filters in
	   test[0-9]+/Makefile, are the only places that needs to know the
	   format of local variable names. */
	p = concat6("@@", this_procname, "@@", fmtnum((fp_t)ndefns), "@@", name);
	if (in_argnamelist)
	{
		s = lookup(p);
		if (s != (Symbol*)NULL)
			execerror("duplicate argument name", name);
		s = install(p, UNDEF, FP(0.0));
	}
	else			/* in func/proc statement body */
	{
		s = lookup(name);
		if (in_global_stmt)
		{
			if (nth_arg(lookup(p)) > 0)
				execerror("cannot redeclare argument as global", s->name);
			else if (s == (Symbol*)NULL) /* new global variable */
				s = install(name, UNDEF, FP(0.0));
		}
		else if (!is_global(s))
		{
			if ( (s == (Symbol*)NULL) || (s->type == UNDEF) ||
			     (s->type == STRVAR) || (s->type == VAR) )
			{
				s = lookup(p);
				if (s == (Symbol*)NULL)	/* variable is a new local variable */
					s = install(p, UNDEF, FP(0.0));
			}
		}
		if (s == (Symbol*)NULL)	/* should never happen */
			execerror("internal error in yygetlocal(): unexpected NULL symbol for", name);
	}
	efree((void*)p);
	return (s);
}

const char *
yygetstr(void)
{	/* get a quoted string, assuming that the opening quote has just been read */
	static char *sbuf = (char *)NULL;
	static size_t max_sbuf = 0;
	int the_c;
	size_t n;

	if (max_sbuf == (size_t)0)	/* guarantee that buffer exists so NUL can be stored */
		sbuf = (char *)emalloc(max_sbuf = (size_t)16);

	for (n = 0; (the_c = getc(fin)) != QUOTATION_MARK; )
	{
		if (the_c == '\n' || the_c == EOF)
			execerror("missing quote", "");
		if ((n + 2) > max_sbuf)
		{
			sbuf = (char *)egrow((void *)sbuf, &max_sbuf, sizeof(sbuf[0]));
			(void)update_const_number("__MAX_STRING__", (fp_t)max_sbuf);
		}
		sbuf[n++] = backslash(the_c);
	}
	sbuf[n] = '\0';

	return((const char *)&sbuf[0]);
}

int
yylex(void)		/* hoc6 */
{
	while ((this_c=getc(fin)) == ' ' || this_c == '\t')
		;
	if (this_c == EOF)
		return 0;
	if (this_c == '\\') {
		this_c = getc(fin);
		if (this_c == '\n') {
			bump_lineno();
			return yylex();
		}
	}
	if (this_c == '#') {		/* comment */
		while ((this_c=getc(fin)) != '\n' && this_c != EOF)
			;
		if (this_c == '\n')
			bump_lineno();
		return this_c;
	}
	if (this_c == '.' || isdigit(this_c)) {	/* number */
		fp_t d;
		(void)ungetc(this_c, fin);
		(void)fscanf(fin, "%lf", &d); /* NB: this is really irl_fscanf(), which handles long double case correctly */
		yylval.sym = install("", NUMBER, d);
#if defined(DEBUG_YYLEX)
		(void)fprintf(stderr,"yylex() -> [%s] [NUMBER]\n", fmtnum(d));
#endif
		return NUMBER;
	}
	if (IsIdStart(this_c))
	{
		Symbol *s;
		(void)ungetc(this_c,fin);
		yylval.sym = s = yygetid();
		if (indef && !in_argnamelist) /* then in func/proc statement body */
		{
			int n;

			n = nth_arg(s);
			if (n > 0)	/* remap named argument to $nnn for code.c processing */
			{
				yylval.narg = n;
#if defined(DEBUG_YYLEX)
				(void)fprintf(stderr,"yylex() -> [%s] [$%d] [%s]\n",
					      s->name, n, "ARG");
#endif
				return (ARG);
			}
		}
#if defined(DEBUG_YYLEX)
		(void)fprintf(stderr,"yylex() -> [%s] [%s]\n",
			      s->name, ((s->type == UNDEF) ? "VAR" : symtype(s)));
#endif
		return (s->type == UNDEF ? VAR : s->type);
	}
	if (this_c == '$') {	/* argument? */
		int n = 0;
		long type;
		this_c = getc(fin);
		if (this_c == '$')	/* $$n means string argument instead of numeric argument, $n */
			type = STRVAR;
		else
		{
			type = VAR;
			(void)ungetc(this_c, fin);
		}
		while (isdigit(this_c=getc(fin)))
			n = 10 * n + this_c - '0';
		(void)ungetc(this_c, fin);
		if (n == 0)
			execerror("strange $...", (const char *)NULL);
		yylval.narg = n;
#if defined(DEBUG_YYLEX)
		(void)fprintf(stderr,"yylex() -> [$%d] [%s]\n", n, ((type == VAR) ? "ARG" : "STRARG"));
#endif
		return (type == VAR) ? ARG : STRARG;
	}
	if (this_c == QUOTATION_MARK) {	/* quoted string */
		const char *sbuf;
		sbuf = yygetstr();
#if 0
		/* Old ugly code that masquerades a string on top of a Symbol */
		yylval.sym = (Symbol *)emalloc(strlen(sbuf)+1);
		strcpy((char *)yylval.sym, sbuf);
#else
		/* New code to generate a real Symbol instead */
#if 0
		yylval.sym = (Symbol *)emalloc(sizeof(Symbol));
		yylval.sym->name = (const char *)NULL;
		yylval.sym->type = STRING;
		yylval.sym->u.str = dupstr(sbuf);
		make_immutable(yylval.sym);
		yylval.sym->next = (Symbol*)NULL;
#else
		yylval.sym = install_const_string("", sbuf);
#endif
#endif
#if defined(DEBUG_YYLEX)
		(void)fprintf(stderr,"yylex() -> [%s] [STRING]\n", sbuf);
#endif
		return STRING;
	}

#if defined(DEBUG_YYLEX)
	(void)fprintf(stderr,"yylex() -> [%d] [OPERATOR]\n", this_c);
#endif
	switch (this_c) {
	case '^':	return TO_POWER;
	case ':':	return follow('=', CONSTEQ, ':');
	case '+':	return follow('+', INC, follow('=', ADDEQ, '+'));
	case '-':	return follow('-', DEC, follow('=', SUBEQ, '-'));
	case '*':	return follow('=', MULEQ, follow('*', TO_POWER, '*'));
	case '/':	return follow('=', DIVEQ, '/');
	case '%':	return follow('=', MODEQ, '%');
	case '>':	return follow('=', GE, GT);
	case '<':	{
				if (follow('=', LE, LT) == LE)
					return (LE);
				else if (follow('>', LTGT, LT) == LTGT)
					return (LTGT);
				else
					return (LT);
			}
	case '=':	return follow('=', EQ, '=');
	case '!':	return follow('=', NE, NOT);
	case '|':	return follow('|', OR, '|');
	case '&':	return follow('&', AND, '&');
	case '\n':	bump_lineno(); return '\n';
	default:	return this_c;
	}
}
@


1.24
log
@Add anyexpr to %type <inst> list.  Generalize grammar rules for
strasgn, strexpr, and expr.  Change internal names of local variables
to include the function/procedure name.  Change some type assignments
to UNDEF in yygetlocal().  Revise and add some DEBUG_YYLEX conditional
debugging statements.
@
text
@d275 1
a1985 1
	static char *nbuf = (char *)NULL;
@


1.23
log
@Add support for named function/procedure arguments, the global
statement, and new default of local, instead of global, visibility of
body variables.  This requires several new static variables, new
functions (addarg(), addglobal(), free_argnamelist(),
free_globallist(), is_global(), nth_arg(), symtype(), and
yygetlocal()), and additional grammar rules (argnames, beginargs,
endargs, enddefn, and globalnames).  By remapping argument names to
argument numbers in yygetid() and yygetlocal(), no changes are needed
in the virtual machine in code.c.  Yet to be fixed is the syntactical
peculiarity that for an argument, n, n++ is rejected, but n=n+1 is
accepted (this is historical, and noted in the BUGS section of hoc.1).
@
text
@d146 1
d181 1
d205 1
a205 1
%type	<inst>	expr stmt asgn prlist prflist sprflist stmtlist
d261 2
a262 2
strasgn:  STRVAR '=' strexpr		{CODE3(varpush,(Inst)$1,str_assign); $$=$3; }
	| STRVAR CONSTEQ strexpr	{CODE3(varpush,(Inst)$1,const_str_assign); $$=$3; }
d264 3
a266 2
	| VAR '=' strexpr		{CODE3(varpush,(Inst)$1,str_assign); $$=$3; }
	| VAR CONSTEQ strexpr		{CODE3(varpush,(Inst)$1,const_str_assign); $$=$3; }
d353 4
d364 5
a368 5
	| STRBLTIN1 '(' strexpr ')'		{ $$ = $3; CODE2(strbltin1, (Inst)$1->u.sptr1); }
	| STRBLTIN1N '(' expr ')'		{ $$ = $3; CODE2(strbltin1n, (Inst)$1->u.sptr1n); }
	| STRBLTIN2 '(' strexpr ',' strexpr ')'	{ $$ = $3; CODE2(strbltin2, (Inst)$1->u.sptr2); }
	| STRBLTIN2SN '(' strexpr ',' expr ')'	{ $$ = $3; CODE2(strbltin2sn, (Inst)$1->u.sptr2sn); }
	| STRBLTIN3SNN '(' strexpr ',' expr ',' expr ')' { $$ = $3; CODE2(strbltin3snn, (Inst)$1->u.sptr3snn); }
d372 8
a379 6
	| expr NUMBER				{ CODE3(constpush, (Inst)$2, str_concat_nn); }
	| expr VAR				{ CODE3(constpush, (Inst)$2, str_concat_ns); }
	| expr string				{ CODE(str_concat_ns); }
	| strexpr NUMBER			{ CODE3(constpush, (Inst)$2, str_concat_sn); }
	| strexpr VAR				{ CODE3(constpush, (Inst)$2, str_concat_sn); }
	| strexpr string			{ CODE(str_concat_ss); }
d390 1
a390 1
	| BLTIN1 '(' expr ')'         		{ $$ = $3; CODE2(bltin1, (Inst)$1->u.ptr1); }
d393 3
a395 3
	| BLTIN1S '(' strexpr ')'         	{ $$ = code2(bltin1s, (Inst)$1->u.ptr1s); }
	| BLTIN2 '(' expr ',' expr ')'		{ $$ = $3; CODE2(bltin2, (Inst)$1->u.ptr2); }
	| BLTIN2S '(' strexpr ',' strexpr ')'	{ $$ = $3; CODE2(bltin2s, (Inst)$1->u.ptr2s); }
d465 7
a471 1
beginargs: /* nothing */			{ free_argnamelist(); free_globallist(); ndefns++; in_argnamelist = 1; }
d1735 1
a1735 1
void
d2029 12
a2040 1
	p = concat3(fmtnum((fp_t)ndefns), "@@", name); /* nnn@@name is guaranteed to be unique */
d2046 1
a2046 1
		s = install(p, VAR, FP(0.0));
d2056 1
a2056 1
				s = install(name, VAR, FP(0.0));
d2065 1
a2065 1
					s = install(p, VAR, FP(0.0));
d2129 1
a2129 1
		(void)fprintf(stderr,"yylex() -> NUMBER [%s]\n", fmtnum(d));
d2146 4
d2153 5
a2157 1
		return s->type == UNDEF ? VAR : s->type;
d2177 1
a2177 1
		(void)fprintf(stderr,"yylex() -> %s [%d]\n", ((type == VAR) ? "ARG" : "STRARG"), n);
d2202 1
a2202 1
		(void)fprintf(stderr,"yylex() -> STRING [%s]\n", sbuf);
d2206 4
@


1.22
log
@Rename misnamed __LINENO__ to __LINE__.
@
text
@d130 9
d154 2
d162 1
a162 1
static void		do_one_init_file ARGS((const char *filename));
d169 2
d178 2
d181 1
d185 1
d196 4
a199 4
%token	<sym>	CONTINUE ELSE FOR FUNC FUNCTION IF NUMBER PRINT PRINTF
%token	<sym>	PRINTLN PROC PROCEDURE READ RETURN SPRINTF STRBLTIN0
%token	<sym>	STRBLTIN1 STRBLTIN1N STRBLTIN2 STRBLTIN2SN STRBLTIN3SNN
%token	<sym>	STRING STRVAR UNDEF VAR WHILE
d276 2
d418 7
d441 8
a448 4
defn:	  FUNC procname				{ $2->type=FUNCTION; indef=1; }
	    '(' ')' stmt			{ CODE(procret); define($2); indef=0; }
	| PROC procname				{ $2->type=PROCEDURE; indef=1; }
	    '(' ')' stmt			{ CODE(procret); define($2); indef=0; }
d456 18
a473 5
arglist:  /* nothing */ 			{ $$ = 0; }
	| expr					{ $$ = 1; }
	| strexpr				{ $$ = 1; }
	| arglist ',' expr			{ $$ = $1 + 1; }
	| arglist ',' strexpr			{ $$ = $1 + 1; }
d525 16
d1117 18
d1618 15
d1771 13
d1793 65
d1970 1
d1980 2
a1981 1
	do {
d1991 8
a1998 2
	if ((s=lookup(sbuf),s) == (Symbol*)NULL)
		s = install(sbuf, UNDEF, FP(0.0));
d2001 1
a2001 1
	(void)fprintf(stderr,"yygetid() -> VAR [%s]\n", sbuf);
d2007 42
d2103 1
a2103 1
		(void)fprintf(stderr,"yylex() -> NUMBER [%lg]\n", d);
d2107 2
a2108 1
	if (IsIdStart(this_c)) {
d2112 11
@


1.21
log
@Make minor adjustments in setting of $$ in the *BLTIN* rules.
@
text
@d588 1
a588 1
		s = lookup("__LINENO__");
d590 1
a590 1
			s = install_number("__LINENO__", FP(0.0));
d595 1
a595 1
	*pdlineno = (fp_t)lineno;	/* update __LINENO__ value in symbol table */
d599 1
a599 1
	s = lookup("__LINENO__");
d601 1
a601 1
		s = install_number("__LINENO__", FP(0.0));
d1169 1
a1169 1
		println __LINENO__
@


1.20
log
@Major update in %token <sym> lists and grammar rules to remove many
function names from the grammar.  Rename othername to otherword (to
resemble `keyword').  Add grammar rules for BLTIN1I, BLTIN2S,
STRBLTIN2SN, and STRBLTIN3SNN.
@
text
@d337 1
a337 1
	| STRBLTIN0 '(' ')'			{ CODE2(strbltin0, (Inst)$1->u.sptr0); }
d361 1
a361 1
	| BLTIN0 '(' ')'              		{ CODE2(bltin0, (Inst)$1->u.ptr0); }
d363 3
a365 3
	| BLTIN1I '(' keyword ')'		{ CODE3(bltin1i, (Inst)$1->u.ptr1i, (Inst)$3); }
	| BLTIN1I '(' otherword ')'		{ CODE3(bltin1i, (Inst)$1->u.ptr1i, (Inst)$3); }
	| BLTIN1S '(' strexpr ')'         	{ $$ = $3; CODE2(bltin1s, (Inst)$1->u.ptr1s); }
@


1.19
log
@Change get_locale_filename() to return a dynamic string, and free it
after use.  Change string equality tests to use STREQUAL().  Free
strings returned from Fopen() and Putenv().  Add final cleanup calls
in main() to irl_free() and free_symbol_table().
@
text
@d171 1
d177 7
a183 7
%token	<sym>	NUMBER STRING PRINT VAR UNDEF WHILE FOR IF ELSE
%token	<sym>	FUNCTION PROCEDURE RETURN FUNC PROC READ
%token	<sym>	ABORT BLTIN0 BLTIN1 BLTIN1S BLTIN2 BREAK CONTINUE
%token	<sym>	DEFINED DELETE HEX HEXFP HEXINT INDEX LENGTH NUMTOSTR
%token	<sym>	PRINTF PRINTLN SPRINTF STRBLTIN0 STRBLTIN1 STRBLTIN1N
%token	<sym>	STRBLTIN2 STRVAR STRFTIME STRTONUM STRTOSYMNUM
%token	<sym>	STRTOSYMSTR SUBSTR
d185 1
d189 3
a191 1
%type	<sym>	keyword othername procname
d193 1
d195 1
d202 1
a299 2
	| HEX
	| ABORT
a301 7
	| DEFINED
	| DELETE
	| HEXFP
	| HEXINT
	| INDEX
	| LENGTH
	| STRTONUM
a304 5
	| STRFTIME
	| NUMTOSTR
	| SUBSTR
	| STRTOSYMNUM
	| STRTOSYMSTR
d307 1
a307 1
othername: BLTIN0
d309 1
d312 1
d319 2
a335 3
	| HEXFP '(' expr ')'			{ CODE(hexfp); }
	| HEXINT '(' expr ')'			{ CODE(hexint); }
	| NUMTOSTR '(' expr ')'			{ CODE(numtostr); }
d337 6
a342 7
	| STRBLTIN0 '(' ')'			{ CODE2(strbltin0, (Inst)$1->u.ptr0); }
	| STRBLTIN1 '(' strexpr ')'		{ $$ = $3; CODE2(strbltin1, (Inst)$1->u.ptr1); }
	| STRBLTIN1N '(' expr ')'		{ $$ = $3; CODE2(strbltin1n, (Inst)$1->u.ptr1); }
	| STRBLTIN2 '(' strexpr ',' strexpr ')'	{ $$ = $3; CODE2(strbltin2, (Inst)$1->u.ptr2); }
	| STRFTIME '(' strexpr ',' expr ')'	{ CODE(str_strftime); $$ = $3; }
	| STRTOSYMSTR '(' strexpr ')'		{ CODE(str_to_symstr); $$ = $3; }
	| SUBSTR '(' strexpr ',' expr ',' expr ')'	{ CODE(str_substr); $$ = $3; }
a360 6
	| ABORT '(' STRING ')'			{ $$ = code2(abort_user, (Inst)$3); }
	| DEFINED '(' keyword ')'		{ $$ = code2(Defined, (Inst)$3); }
	| DEFINED '(' othername ')'		{ $$ = code2(Defined, (Inst)$3); }
	| DELETE '(' keyword ')'		{ $$ = code2(Delete, (Inst)$3); }
	| DELETE '(' othername ')'		{ $$ = code2(Delete, (Inst)$3); }
	| HEX '(' expr ')'			{ CODE(hex); }
d363 3
a365 1
	| BLTIN1S '(' strexpr ')'         	{ $$ = $3; CODE2(bltin1s, (Inst)$1->u.ptr1); }
d367 1
a367 4
	| INDEX '(' strexpr ',' strexpr ')'	{ CODE(str_index); $$ = $5; }
	| LENGTH '(' strexpr ')'		{ CODE(str_length); $$ = $3; }
	| STRTOSYMNUM '(' strexpr ')'		{ CODE(str_to_symnum); $$ = $3; }
	| STRTONUM '(' strexpr ')'		{ CODE(str_to_num); $$ = $3; }
@


1.18
log
@Add SPRINTF to %token list and to keyword and strexpr grammar rules.
Add sprflist grammar rule.  Add sprflist to inst list.  At end of
main(), free the prog memory.
@
text
@d180 2
a181 2
%token	<sym>	PRINTF PRINTLN SPRINTF STRBLTIN0 STRBLTIN1 STRBLTIN1N 
%token	<sym>	STRBLTIN2 STRVAR STRFTIME STRTONUM STRTOSYMNUM 
d779 2
d784 3
a786 1
		do_one_init_file(get_locale_filename(syshocdir, syshocrcbase));
d792 3
a794 1
		do_one_init_file(get_locale_filename(syshocdir, syshochlpbase));
d800 3
a802 1
		do_one_init_file(get_locale_filename(syshocdir, syshocxltbase));
d836 1
d841 1
d868 1
a868 1
			if (strcmp(p,"") == 0) /* ignore "-" option (meaning, stdin) */
d1075 3
a1077 3
	/* Given dirname = "/x/y/z" and basename == "foo.bar", return
	   "/x/y/z/locale/LOCALENAME/foo.bar", where LOCALENAME is obtained 
	   from get_locale_name() */
d1093 1
a1093 1
	variables. */
d1515 7
a1521 1
		(void)Putenv(HOCPATH, concat2(".", elementsep));
d1603 2
d1606 1
a1606 1
	return 0;
d1624 1
a1624 1
	else if (strcmp(infile, "-") == 0) {
@


1.17
log
@Add support for new --trace-file-opening option in do_post_args(),
do_pre_args(), and usage().  Update get_locale_filename() to add
/locale/ to the directory path.
@
text
@d180 3
a182 2
%token	<sym>	PRINTF PRINTLN STRBLTIN0 STRBLTIN1 STRBLTIN1N STRBLTIN2
%token	<sym>	STRVAR STRFTIME STRTONUM STRTOSYMNUM STRTOSYMSTR SUBSTR
d184 1
a184 1
%type	<inst>	expr stmt asgn prlist prflist stmtlist
a303 2
	| STRTOSYMNUM
	| STRTOSYMSTR
d306 1
d310 2
d359 1
d424 5
d1587 1
@


1.16
log
@Add declarations of code_argname and debug_code that are enabled only
when the preprocessor symbol DEBUG_CODE is defined.

Add declaration of new global inloop, and add new tokens BREAK and
CONTINUE to %token list.

Add new subrules for BREAK and CONTINUE in stmt rule and keyword rule.

Fix long-standing bug in handling of return statement, present in the
1984 book: the action for RETURN was missing an assignment to $$,
producing a core dump:

	% hoc-6.0
	proc f() {if ($1 == 0) return }
	f(1)
	f(0)
	Segmentation fault (core dumped)

Putting the return inside a compound statement eliminated the error:

	% hoc-6.0
	proc f() {if ($1 == 0) {return} }
	f(1)
	f(0)

With the assignment to $$, both code samples work correctly.

Revise rules for `for' and `while' statements in stmt rule to
increment and decrement the inloop flag around the parsing of the loop
body, so that illegal use of break and continue outside loops can be
detected (the return statement in hoc 6 was handled the same way).

Add new looponly() function to report illegal placement of break and
continue statements.
@
text
@d914 2
d991 2
d1058 2
a1059 2
	   "/x/y/z/LOCALENAME/foo.bar", where LOCALENAME is obtained from
	   get_locale_name() */
d1066 1
a1066 1
		return (concat5(dirname, "/", locale, "/", basename));
d1690 2
a1691 1
		"\t\t[ --silent ] [ --Uname ] [ --version ]\n",
@


1.15
log
@Add new %token members BLTIN1S and STRBLTIN1N, and add them to the
othername rule, and to the expr and string rules, respectively.
@
text
@d107 6
d125 1
d164 1
d178 4
a181 3
%token	<sym>	ABORT BLTIN0 BLTIN1 BLTIN1S BLTIN2 DEFINED DELETE HEX HEXFP HEXINT
%token	<sym>	INDEX LENGTH NUMTOSTR PRINTF PRINTLN STRBLTIN0 STRBLTIN1 STRBLTIN1N
%token	<sym>	STRBLTIN2 STRVAR STRFTIME STRTONUM STRTOSYMNUM STRTOSYMSTR SUBSTR
d243 3
a245 1
	| RETURN			{ defnonly("return"); CODE(procret); }
d251 4
a254 4
	| while '(' cond ')' stmt end {
		($1)[1] = (Inst)$5;	/* body of loop */
		($1)[2] = (Inst)$6; }	/* end, if cond fails */
	| for '(' cond ';' cond ';' cond ')' stmt end {
d257 2
a258 2
		($1)[3] = (Inst)$9;	/* body of loop */
		($1)[4] = (Inst)$10; }	/* end, if cond fails */
d294 2
d1656 7
@


1.14
log
@Change "(void)code" to macros "CODE" to reduce clutter.

Add prflst to inst list and associated grammar rule to complete the
support for printf.

Generate code to call prsep at output list commas, eliminating the
inconsistent handling of numbers and strings.

Add code to recognize "**" as a synonym for "^", to facilate
copy-and-paste of Fortran code into hoc.

Add support for __NATIVE_GETPPID__ and __PPID__ builtin constants.

In warning (), output a newline on stderr before printing any error
message, to prevent it from being confusingly embedded in any
output-in-progress.

In the grammar rule for string expressions, for the case "expr VAR",
call str_concat_ns() instead of str_concat_nn() to make "x = 123ABC"
produce a string value "123" (assuming ABC is undefined, and thus,
evaluates to an empty string).  Previously, ABC would be evaluated as
a number, which is 0 if ABC is undefined, and the result would be
"1230".  The new behavior conforms to what awk does.
@
text
@d170 2
a171 2
%token	<sym>	ABORT BLTIN0 BLTIN1 BLTIN2 DEFINED DELETE HEX HEXFP HEXINT
%token	<sym>	INDEX LENGTH NUMTOSTR PRINTF PRINTLN STRBLTIN0 STRBLTIN1
d301 1
d307 1
d330 1
d360 1
@


1.13
log
@Add definitions of __NATIVE_xxx__ for all mathematical functions xxx().
Remove (void) cast on SNPRINTFn() calls, since they now expand into
do {...} while (0).
@
text
@d110 4
a113 1

d174 1
a174 1
%type	<inst>	expr stmt asgn prlist stmtlist
d186 1
a186 1
%right	'^'
d191 5
a195 5
	| list asgn eos		{ (void)code2(xpop, STOP); return 1; }
	| list strasgn eos	{ (void)code2(xpop, STOP); return 1; }
	| list stmt eos		{ (void)code(STOP); return 1; }
	| list expr eos		{ (void)code2(printtop, STOP); return 1; }
	| list strexpr eos	{ (void)code2(printtopstring, STOP); return 1; }
d203 34
a236 34
asgn:	  VAR '=' expr		{ (void)code3(varpush,(Inst)$1,assign); $$=$3; }
	| VAR CONSTEQ expr	{ (void)code3(varpush,(Inst)$1,const_assign); $$=$3; }
	| VAR ADDEQ expr	{ (void)code3(varpush,(Inst)$1,addeq); $$=$3; }
	| VAR SUBEQ expr	{ (void)code3(varpush,(Inst)$1,subeq); $$=$3; }
	| VAR MULEQ expr	{ (void)code3(varpush,(Inst)$1,muleq); $$=$3; }
	| VAR DIVEQ expr	{ (void)code3(varpush,(Inst)$1,diveq); $$=$3; }
	| VAR MODEQ expr	{ (void)code3(varpush,(Inst)$1,modeq); $$=$3; }
	| STRVAR '=' expr	{ (void)code3(varpush,(Inst)$1,assign); $$=$3; }
	| STRVAR CONSTEQ expr	{ (void)code3(varpush,(Inst)$1,const_assign); $$=$3; }
	| STRVAR ADDEQ expr	{ (void)code3(varpush,(Inst)$1,addeq); $$=$3; }
	| STRVAR SUBEQ expr	{ (void)code3(varpush,(Inst)$1,subeq); $$=$3; }
	| STRVAR MULEQ expr	{ (void)code3(varpush,(Inst)$1,muleq); $$=$3; }
	| STRVAR DIVEQ expr	{ (void)code3(varpush,(Inst)$1,diveq); $$=$3; }
	| STRVAR MODEQ expr	{ (void)code3(varpush,(Inst)$1,modeq); $$=$3; }
	| ARG '=' expr   	{ defnonly("$"); (void)code2(argassign,(Inst)$1); $$=$3;}
	| ARG ADDEQ expr 	{ defnonly("$"); (void)code2(argaddeq,(Inst)$1); $$=$3;}
	| ARG SUBEQ expr 	{ defnonly("$"); (void)code2(argsubeq,(Inst)$1); $$=$3;}
	| ARG MULEQ expr 	{ defnonly("$"); (void)code2(argmuleq,(Inst)$1); $$=$3;}
	| ARG DIVEQ expr 	{ defnonly("$"); (void)code2(argdiveq,(Inst)$1); $$=$3;}
	| ARG MODEQ expr 	{ defnonly("$"); (void)code2(argmodeq,(Inst)$1); $$=$3;}
	;

strasgn:  STRVAR '=' strexpr		{(void)code3(varpush,(Inst)$1,str_assign); $$=$3; }
	| STRVAR CONSTEQ strexpr	{(void)code3(varpush,(Inst)$1,const_str_assign); $$=$3; }
	| STRARG '=' strexpr	   	{ defnonly("$"); (void)code2(argassign,(Inst)$1); $$=$3;}
	| VAR '=' strexpr		{(void)code3(varpush,(Inst)$1,str_assign); $$=$3; }
	| VAR CONSTEQ strexpr		{(void)code3(varpush,(Inst)$1,const_str_assign); $$=$3; }
	;

stmt:	  expr				{ (void)code(xpop); }
	| strexpr			{ (void)code(xpop); }
	| RETURN			{ defnonly("return"); (void)code(procret); }
	| RETURN expr			{ defnonly("return"); $$=$2; (void)code(funcret); }
	| PROCEDURE begin '(' arglist ')'	{ $$ = $2; (void)code3(call, (Inst)$1, (Inst)$4); }
d238 2
a239 2
	| PRINTF prlist			{ $$ = $2; }
	| PRINTLN prlist		{ $$ = $2; (void)code(prnl); }
d257 1
a257 1
cond:	   expr 			{ (void)code(STOP); }
d261 1
a261 1
for:	  FOR				{ $$ = code(forcode); (void)code4(STOP,STOP,STOP,STOP); }
d263 1
a263 1
if:	  IF				{ $$ = code(ifcode); (void)code3(STOP,STOP,STOP); }
d267 1
a267 1
end:	  /* nothing */			{ (void)code(STOP); $$ = progp; }
d322 3
a324 3
	| HEXFP '(' expr ')'			{ (void)code(hexfp); }
	| HEXINT '(' expr ')'			{ (void)code(hexint); }
	| NUMTOSTR '(' expr ')'			{ (void)code(numtostr); }
d326 6
a331 6
	| STRBLTIN0 '(' ')'			{ (void)code2(strbltin0, (Inst)$1->u.ptr0); }
	| STRBLTIN1 '(' strexpr ')'		{ $$ = $3; (void)code2(strbltin1, (Inst)$1->u.ptr1); }
	| STRBLTIN2 '(' strexpr ',' strexpr ')'	{ $$ = $3; (void)code2(strbltin2, (Inst)$1->u.ptr2); }
	| STRFTIME '(' strexpr ',' expr ')'	{ (void)code(str_strftime); $$ = $3; }
	| STRTOSYMSTR '(' strexpr ')'		{ (void)code(str_to_symstr); $$ = $3; }
	| SUBSTR '(' strexpr ',' expr ',' expr ')'	{ (void)code(str_substr); $$ = $3; }
d335 6
a340 6
	| expr NUMBER				{ (void)code3(constpush, (Inst)$2, str_concat_nn); }
	| expr VAR				{ (void)code3(constpush, (Inst)$2, str_concat_nn); }
	| expr string				{ (void)code(str_concat_ns); }
	| strexpr NUMBER			{ (void)code3(constpush, (Inst)$2, str_concat_sn); }
	| strexpr VAR				{ (void)code3(constpush, (Inst)$2, str_concat_sn); }
	| strexpr string			{ (void)code(str_concat_ss); }
d347 1
a347 1
	| FUNCTION begin '(' arglist ')'	{ $$ = $2; (void)code3(call,(Inst)$1,(Inst)$4); }
d354 8
a361 8
	| HEX '(' expr ')'			{ (void)code(hex); }
	| BLTIN0 '(' ')'              		{ (void)code2(bltin0, (Inst)$1->u.ptr0); }
	| BLTIN1 '(' expr ')'         		{ $$ = $3; (void)code2(bltin1, (Inst)$1->u.ptr1); }
	| BLTIN2 '(' expr ',' expr ')'		{ $$ = $3; (void)code2(bltin2, (Inst)$1->u.ptr2); }
	| INDEX '(' strexpr ',' strexpr ')'	{ (void)code(str_index); $$ = $5; }
	| LENGTH '(' strexpr ')'		{ (void)code(str_length); $$ = $3; }
	| STRTOSYMNUM '(' strexpr ')'		{ (void)code(str_to_symnum); $$ = $3; }
	| STRTONUM '(' strexpr ')'		{ (void)code(str_to_num); $$ = $3; }
d363 18
a380 18
	| expr '+' expr				{ (void)code(add); }
	| expr '-' expr				{ (void)code(sub); }
	| expr '*' expr				{ (void)code(mul); }
	| expr '/' expr				{ (void)code(divop); }	/* ansi has a div fcn! */
	| expr '%' expr				{ (void)code(mod); }
	| expr '^' expr				{ (void)code(power); }
	| '-' expr   %prec UNARYMINUS  		{ $$=$2; (void)code(negate); }
	| '+' expr   %prec UNARYMINUS  		{ $$=$2; (void)code(noop); }
	| expr GT expr				{ (void)code(gt); }
	| expr GE expr				{ (void)code(ge); }
	| expr LT expr				{ (void)code(lt); }
	| expr LTGT expr			{ (void)code(ltgt); }
	| expr LE expr				{ (void)code(le); }
	| expr EQ expr				{ (void)code(eq); }
	| expr NE expr				{ (void)code(ne); }
	| expr AND expr				{ (void)code(And); }
	| expr OR expr				{ (void)code(Or); }
	| NOT expr				{ $$ = $2; (void)code(Not); }
d385 17
a401 12
	| string GT string			{ (void)code(str_gt); }
	| string GE string			{ (void)code(str_ge); }
	| string LT string			{ (void)code(str_lt); }
	| string LE string			{ (void)code(str_le); }
	| string EQ string			{ (void)code(str_eq); }
	| string NE string			{ (void)code(str_ne); }
	;

prlist:	  expr					{ (void)code(prexpr); }
	| strexpr				{ (void)code(prstr); }
	| prlist ',' expr			{ (void)code(prexpr); }
	| prlist ',' strexpr			{ (void)code(prstr); }
d405 1
a405 1
	    '(' ')' stmt			{ (void)code(procret); define($2); indef=0; }
d407 1
a407 1
	    '(' ')' stmt			{ (void)code(procret); define($2); indef=0; }
d1296 6
d1490 6
d1712 1
d1899 1
d1903 1
a1903 1
	case '*':	return follow('=', MULEQ, '*');
@


1.12
log
@Add support for subnormals on SGI IRIX 6.x.

Add comment at call to fscanf() to show that no changes are
needed for quadruple precision.
@
text
@d1198 228
d1600 1
a1600 1
	(void)SNPRINTF4(temp, sizeof(temp), "__FILE__[%02d]", infile_count);
@


1.11
log
@Change sprintf() references to SNPRINTFn().
@
text
@d994 14
d1100 13
d1286 1
d1589 1
a1589 1
		(void)fscanf(fin, "%lf", &d);
@


1.10
log
@Correct typo: SYSHOCHLP -> SYSHOCDIR.
Enlarge max_prog to 8MB.
Call sanity_check() after initializations in main().
@
text
@d1344 1
a1344 1
	(void)sprintf(temp,"__FILE__[%02d]", infile_count);
@


1.9
log
@Add missing ARGS() wrappers on two function prototypes.  Add LTGT
token for new <> binary operator, and corresponding grammar rules.
@
text
@d80 1
a80 1
#define SYSHOCHLP	"/usr/local/share/lib/hoc/hoc-" PACKAGE_VERSION "/"
d1249 1
d1251 3
d1264 1
@


1.8
log
@Add missing typecast on call to Putenv().
@
text
@d50 1
d128 2
a129 2
extern FILE *		Fopen(const char *, const char *, const char **);
extern FILE *		Freopen(const char *, const char *, FILE*, const char **);
d179 1
a179 1
%left	GT GE LT LE EQ NE
d371 1
d420 3
a422 1
void yyerror ARGS((YYCONST char *));	/* various C++ variants of yacc-generated code happy */
d571 1
a571 1
			s = install_number("__LINENO__", 0.0);
d582 1
a582 1
		s = install_number("__LINENO__", 0.0);
d585 1
a585 1
	s->u.val += 1.0;
d647 1
a647 1
			(void)update_number(t,1.0);	/* -Dname means -Dname=1 */
d715 1
a715 1
			double d;
d1064 1
a1064 1
		verbose_mode = (s->u.val != 0.0);
d1091 8
a1098 8
	(void)update_const_number("__MAX_FRAME__", 0.0);
	(void)update_const_number("__MAX_LINE__", 0.0);
	(void)update_const_number("__MAX_NAME__", 0.0);
	(void)update_const_number("__MAX_PROG__", 0.0);
	(void)update_const_number("__MAX_PUSHBACK__",0.0);
	(void)update_const_number("__MAX_STACK__", 0.0);
	(void)update_const_number("__MAX_STRING__", 0.0);
	(void)update_const_number("__MAX_TOKEN__", 0.0);
d1166 1
a1166 1
	(void)install_const_number("__IEEE_754__", 1.0);
d1168 1
a1168 1
	(void)install_const_number("__IEEE_754__", 0.0);
d1194 1
a1194 1
		(void)install_const_string("__SYSHOCPATH__",	
d1198 1
a1198 1
							elementsep, 
d1212 1
a1212 1
	(void)update_const_number("__GID__", 0.0);
d1218 1
a1218 1
	(void)update_const_number("__PID__", 0.0);
d1224 1
a1224 1
	(void)update_const_number("__UID__", 0.0);
d1496 1
a1496 1
		s = install(sbuf, UNDEF, 0.0);
d1624 8
a1631 1
	case '<':	return follow('=', LE, LT);
@


1.7
log
@Add more code to deal with vagaries of how yyerror() is
defined by various yacc implementations.

Change file global c to the_c, since single-letter globals
are always a bad idea.

Add prototypes for new functions Fopen() and Freopen() which
provide default extensions if the first open attempt fails,
so users can omit the .hoc extension.

Add new grammar tokens STRTOSYMNUM and STRTOSYMSTR, and associated
rules.

Add new cd_pwd_enabled and file_trace_enabled flags and associated
option support.

Use \007 instead of \a in transtab[] so that it works properly
for old K&R C too.

Change handling of __LINENO__ to match changes needed for the
io.c:Load() function.

Add support for command-line -D and -U options.

Add support for --secure option.

Use __FILE__'s value in the symbol table, instead of a shadowing
global variable, current_filename; this changes is needed to
support the io.c:Load() function changes.

Add new init_limits() function, and move code into it from
elsewhere.

Add HOCPATH support, and define new __SYSHOCPATH__ symbol table entry.

Add support for __GID__, __PID__, and __UID__, with fallbacks to
zero values when the O/S support for them is lacking.

Add code to grow arrays dynamically.
@
text
@d1203 1
a1203 1
		Putenv(HOCPATH, concat2(".", elementsep));
@


1.6
log
@Add new token DELETE and grammar rules to recognize it.

Add missing casts on several update_number() and update_string() calls.

Replace body of do_undefine() with call to new delete_symbol()
function from symbol.c, which also supports the new delete() function.

Make small tweaks in string expression concatenation rules.
@
text
@a36 6
#if defined(_AIX)
#define yyerror_const 			/* workaround for bugs in AIX yacc output */
#else
#define yyerror_const const
#endif

a41 1
extern "C" void yyerror ARGS((yyerror_const char* s));
d47 5
a51 1
void yyerror ARGS((yyerror_const char* s));
d112 2
d115 1
a115 1
const char *		current_filename;	/* needed in string.c */
d117 9
d127 2
a128 10
static int	c = '\n';		/* global for use by warning() */
static int	infile_count = 0;
static const char *syshocdir = SYSHOCDIR;
static const char *syshochlp = SYSHOCHLP;
static const char *syshochlpbase = SYSHOCHLPBASE;
static const char *syshocrc = SYSHOCRC;
static const char *syshocrcbase = SYSHOCRCBASE;
static const char *syshocxlt = SYSHOCXLT;
static const char *syshocxltbase = SYSHOCXLTBASE;
static const char *hocrc = HOCRC;
d130 1
a130 1
int			main ARGS((int, char*[]));
d143 2
a144 2
static void             do_post_args ARGS((int *, char*[]));
static void             do_pre_args ARGS((const int *, const char*[]));
d168 2
a169 2
%token	<sym>	STRBLTIN2 STRVAR STRFTIME STRTONUM SUBSTR
%token	<narg>	ARG
d223 1
d286 2
d315 1
d326 1
d356 1
d414 6
d435 7
a441 4
int load_enabled = 1;			/* reset by --no-load command-line option */
int logfile_enabled = 1;		/* reset by --no-logfile command-line option */
int save_enabled = 1;			/* reset by --no-save command-line option */
int use_readline = 1;			/* reset by --no-readline  command-line option */
d487 1
a487 1
		(const char*)NULL,
d496 1
a496 1
	static char transtab[] = "a\ab\bf\fn\nr\rt\tv\v"; /* Standard C escapes */
d503 3
a505 1
	if (islower(c) && (strchr(transtab, c) != (char*)NULL))
d556 3
d567 1
a567 1
			s = install_const_number("__LINENO__", 0.0);
d573 11
d616 1
a616 1
		(const char*)NULL,
d632 1
d636 1
a636 1
	t = (char*)dupstr(s);
d639 7
a645 2
		(void)update_number(t,1.0);	/* -Dname means -Dname=1 */
	else					/* have -Dname=something */
d648 11
a659 1
		*equals = '\0';
d667 1
a667 1
			if (q == (const char*)NULL)
d671 2
d674 6
a679 2
				/* TO DO: expand backslash escape sequences in value */
				(void)update_string(t,value);
d692 6
a697 1
				(void)update_number(t, sp->u.val);
d699 6
a704 1
				(void)update_string(t, sp->u.str);
d715 6
a720 1
				(void)update_number(t, d);
d725 1
a725 1
	efree((void*)t);
d763 2
a764 2
		const char* userhocrc;
		const char* home;
d767 1
a767 1
		if (home == (const char*)NULL)
d771 1
a771 1
		efree((void*)userhocrc);
d779 2
d783 1
a783 1
	if ((filename != (const char*)NULL) && (access(filename, R_OK) == 0))
d785 1
a785 1
		fin = fopen(filename, "r");
d794 1
a794 1
			set_filename(filename);
a801 1

d803 1
a803 1
do_post_args(int *pargc, char* argv[])
d844 2
d872 9
a880 1
			else if (ARGMATCH(p,"silent",1))
d896 1
a896 1
	argv[*pargc] = (char*)NULL;	/* ANSI C89 Section 2.1.2.2.1: ``argv[argc] shall be a NULL pointer'' */
d907 1
a907 1
do_pre_args(const int *pargc, const char* argv[])
d912 1
a912 1
	current_filename = dupstr("command-line"); /* in case error() is called */
d955 1
a955 1
			else if (ARGMATCH(p,"silent",1))
d983 1
a983 1
execerror(const char* s, const char* t)	/* recover from run-time error */
d1004 1
a1004 1
	execerror("floating point exception", (const char*)NULL);
d1016 2
a1017 2
	if (locale == (const char*)NULL)
		return ((const char*)NULL);
d1033 1
a1033 1
	if (locale_name == (const char*)NULL)
d1035 1
a1035 1
	if (locale_name == (const char*)NULL)
d1040 1
a1040 1
const char*
d1073 1
a1073 1
		(const char*)NULL,
d1082 16
d1101 9
a1109 1
	lineno = 0;
d1129 1
a1129 1
	if (locale_name != (const char*)NULL)
a1153 1

d1184 39
a1224 1

d1228 1
a1228 1
	execerror("interrupt", (const char*)NULL);
d1232 1
a1232 1
main(int argc, char* argv[])	/* hoc7 */
d1236 2
d1242 8
d1256 1
a1256 1
	do_pre_args(&argc,(const char**)argv);
d1261 1
a1261 1
		static char *stdinonly[] = { stdhyphen, (char*)NULL };
d1279 2
d1289 1
a1289 1
	if (infile == (const char*)NULL) /* skip over holes from command-line options */
d1293 1
a1293 1
		infile = (const char*)NULL;
d1296 1
a1296 1
	} else if ((fin=freopen(infile, "r", stdin)) == (FILE*)NULL) {
d1298 1
a1298 1
	} else if ((fin=fopen(infile, "r")) == (FILE*)NULL) {
d1301 1
d1304 2
a1305 1
	set_filename((infile == (const char*)NULL) ? "/dev/stdin" : infile);
d1340 3
d1344 4
a1349 3
	if (current_filename != (const char*)NULL)
		efree((void*)current_filename);
	current_filename = dupstr(filename);
d1358 1
a1358 1
	for (k = 0; text[k] != (const char*)NULL; ++k)
d1373 4
a1376 3
		"\t\t[ --no-help-file ] [ --no-load ] [ --no-logfile ]\n",
		"\t\t[ --no-readline ] [ --no-save ] [ --no-site-file ]\n",
		"\t\t[ --no-translation-file ] [ --no-user-file ] [ --quick ]\n",
d1380 1
a1380 1
		(const char*)NULL,
d1403 1
a1403 1
		(const char*)NULL,
d1412 1
d1425 2
d1428 1
a1428 1
	if (t != (const char*)NULL)
d1435 1
a1435 1
		if (t != (const char*)NULL)
d1440 1
a1440 1
	fprintf(stderr, "%s: %s", progname, s);
d1442 1
a1442 1
		fprintf(stderr, " %s", t);
d1444 2
a1445 2
		fprintf(stderr, " in %s", infile);
	fprintf(stderr, " near line %d\n", lineno);
d1448 2
a1449 2
	while (c != '\n' && c != EOF)
		if((c = getc(fin), c) == '\n')	/* flush rest of input line */
d1451 1
a1451 1
		else if (c == EOF && errno == EINTR) {
d1459 1
a1459 1
yyerror(yyerror_const char* s)	/* report compile-time error */
d1472 6
a1477 2
	char sbuf[MAX_NAME+1];
	char *p = sbuf;
d1479 2
a1480 1
	c = getc(fin);
d1482 4
a1485 3
		if (p >= sbuf + sizeof(sbuf) - 1) {
			*p = '\0';
			execerror("name too long", sbuf);
d1487 4
a1490 4
		*p++ = c;
	} while ((c=getc(fin)) != EOF && IsIdMiddle(c));
	(void)ungetc(c, fin);
	*p = '\0';
a1500 1

d1504 2
a1505 2
	char *p;
	static char sbuf[MAX_STRING+1];
d1507 4
d1512 2
a1513 1
	for (p = sbuf; (the_c=getc(fin)) != QUOTATION_MARK; p++) {
d1516 4
a1519 3
		if (p >= sbuf + sizeof(sbuf) - 1) {
			*p = '\0';
			execerror("string too long", sbuf);
d1521 1
a1521 1
		*p = backslash(the_c);
d1523 1
a1523 1
	*p = '\0';
d1525 1
a1525 1
	return((const char*)&sbuf[0]);
d1531 1
a1531 1
	while ((c=getc(fin)) == ' ' || c == '\t')
d1533 1
a1533 1
	if (c == EOF)
d1535 3
a1537 3
	if (c == '\\') {
		c = getc(fin);
		if (c == '\n') {
d1542 2
a1543 2
	if (c == '#') {		/* comment */
		while ((c=getc(fin)) != '\n' && c != EOF)
d1545 1
a1545 1
		if (c == '\n')
d1547 1
a1547 1
		return c;
d1549 1
a1549 1
	if (c == '.' || isdigit(c)) {	/* number */
d1551 1
a1551 1
		(void)ungetc(c, fin);
d1559 1
a1559 1
	if (IsIdStart(c)) {
d1561 1
a1561 1
		(void)ungetc(c,fin);
d1565 1
a1565 1
	if (c == '$') {	/* argument? */
d1567 12
a1578 3
		while (isdigit(c=getc(fin)))
			n = 10 * n + c - '0';
		(void)ungetc(c, fin);
d1583 1
a1583 1
		(void)fprintf(stderr,"yylex() -> ARG [%d]\n", n);
d1585 1
a1585 1
		return ARG;
d1587 1
a1587 1
	if (c == QUOTATION_MARK) {	/* quoted string */
d1593 1
a1593 1
		strcpy((char*)yylval.sym, sbuf);
d1598 1
a1598 1
		yylval.sym->name = (const char*)NULL;
d1612 1
a1612 1
	switch (c) {
d1626 1
a1626 1
	default:	return c;
@


1.5
log
@Update grammar with new defined() function, new nonterminals `keyword'
and `othername', and new internal support functions do_define(),
do_undefine(), and error(), all needed for support of that new
function.

Recognize new -D and -U options in do_pre_args() and do_post_args(),
and update usage_and_die() output to reflect those new options.

Define current_filename to "command-line" during command-line option
parsing, because it is now needed if error() is called to report a bad
argument.

Add new function init_symbols(), and move symbol initialization code
out of do_pre_args() into that new function.

Make first pass at improving the string expression grammar.  The
reduce-reduce conflicts from expression concatenation have been
resolved, but more work remains to generalize the grammar, which is
now too restrictive.

Install the SYS* and HOC* settings as __SYSxxx__ and __HOCxxx__
predefined immutable constant strings.  They are needed to support
dynamic language switching in hoc code, since installed system files
have to be reloaded to accomplish that.

Indent braced actions in grammar rules to improve readability.

Add QUOTATION_MARK symbol for '"', to avoid confusing tools like
tgrind(1).
@
text
@d166 3
a168 3
%token	<sym>	ABORT BLTIN0 BLTIN1 BLTIN2 DEFINED HEX HEXFP HEXINT INDEX
%token	<sym>	LENGTH NUMTOSTR PRINTF PRINTLN STRBLTIN0 STRBLTIN1 STRBLTIN2
%token	<sym>	STRVAR STRFTIME STRTONUM SUBSTR
d279 1
d326 5
a331 3
	| strexpr NUMBER			{ (void)code(str_concat_sn); }
	| expr NUMBER				{ (void)code(str_concat_nn); }
	| expr string				{ (void)code(str_concat_ns); }
d343 2
d607 2
a608 2
		update_number(t,1.0);	/* -Dname means -Dname=1 */
	else				/* have -Dname=something */
d626 1
a626 1
				update_string(t,value);
d639 1
a639 1
				update_number(t, sp->u.val);
d641 1
a641 1
				update_string(t, sp->u.str);
d652 1
a652 1
				update_number(t, d);
d892 2
a893 16
	Symbol *sp;

	sp = lookup(s);
	if (sp != (Symbol*)NULL)
	{
		/* TO DO: should we allow deletion of function/procedure names? */
		if ((sp->type == VAR) || (sp->type == STRVAR))
		{
			if (sp->immutable)
				error("illegal attempt to delete immutable constant", s);
			else
				delete_symbol(sp);
		}
		else if (sp->type != UNDEF)
			error("illegal attempt to undefine nonvariable", s);
	}
@


1.4
log
@Major update for better portability, support of bison and byacc
as well as yacc, support for string expressions, support of new
functions, and support for dynamic string translations.
@
text
@d113 2
d139 3
a142 1
static void		do_one_init_file ARGS((const char *filename));
d145 1
a156 1
static void             warning ARGS((const char *, const char *));
d166 2
a167 2
%token	<sym>	ABORT BLTIN0 BLTIN1 BLTIN2 HEX HEXFP HEXINT INDEX LENGTH
%token	<sym>	NUMTOSTR PRINTF PRINTLN STRBLTIN0 STRBLTIN1 STRBLTIN2
d173 1
a173 1
%type	<sym>	procname
d213 6
a218 6
	| ARG '=' expr   { defnonly("$"); (void)code2(argassign,(Inst)$1); $$=$3;}
	| ARG ADDEQ expr { defnonly("$"); (void)code2(argaddeq,(Inst)$1); $$=$3;}
	| ARG SUBEQ expr { defnonly("$"); (void)code2(argsubeq,(Inst)$1); $$=$3;}
	| ARG MULEQ expr { defnonly("$"); (void)code2(argmuleq,(Inst)$1); $$=$3;}
	| ARG DIVEQ expr { defnonly("$"); (void)code2(argdiveq,(Inst)$1); $$=$3;}
	| ARG MODEQ expr { defnonly("$"); (void)code2(argmodeq,(Inst)$1); $$=$3;}
d227 8
a234 10
stmt:	  expr	{ (void)code(xpop); }
	| strexpr	{ (void)code(xpop); }
	| RETURN { defnonly("return"); (void)code(procret); }
	| RETURN expr
	        { defnonly("return"); $$=$2; (void)code(funcret); }
	| PROCEDURE begin '(' arglist ')'
		{ $$ = $2; (void)code3(call, (Inst)$1, (Inst)$4); }
	| PRINT prlist	{ $$ = $2; }
	| PRINTF prlist	{ $$ = $2; }
	| PRINTLN prlist { $$ = $2; (void)code(prnl); }
d250 1
a250 1
	| '{' stmtlist '}'	{ $$ = $2; }
d252 1
a252 1
cond:	   expr 	{ (void)code(STOP); }
d254 1
a254 1
while:	  WHILE	{ $$ = code3(whilecode,STOP,STOP); }
d256 1
a256 1
for:	  FOR	{ $$ = code(forcode); (void)code4(STOP,STOP,STOP,STOP); }
d258 1
a258 1
if:	  IF	{ $$ = code(ifcode); (void)code3(STOP,STOP,STOP); }
d260 29
a288 1
begin:	  /* nothing */		{ $$ = progp; }
d290 12
a301 1
end:	  /* nothing */		{ (void)code(STOP); $$ = progp; }
d303 2
a304 1
stmtlist: /* nothing */		{ $$ = progp; }
d309 2
a310 2
string:   STRING					{ $$ = code2(const_str_push, (Inst)$1); }
	| STRVAR					{ $$ = code3(varpush, (Inst)$1, streval); }
d312 9
a320 9
	| '(' strexpr ')'				{ $$ = $2; }
	| HEXFP '(' expr ')'				{ (void)code(hexfp); }
	| HEXINT '(' expr ')'				{ (void)code(hexint); }
	| NUMTOSTR '(' expr ')'				{ (void)code(numtostr); }
	| READ '(' STRVAR ')'				{ $$ = code2(varread, (Inst)$3); }
	| STRBLTIN0 '(' ')'				{ (void)code2(strbltin0, (Inst)$1->u.ptr0); }
	| STRBLTIN1 '(' strexpr ')'			{ $$ = $3; (void)code2(strbltin1, (Inst)$1->u.ptr1); }
	| STRBLTIN2 '(' strexpr ',' strexpr ')'		{ $$ = $3; (void)code2(strbltin2, (Inst)$1->u.ptr2); }
	| STRFTIME '(' strexpr ',' expr ')'		{ (void)code(str_strftime); $$ = $3; }
d325 4
a328 8
	| strexpr string				{ (void)code(str_concat_ss); }
	| strexpr expr					{ (void)code(str_concat_sn); }

	/* Produces 90 reduce/reduce conflicts:
	| expr expr					{ (void)code(str_concat_nn); }
	 */

	| expr string					{ (void)code(str_concat_ns); }
d331 3
a333 3
expr:	  NUMBER { $$ = code2(constpush, (Inst)$1); }
	| VAR	 { $$ = code3(varpush, (Inst)$1, eval); }
	| ARG	 { defnonly("$"); $$ = code2(arg, (Inst)$1); }
d335 9
a343 8
	| FUNCTION begin '(' arglist ')'
		{ $$ = $2; (void)code3(call,(Inst)$1,(Inst)$4); }
	| READ '(' VAR ')' { $$ = code2(varread, (Inst)$3); }
	| ABORT '(' STRING ')' { $$ = code2(abort_user, (Inst)$3); }
	| HEX '(' expr ')' { (void)code(hex); }
	| BLTIN0 '(' ')'               { (void)code2(bltin0, (Inst)$1->u.ptr0); }
	| BLTIN1 '(' expr ')'          { $$ = $3; (void)code2(bltin1, (Inst)$1->u.ptr1); }
	| BLTIN2 '(' expr ',' expr ')' { $$ = $3; (void)code2(bltin2, (Inst)$1->u.ptr2); }
d347 28
a374 38
	| '(' expr ')'	{ $$ = $2; }
	| expr '+' expr	{ (void)code(add); }
	| expr '-' expr	{ (void)code(sub); }
	| expr '*' expr	{ (void)code(mul); }
	| expr '/' expr	{ (void)code(divop); }	/* ansi has a div fcn! */
	| expr '%' expr	{ (void)code(mod); }
	| expr '^' expr	{ (void)code(power); }
	| '-' expr   %prec UNARYMINUS   { $$=$2; (void)code(negate); }
	| '+' expr   %prec UNARYMINUS   { $$=$2; (void)code(noop); }
	| expr GT expr	{ (void)code(gt); }
	| expr GE expr	{ (void)code(ge); }
	| expr LT expr	{ (void)code(lt); }
	| expr LE expr	{ (void)code(le); }
	| expr EQ expr	{ (void)code(eq); }
	| expr NE expr	{ (void)code(ne); }
	| expr AND expr	{ (void)code(And); }
	| expr OR expr	{ (void)code(Or); }
	| NOT expr	{ $$ = $2; (void)code(Not); }
	| INC VAR	{ $$ = code2(preinc,(Inst)$2); }
	| DEC VAR	{ $$ = code2(predec,(Inst)$2); }
	| VAR INC	{ $$ = code2(postinc,(Inst)$1); }
	| VAR DEC	{ $$ = code2(postdec,(Inst)$1); }
	| string GT string	{ (void)code(str_gt); }
	| string GE string	{ (void)code(str_ge); }
	| string LT string	{ (void)code(str_lt); }
	| string LE string	{ (void)code(str_le); }
	| string EQ string	{ (void)code(str_eq); }
	| string NE string	{ (void)code(str_ne); }
	;
prlist:	  expr			{ (void)code(prexpr); }
	| strexpr		{ (void)code(prstr); }
	| prlist ',' expr	{ (void)code(prexpr); }
	| prlist ',' strexpr	{ (void)code(prstr); }
	;
defn:	  FUNC procname { $2->type=FUNCTION; indef=1; }
	    '(' ')' stmt { (void)code(procret); define($2); indef=0; }
	| PROC procname { $2->type=PROCEDURE; indef=1; }
	    '(' ')' stmt { (void)code(procret); define($2); indef=0; }
d376 13
d393 6
a398 5
arglist:  /* nothing */ 	{ $$ = 0; }
	| expr			{ $$ = 1; }
	| strexpr		{ $$ = 1; }
	| arglist ',' expr	{ $$ = $1 + 1; }
	| arglist ',' strexpr	{ $$ = $1 + 1; }
d594 62
d753 4
d828 2
a834 16
	(void)update_number("__BANNER__", (fp_t)print_banner); /* so -no-banner setting is available to user code */
	(void)update_number("__READLINE__", (fp_t)use_readline); /* so -no-readline setting is available to user code */
	(void)update_number("__VERBOSE__",(fp_t)verbose_mode); /* so -silent setting is available to user code */

#if defined(HAVE_IEEE_754)
	(void)install_const_number("__IEEE_754__", 1.0);
#else
	(void)install_const_number("__IEEE_754__", 0.0);
#endif

	(void)install_const_string("__PACKAGE_BUGREPORT__",	PACKAGE_BUGREPORT);
	(void)install_const_string("__PACKAGE_DATE__",		PACKAGE_DATE);
	(void)install_const_string("__PACKAGE_NAME__",		PACKAGE_NAME);
	(void)install_const_string("__PACKAGE_STRING__",	PACKAGE_STRING);
	(void)install_const_string("__PACKAGE_VERSION__",	PACKAGE_VERSION);

d876 23
d900 2
d905 7
d1014 1
d1061 33
d1114 1
d1221 3
a1223 1
		"\t[ --author ] [ --? ] [ --copyright] [ --help ] [ --no-banner ]\n",
d1227 1
a1227 1
		"\t\t[ --silent ] [ --version ]\n",
d1259 1
a1259 1
static void
d1350 1
a1350 1
	for (p = sbuf; (the_c=getc(fin)) != '"'; p++) {
d1414 1
a1414 1
	if (c == '"') {	/* quoted string */
@


1.3
log
@New features:

	** The grammar has been extended to support string constants,
	   variables, and expressions, the new abort(), printf(),
	   __hex() [temporary], and who() built-in functions, and a new
	   assignment operator, :=, used to create immutable named
	   constants.  abort() allows hoc programs to cause immediate
	   return to the top level hoc evaluator, just like built-in
	   functions can.  This is necessary if kernel code candidates
	   are to be prototyped in hoc first.

	** Hide lineno access in new functions bump_lineno() and
	   init_lineno(), since the current value is now available in
	   the __LINENO__ variable to hoc programs.

	** Add GNU readline support.

	** Add support for system-wide and user-specific initialization
	   files, including internationalized ones.

	** Add support for several command-line options.  Argument
	   processing is now in a separate function, do_args(), instead
	   of in-line in main().

	** Add support for several new predefined named constants and
	   variables: __DATE__, __FILE__, __IEEE_754__, __LINENO__,
	   __PACKAGE_BUGREPORT__, __PACKAGE_DATE__, __PACKAGE_NAME__,
	   __PACKAGE_STRING__, __PACKAGE_VERSION__, __PROMPT__,
	   __TIME__, and __VERBOSE__.

	** Change warning messages into the GNU and UNIX standard form
	   file:lineno:message, for user familiarity, and convenience
	   with text editors that know how to parse such messages and
	   jump to that location in the file.

	** Create a Symbol for quoted character strings, instead of the
	   old ugly hack of masquerading a string pointer on top of a
	   Symbol pointer.

	** Add support for Standard C/C++ escape sequences in character
	   strings, plus \E (for escape: handy in creating new
	   __PROMPT__ strings).

	** Use new dupstr() function for string allocation, instead of
	   explicit calls to emalloc() and strcpy().

	** Protect header file inclusion with feature-test conditionals.

	** Provide extended isalpha() and isalnum() to support
	   internationalization of hoc source code.

	** Make array dimensions changeable at compile time, and
	   increase them, since we now handle considerably larger hoc
	   programs since the old PDP-11 days.

	** Add definitions of the names and locations of startup files
	   (HOCRC, SYSHOCDIR, SYSHOCRCBASE, SYSHOCHLPBASE).
@
text
@d4 13
a20 7
#if 1
#undef isalnum
#define isalnum(c) (((isalnum)(c)) || ((160 <= (c)) && ((c) <= 256)))
#undef isalpha
#define isalpha(c) (((isalpha)(c)) || ((160 <= (c)) && ((c) <= 256)))
#endif

d37 6
d44 11
a54 2
extern "C" void fpecatch(int dummy);
extern "C" void intcatch(int dummy);
a72 18
#if !defined(MAX_NAME)
#define MAX_NAME 1024
#endif

#if (MAX_NAME + 0) < 8			/* avoid silly small values */
#undef MAX_NAME
#define MAX_NAME 8
#endif

#if !defined(MAX_STRING)
#define MAX_STRING 32767
#endif

#if (MAX_STRING + 0) < 1024		/* avoid silly small values */
#undef MAX_STRING
#define MAX_STRING	1024
#endif

a84 4
#if !defined(SYSHOCRCBASE)
#define SYSHOCRCBASE	"hoc.rc"
#endif

d93 4
d101 11
a111 2
#define	code2(c1,c2)	code(c1); (void)code(c2)
#define	code3(c1,c2,c3)	code(c1); (void)code(c2); (void)code(c3)
d113 2
a114 3
static void	defnonly(const char *);
static void	warning(const char *s, const char *t);
void		yyerror(const char* s);		/* keep IBM AIX compilers happy */
d116 2
a117 1
int		indef;			/* needed in code.c too */
d124 2
d127 27
a153 1
static const char *current_filename;
d162 3
a164 1
%token	<sym>	ABORT BLTIN0 BLTIN1 BLTIN2 HEX PRINTF PRINTLN STRVAR WHO
d168 1
a168 1
%type	<inst>	strasgn strexpr
d181 12
a192 8
	| list '\n'
	| list defn '\n'
	| list asgn '\n'  { (void)code2(xpop, STOP); return 1; }
	| list strasgn '\n'  { (void)code2(xpop, STOP); return 1; }
	| list stmt '\n'  { (void)code(STOP); return 1; }
	| list expr '\n'  { (void)code2(printtop, STOP); return 1; }
	| list strexpr '\n'  { (void)code2(printtopstring, STOP); return 1; }
	| list error '\n' { yyerrok; }
d194 2
a195 1
asgn:	  VAR '=' expr { (void)code3(varpush,(Inst)$1,assign); $$=$3; }
d202 7
d218 1
a219 1
	| STRVAR CONSTEQ strexpr	{(void)code3(varpush,(Inst)$1,const_str_assign); $$=$3; }
d224 1
d232 1
a232 2
	| PRINTLN prlist { $$ = $2; }
	| WHO '(' ')'	{ (void)code(who); }
d254 1
a254 1
for:	  FOR	{ $$ = code(forcode); (void)code3(STOP,STOP,STOP); (void)code(STOP); }
d263 1
a263 1
	| stmtlist '\n'
d267 24
a290 3
strexpr: STRING	{ $$ = code2(const_str_push, (Inst)$1); }
	| STRVAR { $$ = code3(varpush, (Inst)$1, streval); }
	| strexpr strexpr { $$ = code(str_concat); }
a296 1
	| strasgn
d305 3
d330 6
d353 1
d355 1
d360 9
d374 6
d382 1
d384 1
a384 1
static int verbose_mode = 1;		/* reset by --silent command-line option */
d391 1
a391 1
static const char	*progname;
d393 1
a393 1
FILE			*fin;		/* input file pointer (also used in code.c) */
d396 1
a396 1
bump_lineno(void)
d398 1
a398 3
	static double * pdlineno = (double*)NULL;

	if (pdlineno == (double*)NULL)
d400 1
a400 25
		Symbol *s;

		s = lookup("__LINENO__");
		if (s == (Symbol*)NULL)
			s = install_const_number("__LINENO__", 0.0);
		s->immutable = 1;	/* to prevent user code assignments */
		pdlineno = &s->u.val;
	}
	lineno++;
	*pdlineno = (double)lineno;	/* update __LINENO__ value in symbol table */
}

static void
init_lineno(void)
{
	lineno = 0;
	bump_lineno();
}

#if defined(HAVE_GNU_READLINE)
/* NB: This simple interface to GNU readline assumes that fscanf(),
   getc(), and ungetc() only access a single file!  Apart from the
   macros and functions defined inside this conditional, NO other
   changes to the hoc code below are required.  There is a similar,
   but shorter conditional in code.c. */
d402 1
a402 3
#if defined(HAVE_READLINE_READLINE_H)
#include <readline/readline.h>
#endif
d404 1
a404 3
#if defined(HAVE_READLINE_HISTORY_H)
#include <readline/history.h>
#endif
d406 6
a411 2
static int rl_fd_stdin;			/* dup()'ed file descriptor of original stdin */
static int rl_ndigits;			/* number of digits seen in rl_token[] */
d413 3
a415 3
#define MAX_TOKEN 512
static char rl_token[MAX_TOKEN + 1];	/* +1 for trailing NUL */
static int rl_ntoken = 0;		/* number of chars currently in rl_token[] */
d417 1
a417 3
#define MAX_PUSHBACK	512
int rl_pushback[MAX_PUSHBACK];		/* pushback buffer for rl_unget_char() */
int rl_pushpos = -1;			/* current index into rl_pushback[] */
d419 1
a419 3
static char *rl_current_line = (char *) NULL;
static char *rl_nextc = (char*)NULL;
extern int readline_echoing_p;
d421 2
a422 4
static const char*
get_prompt(void)
{
	Symbol *s;
d424 4
a427 28
	s = lookup("__PROMPT__");
	if (s == (Symbol*)NULL)
		s = install_string("__PROMPT__", (PACKAGE_NAME "> "));
	return (s->u.str);
}

static char *
rl_gets (FILE *fpin)	/* I adapted this from the readline info docs: thanks, folks! */
{	/* Read a string, and return a pointer to it, or NULL on EOF. */
	/* If the buffer has already been allocated, return the memory
	   to the free pool. */

	if (rl_current_line)
	{
		free (rl_current_line);
		rl_current_line = (char *) NULL;
	}

	/* Get a line from the user, prompting if the input file is interactive */
	readline_echoing_p = isatty(fileno(fpin));
	rl_current_line = readline ((isatty(fileno(fpin)) && verbose_mode)
				    ? get_prompt() : (char*)NULL);

	/* If the line has any text in it, save it on the history. */
	if (rl_current_line && *rl_current_line)
		add_history (rl_current_line);

	return (rl_current_line);
d431 1
a431 1
rl_getchar(FILE * fpin)
d433 1
a433 272
	if (rl_pushpos >= 0)
		return (rl_pushback[rl_pushpos--]);

	if (rl_nextc == (char*)NULL)	/* time to refill input line buffer */
		rl_nextc = rl_gets(fpin);

	if (rl_nextc == (char*)NULL)	/* then no more input data */
		return (EOF);
	else if (*rl_nextc == '\0')	/* then end of line */
	{
		rl_nextc = (char*)NULL;	/* to force refill next time */
		return ((int)'\n');
	}
	else
		return (*rl_nextc++);
}

static void
rl_unget_char(int c)
{
	if (rl_pushpos >= (MAX_PUSHBACK - 1))
		execerror("too many input characters pushed back",
			  (const char *)NULL);
	rl_pushback[++rl_pushpos] = c;
}

static void
rl_add_to_token(int the_char)
{
	if (rl_ntoken >= (MAX_TOKEN-1))
		execerror("numeric token too long", rl_token);
	rl_token[rl_ntoken++] = (char)the_char;
	rl_token[rl_ntoken] = (char)'\0'; /* keep rl_token properly terminated */
}

static void
rl_scan_digits(FILE *fpin)
{					/* regexp: [0-9]* */
	int the_char;

	the_char = rl_getchar(fpin);
	while (isdigit(the_char))
	{
		rl_add_to_token(the_char);
		rl_ndigits++;
		the_char = rl_getchar(fpin);
	}
	rl_unget_char(the_char);
}

static void
rl_scan_dot(FILE *fpin)
{					/* regexp: [.]? */
	int the_char;

	the_char = rl_getchar(fpin);
	if (the_char == '.')
		rl_add_to_token(the_char);
	else
		rl_unget_char(the_char);
}

static void
rl_scan_sign(FILE *fpin)
{					/* regexp: [-+]* */
	int the_char;

	the_char = rl_getchar(fpin);
	while ((the_char == (int)'+') || (the_char == (int)'-'))
	{
		rl_add_to_token(the_char);
		the_char = rl_getchar(fpin);
	}
	rl_unget_char(the_char);
}

static void
rl_scan_exponent(FILE *fpin)
{					/* regexp: [Ee][-+]*[0-9]+ */
	int the_char;

	the_char = rl_getchar(fpin);
	if ((the_char == 'E') || (the_char == 'e'))
	{
		/* NB: We do not need to be precise here: strtod()
		will catch any error from missing exponent digits */
		rl_add_to_token(the_char);
		rl_scan_sign(fpin);
		rl_scan_digits(fpin);
	}
	else
		rl_unget_char(the_char);
}

static void
rl_scan_whitespace(FILE *fpin)
{					/* regexp: [ \t]* */
	int the_char;

	the_char = rl_getchar(fpin);
	while ((the_char == (int)' ') || (the_char == (int)'\t'))
		the_char = rl_getchar(fpin);
	rl_unget_char(the_char);
}

int
rl_fscanf(FILE *fpin,const char *format,void *pdata)
{					/* NB: also needed in code.the_char */
	/* NB: This function is called ONLY with format == "%lf", so we can
	   simplify the processing, using strtod() to do the conversion, and
	   also allowing us to advance the rl_nextc pointer correctly. */
	char *endptr;
	int result;

	/* Collect a numeric string matching the regular expression
		[-+]*[0-9]*[.]?[0-9]*([Ee][-+]*[0-9])?
	   with the constraint that at least one digit must be seen
	*/

	rl_ndigits = 0;
	rl_ntoken = 0;
	rl_scan_whitespace(fpin);	/* regexp: [ \t]* */
	rl_scan_sign(fpin); 		/* regexp: [-+]* */
	rl_scan_digits(fpin);		/* regexp: [0-9]* */
	rl_scan_dot(fpin);		/* regexp: [.]? */
	rl_scan_digits(fpin);		/* regexp: [0-9]* */
	rl_scan_exponent(fpin);		/* regexp: [Ee][-+]*[0-9]+ */
	if (rl_ndigits > 0)		/* looks like we got a number */
	{
		*(double*)pdata = strtod(rl_token,&endptr);
		result = 1;
	}
	else				/* did not find a valid number */
	{
		result = 0;
		endptr = &rl_token[0];
	}
	if (endptr != (char*)NULL)	/* put back unread input */
	{
		char *last;
		last = strchr(endptr,'\0') - 1;
		while (last >= endptr)
			rl_unget_char(*last--);
	}
	else
		execerror("unexpected return from strtod()", (const char*)NULL);
	return (result);
}

#undef getc
#define getc(fpin)			rl_getchar(fpin)
#undef ungetc
#define ungetc(c,fpin)			rl_unget_char(c)
#undef fscanf
#define fscanf(fpin,format,pdata)	rl_fscanf(fpin,format,pdata)

#endif /* defined(HAVE_GNU_READLINE) */

int c = '\n';	/* global for use by warning() */

static int	backslash(int), follow(int, int, int);
static void	run(void);

int
yylex(void)		/* hoc6 */
{
	while ((c=getc(fin)) == ' ' || c == '\t')
		;
	if (c == EOF)
		return 0;
	if (c == '\\') {
		c = getc(fin);
		if (c == '\n') {
			bump_lineno();
			return yylex();
		}
	}
	if (c == '#') {		/* comment */
		while ((c=getc(fin)) != '\n' && c != EOF)
			;
		if (c == '\n')
			bump_lineno();
		return c;
	}
	if (c == '.' || isdigit(c)) {	/* number */
		double d;
		(void)ungetc(c, fin);
		(void)fscanf(fin, "%lf", &d);
		yylval.sym = install("", NUMBER, d);
		return NUMBER;
	}
	if (isalpha(c) || c == '_') {
		Symbol *s;
		char sbuf[MAX_NAME+1], *p = sbuf;
		do {
			if (p >= sbuf + sizeof(sbuf) - 1) {
				*p = '\0';
				execerror("name too long", sbuf);
			}
			*p++ = c;
		} while ((c=getc(fin)) != EOF && (isalnum(c) || c == '_'));
		(void)ungetc(c, fin);
		*p = '\0';
		if ((s=lookup(sbuf),s) == (Symbol*)NULL)
			s = install(sbuf, UNDEF, 0.0);
		yylval.sym = s;
#if 0
		(void)fprintf(stderr,"yylex() -> VAR [%s]\n", sbuf);
#endif
		return s->type == UNDEF ? VAR : s->type;
	}
	if (c == '$') {	/* argument? */
		int n = 0;
		while (isdigit(c=getc(fin)))
			n = 10 * n + c - '0';
		(void)ungetc(c, fin);
		if (n == 0)
			execerror("strange $...", (const char *)NULL);
		yylval.narg = n;
		return ARG;
	}
	if (c == '"') {	/* quoted string */
		char sbuf[MAX_STRING+1], *p;
		for (p = sbuf; (c=getc(fin)) != '"'; p++) {
			if (c == '\n' || c == EOF)
				execerror("missing quote", "");
			if (p >= sbuf + sizeof(sbuf) - 1) {
				*p = '\0';
				execerror("string too long", sbuf);
			}
			*p = backslash(c);
		}
		*p = 0;
#if 0
		/* Old ugly code that masquerades a string on top of a Symbol */
		yylval.sym = (Symbol *)emalloc(strlen(sbuf)+1);
		strcpy((char*)yylval.sym, sbuf);
#else
		/* New code to generate a real Symbol instead */
#if 0
		yylval.sym = (Symbol *)emalloc(sizeof(Symbol));
		yylval.sym->name = (const char*)NULL;
		yylval.sym->type = STRING;
		yylval.sym->u.str = dupstr(sbuf);
		yylval.sym->immutable = 1;
		yylval.sym->next = (Symbol*)NULL;
#else
		yylval.sym = install_const_string("", sbuf);
#endif
#endif
#if 0
		(void)fprintf(stderr,"yylex() -> STRING [%s]\n", sbuf);
#endif
		return STRING;
	}
	switch (c) {
	case ':':	return follow('=', CONSTEQ, ':');
	case '+':	return follow('+', INC, follow('=', ADDEQ, '+'));
	case '-':	return follow('-', DEC, follow('=', SUBEQ, '-'));
	case '*':	return follow('=', MULEQ, '*');
	case '/':	return follow('=', DIVEQ, '/');
	case '%':	return follow('=', MODEQ, '%');
	case '>':	return follow('=', GE, GT);
	case '<':	return follow('=', LE, LT);
	case '=':	return follow('=', EQ, '=');
	case '!':	return follow('=', NE, NOT);
	case '|':	return follow('|', OR, '|');
	case '&':	return follow('&', AND, '&');
	case '\n':	bump_lineno(); return '\n';
	default:	return c;
	}
}
a436 5
static int
backslash(int c)	/* get next char with \'s interpreted */
{
	static char transtab[] = "a\ab\bf\fn\nr\rt\tv\v"; /* Standard C escapes */

d484 2
d488 2
a489 2
static int
follow(int expect, int ifyes, int ifno)	/* look ahead for >=, etc. */
d491 1
a491 1
	int ch = getc(fin);
d493 3
a495 5
	if (ch == expect)
		return ifyes;
	(void)ungetc(ch, fin);
	return ifno;
}
d497 8
a504 8
void
yyerror(const char* s)	/* report compile-time error */
{
/*rob
	warning(s, (const char *)NULL);
	longjmp(begin, 0);
rob*/
	execerror(s, (const char *)NULL);
d508 1
a508 1
prepend_file(const char* filename)
d510 31
a540 10
	char** new_gargv;
	int new_gargc;

	new_gargc = gargc + 1;
	new_gargv = (char**)emalloc(sizeof(char*) * (new_gargc + 1));
	new_gargv[0] = (char*)emalloc(sizeof(char) * (strlen(filename) + 1));
	(void)strcpy(new_gargv[0],filename);
	(void)memcpy(&new_gargv[1], gargv, (gargc + 1)*sizeof(char*));
	gargc = new_gargc;
	gargv = new_gargv;
d543 2
a544 2
static const char *
get_language_code(void)
d546 2
a547 13
	/* According to "man 3c setlocale", the language of text
	messages is determined by the locale variable LC_MESSAGES: its
	value is set by the first defined of three environment
	variables. */

	const char *language_code;

	language_code = getenv("LC_ALL");
	if (language_code == (const char*)NULL)
		language_code = getenv("LC_MESSAGES");
	if (language_code == (const char*)NULL)
		language_code = getenv("LANG");
	return (language_code);
d550 2
a551 2
static const char *
get_language_file(const char *dirname, const char *basename)
d553 10
a562 5
	/* Given dirname = "/x/y/z" and basename == "foo.bar", return
	   "/x/y/z/LANG/foo.bar", where LANG is obtained from
	   get_language_code() */
	const char *lang;
	char *lang_file;
d564 1
a564 4
	lang = get_language_code();
	if (lang == (const char*)NULL)
		return ((const char*)NULL);
	else
d566 2
a567 6
		lang_file = (char*)emalloc(sizeof(char) *
					   (strlen(dirname) +
					    1 + strlen(lang) + 1 +
					    strlen(basename) + 1));
		return (strcat(strcat(strcat(strcat(strcpy(lang_file, dirname), "/"),
					     lang), "/"), basename));
a568 1
}
d570 5
a574 3
static void
check_for_hocrc(void)
{
d576 5
a580 5
	/* Prepend startup files in reverse order of use: first to
	   read is syshocrc, then user's .hocrc, then command line
	   file(s). */

	const char *lang_file;
a582 4
	static char* userhocrc;
	char* home;
	size_t need;

d585 3
d589 1
a589 1
		if (home == (char*)NULL)
d591 3
a593 5
		need = strlen(home) + 1 + strlen(hocrc) + 1;
		userhocrc = (char*)emalloc(sizeof(char) * need);
		(void)strcat(strcat(strcat(userhocrc, home), "/"),hocrc);
		if (access(userhocrc, R_OK) == 0)
			prepend_file(userhocrc);
d596 1
d598 6
a603 1
	if (read_help_file)
d605 14
a618 18
		lang_file = get_language_file(syshocdir, syshochlpbase);
		if ((lang_file != (const char*)NULL) &&
		    (access(lang_file, R_OK) == 0))
			prepend_file(lang_file);

		if (access(syshochlp, R_OK) == 0)
			prepend_file(syshochlp);
	}

	if (read_site_file)
	{
		lang_file = get_language_file(syshocdir, syshocrcbase);
		if ((lang_file != (const char*)NULL) &&
		    (access(lang_file, R_OK) == 0))
			prepend_file(lang_file);

		if (access(syshocrc, R_OK) == 0)
			prepend_file(syshocrc);
a621 19
void
execerror(const char* s, const char* t)	/* recover from run-time error */
{
	warning(s, t);
	(void)fseek(fin, 0L, 2);	/* flush rest of file */
	longjmp(begin, 0);
}

void
fpecatch(int dummy)	/* catch floating point exceptions */
{
	execerror("floating point exception", (const char*)NULL);
}

void
intcatch(int dummy)	/* catch interrupts */
{
	execerror("interrupt", (const char*)NULL);
}
d624 1
a624 1
run(void)	/* execute until EOF */
d626 2
a627 6
	(void)setjmp(begin);
	(void)signal(SIGINT, intcatch);
	(void)signal(SIGFPE, fpecatch);
	for (initcode(); yyparse(); initcode())
		execute(progbase);
}
d629 3
a631 13
static void
author_and_die(void)
{
	(void)fprintf(stderr, "%s was written by\n\n\tBrian W. Kernighan and Rob Pike\n\n",
		      PACKAGE_NAME);
	(void)fprintf(stderr, "and described in their book:\n\n");
	(void)fprintf(stderr, "\tThe UNIX Programming Environment\n");
	(void)fprintf(stderr, "\tPrentice-Hall\n");
	(void)fprintf(stderr, "\t1984\n");
	(void)fprintf(stderr, "\tISBN 0-13-937699-2 (hardcover), 0-13-937681-X (paperback)\n\n");
	(void)fprintf(stderr, "Extensions by the current maintainer, %s.\n", PACKAGE_BUGREPORT);
	exit(EXIT_SUCCESS);
}
d633 8
a640 11
static void
usage(void)
{
	(void)fprintf(stderr, "Usage:\n");
	(void)fprintf(stderr, "\t%s\t[ --author ] [ --help ] [ --no-help-file ]\n",
		      progname);
	(void)fprintf(stderr, "\t\t[ --no-site-file ] [ --no-user-file ] [ --silent ]\n");
	(void)fprintf(stderr, "\t\t[ --version ]\n");
	(void)fprintf(stderr, "\t\tinput-file(s) [ -- ] more-input-file(s)\n\n");
	(void)fprintf(stderr, "Options may be prefixed with either one or two hyphens.\n");
}
d642 62
a703 10
static void
help_and_die(void)
{
	usage();
	(void)fprintf(stderr, "\n");
	(void)fprintf(stderr, "For additional help, try %s's help() command, or in a shell,\n",
		      PACKAGE_NAME);
	(void)fprintf(stderr, "use the UNIX manual page command, man %s.\n", PACKAGE_NAME);
	exit(EXIT_SUCCESS);
}
d705 4
a708 7
static void
usage_and_die(const char *bad_option)
{
	(void)fprintf(stderr, "Unrecognized option: [%s]\n", bad_option);
	usage();
	exit(EXIT_FAILURE);
}
d710 1
a710 7
static void
version_and_die(void)
{
	(void)fprintf(stderr, "This is %s version %s of %s.\n\n",
		      PACKAGE_NAME, PACKAGE_VERSION, PACKAGE_DATE);
	(void)fprintf(stderr, "Report bugs to %s.\n", PACKAGE_BUGREPORT);
	exit(EXIT_SUCCESS);
d714 1
a714 1
do_args(int *pargc, char* argv[])
d716 2
a717 3
	int k, m;
	char *p;
	Symbol *s;
d719 8
a726 1
	(void)install("__VERBOSE__", VAR, 1.0);	/* so -silent setting is available to user code */
d749 1
a749 1
			if (strcmp(p,"") == 0) /* ignore "-" option (meaning, stdin) */
d751 2
a752 3
				if (p == (argv[k] + 2))
					p[-1] = '\0'; /* convert "--" to "-" */
				continue;
a753 4
			else if (ARGMATCH(p,"author",1))
				author_and_die();
			else if (ARGMATCH(p,"help",1))
				help_and_die();
d756 8
a763 1
			else if (ARGMATCH(p,"no-site-file",4))
d765 2
d769 1
a769 1
			else if (ARGMATCH(p,"quick",1))	/* possibly temporary, and undocumented! */
d773 1
d779 1
a779 1
				(void)install("__VERBOSE__", VAR, 0.0);
a780 9
			else if (ARGMATCH(p,"version",1))
				version_and_die();
			else
				usage_and_die(argv[k]);
			/* Remove the option from the argument list */
			for (m = k + 1; m < (*pargc); ++m)
				argv[m-1] = argv[m];
			(*pargc)--;
			k--;	/* avoid missing the next argument */
d783 76
d860 29
a888 2
	if (s != (Symbol*)NULL)
		s->immutable = 1;
d891 33
a923 2
int
main(int argc, char* argv[])	/* hoc6 */
a924 5
	static int first = 1;
#ifdef YYDEBUG
	extern int yydebug;
	yydebug=3;
#endif
d928 1
a928 1
	rl_fd_stdin = dup(fileno(stdin)); /* save handle for original stdin */
d930 2
d933 13
a945 18
#if defined(HAVE_LOCALE_H)
	/* This single call internationalizes the hoc language!  An
	   external setting of the environment variables LANG or
	   LC_ALL will change the behavior of isalnum() and isalpha(),
	   allowing accented characters in ISO 8859-1 from 128..255 to
	   be used in hoc identifiers.  Yet to be done is the
	   replacement of English messages embedded in the source code
	   with locale-sensitive internationalized ones. */
#if 0
	(void)setlocale(LC_ALL, "");
#else
	{
		const char *language_code;
		language_code = get_language_code();
		if (language_code != (const char*)NULL)
			(void)setlocale(LC_ALL, language_code);
	}
#endif
d947 1
d949 3
a951 2
	progname = argv[0];
	init();
d953 3
a955 1
	do_args(&argc,argv);
d958 1
a958 1
		static char *stdinonly[] = { stdhyphen };
a966 1
	check_for_hocrc();
a972 19
void
set_filename(const char *filename)
{
	Symbol *s;
	char temp[sizeof("__FILE__") + sizeof("18446744073709551616" /* 2^64 */) + 2];

	(void)sprintf(temp,"__FILE__[%d]", infile_count);
	install_const_string(temp,filename);

	s = lookup("__FILE__");
	if (s == (Symbol*)NULL)
		s = install_const_string("__FILE__",filename);
	else
		(void)set_string(s,filename);
	if (current_filename != (const char*)NULL)
		free((void*)current_filename);
	current_filename = dupstr(filename);
}

d978 2
a979 1
	if (fin && fin != stdin)
d981 2
d990 2
a991 2
		(void)dup2(rl_fd_stdin,fileno(stdin)); /* restore original stdin */
	} else if ((fin=freopen(infile, "r", stdin)) == NULL) {
d993 1
a993 1
	} else if ((fin=fopen(infile, "r")) == NULL) {
d995 1
a995 1
		fprintf(stderr, "%s: can't open %s\n", progname, infile);
a997 2
	init_lineno();
	infile_count++;
d1002 93
d1098 6
d1114 8
d1130 1
d1138 60
d1200 2
a1201 2
static void
defnonly(const char *s)	/* warn if illegal definition */
d1203 88
a1290 2
	if (!indef)
		execerror(s, "used outside definition");
@


1.2
log
@Move declaration of indef to top section to avoid a compilation
failure on IBM RS/6000 AIX 4.1 systems.
@
text
@d2 43
d46 68
a113 4
#include "hoc.h"
#define	code2(c1,c2)	code(c1); code(c2)
#define	code3(c1,c2,c3)	code(c1); code(c2); code(c3)
int	indef;
d118 1
a118 1
	int	narg;	/* number of arguments */
d120 1
a120 1
%token	<sym>	NUMBER STRING PRINT VAR BLTIN UNDEF WHILE FOR IF ELSE
d122 1
d125 2
a126 1
%type	<inst>	cond while for if begin end 
d129 1
a129 1
%right	'=' ADDEQ SUBEQ MULEQ DIVEQ MODEQ
d135 1
a135 1
%left	UNARYMINUS NOT INC DEC
d141 5
a145 3
	| list asgn '\n'  { code2(xpop, STOP); return 1; }
	| list stmt '\n'  { code(STOP); return 1; } 
	| list expr '\n'  { code2(printtop, STOP); return 1; }
d148 19
a166 12
asgn:	  VAR '=' expr { code3(varpush,(Inst)$1,assign); $$=$3; }
	| VAR ADDEQ expr	{ code3(varpush,(Inst)$1,addeq); $$=$3; }
	| VAR SUBEQ expr	{ code3(varpush,(Inst)$1,subeq); $$=$3; }
	| VAR MULEQ expr	{ code3(varpush,(Inst)$1,muleq); $$=$3; }
	| VAR DIVEQ expr	{ code3(varpush,(Inst)$1,diveq); $$=$3; }
	| VAR MODEQ expr	{ code3(varpush,(Inst)$1,modeq); $$=$3; }
	| ARG '=' expr   { defnonly("$"); code2(argassign,(Inst)$1); $$=$3;}
	| ARG ADDEQ expr { defnonly("$"); code2(argaddeq,(Inst)$1); $$=$3;}
	| ARG SUBEQ expr { defnonly("$"); code2(argsubeq,(Inst)$1); $$=$3;}
	| ARG MULEQ expr { defnonly("$"); code2(argmuleq,(Inst)$1); $$=$3;}
	| ARG DIVEQ expr { defnonly("$"); code2(argdiveq,(Inst)$1); $$=$3;}
	| ARG MODEQ expr { defnonly("$"); code2(argmodeq,(Inst)$1); $$=$3;}
d168 3
a170 2
stmt:	  expr	{ code(xpop); }
	| RETURN { defnonly("return"); code(procret); }
d172 1
a172 1
	        { defnonly("return"); $$=$2; code(funcret); }
d174 1
a174 1
		{ $$ = $2; code3(call, (Inst)$1, (Inst)$4); }
d176 3
d196 1
a196 1
cond:	   expr 	{ code(STOP); }
d200 1
a200 1
for:	  FOR	{ $$ = code(forcode); code3(STOP,STOP,STOP); code(STOP); }
d202 1
a202 1
if:	  IF	{ $$ = code(ifcode); code3(STOP,STOP,STOP); }
d206 1
a206 1
end:	  /* nothing */		{ code(STOP); $$ = progp; }
d212 6
d222 1
d224 1
a224 1
		{ $$ = $2; code3(call,(Inst)$1,(Inst)$4); }
d226 5
a230 1
	| BLTIN '(' expr ')' { $$=$3; code2(bltin, (Inst)$1->u.ptr); }
d232 17
a248 16
	| expr '+' expr	{ code(add); }
	| expr '-' expr	{ code(sub); }
	| expr '*' expr	{ code(mul); }
	| expr '/' expr	{ code(divop); }	/* ansi has a div fcn! */
	| expr '%' expr	{ code(mod); }
	| expr '^' expr	{ code (power); }
	| '-' expr   %prec UNARYMINUS   { $$=$2; code(negate); }
	| expr GT expr	{ code(gt); }
	| expr GE expr	{ code(ge); }
	| expr LT expr	{ code(lt); }
	| expr LE expr	{ code(le); }
	| expr EQ expr	{ code(eq); }
	| expr NE expr	{ code(ne); }
	| expr AND expr	{ code(and); }
	| expr OR expr	{ code(or); }
	| NOT expr	{ $$ = $2; code(not); }
d254 4
a257 4
prlist:	  expr			{ code(prexpr); }
	| STRING		{ $$ = code2(prstr, (Inst)$1); }
	| prlist ',' expr	{ code(prexpr); }
	| prlist ',' STRING	{ code2(prstr, (Inst)$3); }
d260 1
a260 1
	    '(' ')' stmt { code(procret); define($2); indef=0; }
d262 1
a262 1
	    '(' ')' stmt { code(procret); define($2); indef=0; }
d274 271
a544 13
#include <stdio.h>
#include <ctype.h>
char	*progname;
int	lineno = 1;
#include <signal.h>
#include <setjmp.h>
#include <errno.h>
jmp_buf	begin;
char	*infile;	/* input file name */
FILE	*fin;		/* input file pointer */
char	**gargv;	/* global argument list */
extern	errno;
int	gargc;
d548 2
a549 3
int	backslash(int), follow(int, int, int);
void	defnonly(char*), run(void);
void	warning(char*, char*);
d551 1
d561 1
a561 1
			lineno++;
d569 1
a569 1
			lineno++;
d574 2
a575 2
		ungetc(c, fin);
		fscanf(fin, "%lf", &d);
d581 1
a581 1
		char sbuf[100], *p = sbuf;
d589 1
a589 1
		ungetc(c, fin);
d591 1
a591 1
		if ((s=lookup(sbuf)) == 0)
d594 3
d603 1
a603 1
		ungetc(c, fin);
d605 1
a605 1
			execerror("strange $...", (char *)0);
d610 1
a610 1
		char sbuf[100], *p;
d621 2
d625 16
d644 1
d656 1
a656 1
	case '\n':	lineno++; return '\n';
d661 3
d666 2
a667 1
	static char transtab[] = "b\bf\fn\nr\rt\t";
d671 1
a671 1
	if (islower(c) && strchr(transtab, c))
d673 41
d717 1
d720 1
a720 1
	int c = getc(fin);
d722 1
a722 1
	if (c == expect)
d724 1
a724 1
	ungetc(c, fin);
d729 1
a729 1
yyerror(char* s)	/* report compile-time error */
d732 1
a732 1
	warning(s, (char *)0);
d735 108
a842 1
	execerror(s, (char *)0);
d846 1
a846 1
execerror(char* s, char* t)	/* recover from run-time error */
d849 1
a849 1
	fseek(fin, 0L, 2);		/* flush rest of file */
d854 1
a854 1
fpecatch(void)	/* catch floating point exceptions */
d856 1
a856 1
	execerror("floating point exception", (char *) 0);
d860 1
a860 1
intcatch(void)	/* catch interrupts */
d862 1
a862 1
	execerror("interrupt", (char *) 0);
d865 1
a865 1
void
d868 3
a870 3
	setjmp(begin);
	signal(SIGINT, intcatch);
	signal(SIGFPE, fpecatch);
d875 127
d1010 26
d1038 2
d1041 2
a1042 1
		static char *stdinonly[] = { "-" };
d1051 1
d1054 1
a1054 1
	signal(SIGINT, SIG_IGN);
d1058 20
d1083 1
a1083 1
		fclose(fin);
d1085 3
a1087 2
	lineno = 1;
	if (strcmp(infile, "-") == 0) {
d1089 5
a1093 1
		infile = 0;
d1095 1
d1099 3
d1105 2
a1106 2
void
warning(char *s, char *t)	/* print warning message */
d1108 11
d1125 1
d1127 2
a1128 2
		if((c = getc(fin)) == '\n')	/* flush rest of input line */
			lineno++;
d1135 2
a1136 2
void
defnonly(char *s)	/* warn if illegal definition */
@


1.1
log
@Initial revision
@
text
@d6 1
a147 1
int	indef;
@
