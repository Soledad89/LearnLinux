head	1.19;
access;
symbols;
locks
	beebe:1.19; strict;
comment	@ * @;


1.19
date	2002.08.08.22.21.57;	author beebe;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.08.01.24.57;	author beebe;	state Exp;
branches;
next	1.17;

1.17
date	2002.08.01.12.23.30;	author beebe;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.31.17.25.51;	author beebe;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.30.18.14.00;	author beebe;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.28.14.24.54;	author beebe;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.24.19.20.50;	author beebe;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.24.14.50.07;	author beebe;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.20.23.09.17;	author beebe;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.22.23.11.17;	author beebe;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.15.22.44.05;	author beebe;	state Exp;
branches;
next	1.8;

1.8
date	2002.02.19.01.01.40;	author beebe;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.30.17.09.19;	author beebe;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.27.18.22.21;	author beebe;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.11.02.37.54;	author beebe;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.04.17.47.08;	author beebe;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.02.21.37.28;	author beebe;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.02.15.03.21;	author beebe;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.01.13.18.21;	author beebe;	state Exp;
branches;
next	;


desc
@Original version.
@


1.19
log
@Rename StoN to StoF, for symmetry with FtoS.
@
text
@#include "hoc.h"

#if defined(HAVE_CTYPE_H)
#include <ctype.h>			/* for isxxx() prototypes */
#endif

#if defined(HAVE_MATH_H)
#include <math.h>			/* for ldexp() prototype */
#endif

#if defined(HAVE_STDIO_H)
#include <stdio.h>			/* for sprintf()/snprintf() prototypes */
#endif

#if defined(HAVE_STRING_H)
#include <string.h>
#endif

#define elementsof(x)	(sizeof(x)/sizeof(x[0]))

extern char **environ;			/* defined in run-time library */
EXTERN int cmpstr ARGS((const void *, const void *));

static unsigned int	htou ARGS((const char *));
static const char *	xinttos ARGS((fp_t));

const char *
Abort(const char *s)
{
	execerror("execution aborted:", s);
	return (dupstr(""));		/* NOT REACHED */
}

const char *
concat2(const char *s, const char *t)
{
	if (s == (const char *)NULL)
		s = "";
	if (t == (const char *)NULL)
		t = "";
	return ((const char*)strcat(strcpy((char*)emalloc(strlen(s) + strlen(t) + 1), s), t));
}

const char *
concat3(const char *s, const char *t, const char *u)
{
	if (s == (const char *)NULL)
		s = "";
	if (t == (const char *)NULL)
		t = "";
	if (u == (const char *)NULL)
		u = "";
	return ((const char*)strcat(strcat(strcpy((char*)emalloc(strlen(s) + strlen(t) + strlen(u) + 1), s), t), u));
}

const char *
concat4(const char *s, const char *t, const char *u, const char *v)
{
	if (s == (const char *)NULL)
		s = "";
	if (t == (const char *)NULL)
		t = "";
	if (u == (const char *)NULL)
		u = "";
	if (v == (const char *)NULL)
		v = "";
	return ((const char*)strcat(strcat(strcat(strcpy((char*)emalloc(strlen(s) + strlen(t) + strlen(u) + strlen(v) + 1), s), t), u), v));
}

const char *
concat5(const char *s, const char *t, const char *u, const char *v, const char *w)
{
	if (s == (const char *)NULL)
		s = "";
	if (t == (const char *)NULL)
		t = "";
	if (u == (const char *)NULL)
		u = "";
	if (v == (const char *)NULL)
		v = "";
	if (w == (const char *)NULL)
		w = "";
	return ((const char*)strcat(strcat(strcat(strcat(strcpy((char*)emalloc(strlen(s) + strlen(t) + strlen(u) + strlen(v) + strlen(w) + 1), s), t), u), v), w));
}

const char *
concat6(const char *s, const char *t, const char *u, const char *v, const char *w, const char *x)
{
	if (s == (const char *)NULL)
		s = "";
	if (t == (const char *)NULL)
		t = "";
	if (u == (const char *)NULL)
		u = "";
	if (v == (const char *)NULL)
		v = "";
	if (w == (const char *)NULL)
		w = "";
	if (x == (const char *)NULL)
		x = "";
	return ((const char*)strcat(strcat(strcat(strcat(strcat(strcpy((char*)emalloc(strlen(s) + strlen(t) + strlen(u) + strlen(v) + strlen(w) + strlen(x) + 1), s), t), u), v), w), x));
}

int
decval(int c)
{	/* return the decimal value of c, or 01 if not decimal */
	/* All current characters sets (ASCII, EBCDIC, ISO8859-n,
	   ISO10646, Unicode) have consecutive decimal digits, so this
	   code is portable. */
	if (('0' <= c) && (c <= '9'))
		return ((int)(c - '0'));
	else
		return (-1);
}

const char *
Char(fp_t n)
{
	char s[2] = {'\0', '\0'};
	/* NB: (char)(unsigned char)n produced incorrect results on
	   IBM AIX 4.2 with g++ 2.95.3; this rewrite fixes the problem. */
	s[0] = (char)(0xff & (int)n);
	return (dupstr(s));
}

const char *
Exit(const char *reason)
{
	if ((reason != (const char*)NULL) && (*reason != '\0'))
	{
		warning(reason, (const char*)NULL);
		exit(EXIT_FAILURE);
	}
	else
		exit(EXIT_SUCCESS);
	return (dupstr(""));		/* NOT REACHED */
}

const char *
Expand(const char *s)
{	/* Return a dynamic copy of s with escape sequences expanded */
	char *p;
	char *t;

	t = (char*)dupstr(s);
	for (p = t; *s != '\0'; p++, s++)
	{
		if (*s == '\\')
		{
			switch (*++s)
			{		/* abfnrtvE */
			case 'a': *p = '\007'; break;	/* NB: use octal value for old K&R compilers */
			case 'b': *p = '\b'; break;
			case 'f': *p = '\f'; break;
			case 'n': *p = '\n'; break;
			case 'r': *p = '\r'; break;
			case 't': *p = '\t'; break;
			case 'v': *p = '\v'; break;
			case 'E': *p = '\033'; break;
			default: *p = *s; break;
			}
		}
		else
			*p = *s;
	}
	*p = '\0';
	return ((const char*)t);
}

const char *
FtoH(fp_t x)
{	/* return dynamic copy of native floating-point converted to hexadecimal */
	char buffer[sizeof("XXXXXXXX_XXXXXXXX_XXXXXXXX_XXXXXXXX")];
	FP_Parts d;
	int big_endian = IsBigEndian();

	d.v = x;

#if defined(HAVE_FP_T_SINGLE)
	SNPRINTF4(buffer, sizeof(buffer), "%08x", d.i[0]);
#endif

#if defined(HAVE_FP_T_DOUBLE)
	SNPRINTF5(buffer, sizeof(buffer), "%08x_%08x",
		  d.i[1-big_endian], d.i[big_endian]);
#endif

#if defined(HAVE_FP_T_QUADRUPLE)
	if (sizeof(d) == sizeof(d.v))	/* 128-bit */
	{
		if (big_endian)	/* 128-bit big endian */
			SNPRINTF7(buffer, sizeof(buffer), "%08x_%08x_%08x_%08x",
					d.i[0], d.i[1], d.i[2], d.i[3]);
		else		/* 128-bit little endian */
			SNPRINTF7(buffer, sizeof(buffer), "%08x_%08x_%08x_%08x",
					d.i[3], d.i[2], d.i[1], d.i[0]);
	}
	else if (sizeof(fp_t) == sizeof(double)) /* long double masquerading as double */
	{
		SNPRINTF5(buffer, sizeof(buffer), "%08x_%08x",
			  d.i[1-big_endian], d.i[big_endian]);
	}
	else				/* 80-bit Intel x86 format */
	{
		SNPRINTF6(buffer, sizeof(buffer), "%04x_%08x_%08x",
				(d.i[2] & 0xffff), d.i[1], d.i[0]);
	}
#endif

	return (dupstr(buffer));
}

const char *
FtoS(fp_t x)
{	/* return dynamic copy of floating-point converted to a string */
	return (dupstr(fmtnum(x)));
}

const char *
Getenv(const char *envvar)
{	/* Return the value of environment variable envvar, as a new
	   string (empty if envvar was not defined, or was empty).
	   The dupstr() call is necessary because at least two UNIX
	   platforms (Apple Darwin (MacOS X) and FreeBSD) use an
	   overwrite-in-place-when-possible algorithm in putenv(). */
	const char *p;

	p = (const char *)getenv(envvar);
	if (p == (const char *)NULL)
		p = "";
	return (dupstr(p));
}

const char *
Hex(fp_t x)
{	/* return dynamic copy of floating-point converted to native
	   hexadecimal, C99 hexadecimal, and decimal */
	char buffer[sizeof("0xhhhhhhhh_hhhhhhhh_hhhhhhhh_hhhhhhhh")];
	FP_Parts d;
	int big_endian = IsBigEndian();

	d.v = x;

#if defined(HAVE_FP_T_DOUBLE)
	SNPRINTF5(buffer, sizeof(buffer), "0x%08x_%08x", d.i[1 - big_endian], d.i[big_endian]);
#endif

#if defined(HAVE_FP_T_QUADRUPLE)
	if (sizeof(d) == sizeof(d.v)) /* 128-bit */
	{
		if (big_endian)		/* 128-bit big endian */
			SNPRINTF7(buffer, sizeof(buffer), "0x%08x_%08x_%08x_%08x",
				  d.i[0], d.i[1], d.i[2], d.i[3]);
		else			/* 128-bit little endian */
			SNPRINTF7(buffer, sizeof(buffer), "0x%08x_%08x_%08x_%08x",
				  d.i[3], d.i[2], d.i[1], d.i[0]);
	}
	else if (sizeof(fp_t) == sizeof(double)) /* long double masquerading as double */
		SNPRINTF5(buffer, sizeof(buffer), "0x%08x_%08x",
			  d.i[1 - big_endian], d.i[big_endian]);
	else				/* 80-bit little endian */
		SNPRINTF6(buffer, sizeof(buffer), "0x%04x_%08x_%08x",
			  (0xffff & d.i[2]), d.i[1], d.i[0]);
#endif

#if defined(HAVE_FP_T_SINGLE)
	SNPRINTF4(buffer, sizeof(buffer), "0x%08x", d.i[0]);
#endif

	return (concat5(buffer," == ",xfptos(x)," ",fmtnum(x)));
}

const char *
Hexfp(fp_t x)
{	/* return dynamic copy of floating-point converted to C99 hexadecimal */
	return (dupstr(xfptos(x)));
}

const char *
Hexint(fp_t x)
{	/* return dynamic copy of floating-point converted to C hexadecimal integer */
	return (dupstr(xinttos(x)));
}

int
hexval(int c)
{	/* return the hexadecimal value of c, or -1 if not hexadecimal */
	/* All current characters sets (ASCII, EBCDIC, ISO8859-n,
	   ISO10646, Unicode) have consecutive decimal digits and
	   consecutive letters A-F, so this code is portable. */
	if (('0' <= c) && (c <= '9'))
		return ((int)(c - '0'));
	else if (('a' <= c) && (c <= 'f'))
		return ((int)((c - 'a') + 10));
	else if (('A' <= c) && (c <= 'F'))
		return ((int)((c - 'A') + 10));
	else
		return (-1);
}

fp_t
HtoF(const char *s)
{
	char *p;
	char *t;
	FP_Parts d;
	int big_endian = IsBigEndian();

	d.v = FP(0.0);

	t = (char*)dupstr(s);

	for (p = t; *s; ++s)
	{
		if (isxdigit(*s))
			*p++ = *s;	/* copy only hexadecimal digits */
	}
	*p = '\0';			/* terminate string */

#if defined(HAVE_FP_T_SINGLE)
	if (strlen(t) == 8)
	{
		d.i[0] = htou(t);
	}
	else
		execerror("illegal native hexadecimal string in htof()", (const char*)NULL);
#endif

#if defined(HAVE_FP_T_DOUBLE)
	if (strlen(t) == 16)
	{
		d.i[big_endian] = htou(t+8);
		t[8] = '\0';
		d.i[1-big_endian] = htou(t);
	}
	else
		execerror("illegal native hexadecimal string in htof()", (const char*)NULL);
#endif

#if defined(HAVE_FP_T_QUADRUPLE)
	if (sizeof(d) == sizeof(d.v))	/* 128-bit */
	{
		if (strlen(t) == 32)
		{
			if (big_endian)
			{
				d.i[3] = htou(t+24);
				t[24] = '\0';
				d.i[2] = htou(t+16);
				t[16] = '\0';
				d.i[1] = htou(t+8);
				t[8] = '\0';
				d.i[0] = htou(t+0);
			}
			else
			{
				d.i[0] = htou(t+24);
				t[24] = '\0';
				d.i[1] = htou(t+16);
				t[16] = '\0';
				d.i[2] = htou(t+8);
				t[8] = '\0';
				d.i[3] = htou(t+0);
			}
		}
		else
			execerror("illegal native hexadecimal string in htof()", (const char*)NULL);
	}
	else if (sizeof(fp_t) == sizeof(double)) /* long double masquerading as double */
	{
		if (strlen(t) == 16)
		{
			d.i[big_endian] = htou(t+8);
			t[8] = '\0';
			d.i[1-big_endian] = htou(t);
		}
		else
			execerror("illegal native hexadecimal string in htof()", (const char*)NULL);
	}
	else				/* 80-bit Intel x86 format */
	{
		if (strlen(t) == 20)
		{
			d.i[0] = htou(t+12);
			t[12] = '\0';
			d.i[1] = htou(t+4);
			t[4] = '\0';
			d.i[2] = htou(t+0);
		}
		else
			execerror("illegal native hexadecimal string in htof()", (const char*)NULL);
	}
#endif

	efree((void*)t);

	return (d.v);
}


static unsigned int
htou(const char *s)			/* hexadecimal to unsigned integer */
{
	unsigned int h;
	unsigned int u;

	u = (unsigned int)0;
	while (*s)
	{
		if (('0' <= *s) && (*s <= '9'))
			h = *s - '0';
		else if (('a' <= *s) && (*s <= 'f'))
			h = (*s - 'a') + 10;
		else if (('A' <= *s) && (*s <= 'F'))
			h = (*s - 'A') + 10;
		u = (u << 4) | h;
		s++;
	}

	return (u);
}


fp_t
Ichar(const char *s)
{
	return ((fp_t)(unsigned char)s[0]); /* guarantee Ichar(s) >= 0 */
}

fp_t
Index(const char *s, const char *t)
{	/* return 1-based index of substring t in string s, or 0 if not found */
	const char *p;

	p = strstr(s,t);
	return ((fp_t)((p == (const char*)NULL) ? 0 : ((p - s) + 1)));
}

const char *
Inf_string(fp_t x)
{
	return ((x < 0) ? "-Inf" : "+Inf");
}

fp_t
Length(const char *s)
{
	return ((fp_t)strlen(s));
}

const char *
NaN_string(fp_t x)
{
	if (IsSNaN(x) && !IsQNaN(x))
		return ((Copysign(FP(1.0),x) * Copysign(FP(1.0),NaN()) == FP(-1.0)) ?
			"-SNaN" : "+SNaN");
	else if (IsQNaN(x) && !IsSNaN(x))
		return ((Copysign(FP(1.0),x) * Copysign(FP(1.0),NaN()) == FP(-1.0)) ?
			"-QNaN" : "+QNaN");
	else if (IsNaN(x))
		return ((Copysign(FP(1.0),x) * Copysign(FP(1.0),NaN()) == FP(-1.0)) ?
			"-NaN" : "+NaN");
	else
		return ((const char *)NULL);
}

const char *
Printenv(const char *pattern)
{
	char *equals;
	int len;
#if 0
	size_t len_pattern;
#endif
	int max_name_width;
	size_t n;
	char **p;
	char **sorted_environ;

	if (pattern == (const char *)NULL)
		pattern = "";
#if 0
	len_pattern = strlen(pattern);
#endif

	max_name_width = 0;
	for (n = 0, p = environ; (*p != (char *)NULL); ++p)
	{
		++n;			/* find out how many we need */
		equals = strchr(*p,'=');
		*equals = '\0';
#if 0
		if (strncmp((const char *)*p,pattern,len_pattern) == 0)
#else
		if (match((const char *)*p,pattern))
#endif
		{
#if 0
			len = (int)(strchr(*p,'=') - *p);
#else
			len = (int)strlen(*p);
#endif
			if (max_name_width < len)
				max_name_width = len;
		}
		*equals = '=';
	}

	sorted_environ = (char **)emalloc((n + 1) * sizeof(char *));
	for (n = 0, p = environ; (*p != (char *)NULL); ++p)
		sorted_environ[n++] = *p;
	sorted_environ[n] = (char *)NULL;

	qsort(sorted_environ, n, sizeof(char *), cmpstr);

	for (p = sorted_environ; (*p != (char *)NULL); ++p)
	{
#if 0
		if (strncmp(*p,pattern,len_pattern) == 0)
#else
		equals = strchr(*p,'=');
		*equals = '\0';
		if (match(*p,pattern))
#endif
		{
			prtext2(*p, max_name_width);
			prtext("\t= \"");
			prtext(equals + 1);
			prtext("\"");
			prnl();
		}
		*equals = '=';
	}

	efree((void*)sorted_environ);

	return (dupstr(""));
}

const char *
Protect(const char *s)
{	/* return a copy of s with all nonprintable characters protected */
	char *protected_s;
	char *p;
	const char *q;
	static const char inputtab[]  = "\007\b\f\n\r\t\v\033";	/* NB: use \007, not \a, for old K&R compilers */
	static const char outputtab[] = "abfnrtvE";
	size_t len_protected_s;

	len_protected_s = 4*strlen(s) + 1;
	protected_s = (char*)emalloc(len_protected_s); /* for \ooo worst-case expansion */
	for (p = protected_s; *s; ++s)
	{
		if ((q = strchr(inputtab,*s), q) != (const char*)NULL)
		{
			SNPRINTF4(p, len_protected_s - (p - protected_s),
					"\\%c", (unsigned int)UC(outputtab[q-inputtab]));
			p += 2;
		}
		else if ((*s == '\\') || (*s == '"'))
		{
			SNPRINTF4(p, len_protected_s - (p - protected_s),
					"\\%c", (unsigned int)UC(*s));
			p += 2;
		}
		else if (isprint(*s))
		{
			if ((p - protected_s) < len_protected_s)
				*p++ = *s;
		}
		else
		{
			SNPRINTF4(p, len_protected_s - (p - protected_s),
					"\\%03o", (unsigned int)UC(*s));
			p += 4;
		}
	}
	*p = '\0';
	return ((const char*)protected_s);
}

const char *
Putenv(const char *envvar, const char *newval)
{
	(void)putenv((char*)concat3(envvar,"=",newval));
	return (Getenv(envvar));	/* NB: NOT getenv()! ... see Getenv() comments */
}

fp_t
StoF(const char *s)
{
	return (strton(s, (char**)NULL));
}

#if defined(HAVE_FP_T_QUADRUPLE) && !defined(HAVE_STRTOLD)
long double
strtold(const char * /* restrict */ nptr, char ** /* restrict */ endptr)
{
	long double result;

	/* Sun Solaris 2.8 has no strtold(), but sscanf() works for long
	   double arguments.  Perhaps this mapping will work on other
	   systems as well. */
	if (sscanf(nptr, "%Lg", &result) != 1)
	{
		perror("strtold()->sscanf() failed");
		result = QNaN();
	}
	if (endptr != (char**)NULL)
		*endptr = (char*)strchr(nptr,'\0'); /* pretend that the parse succeeded */
	return (result);
}
#endif

fp_t
strton(const char *s, char **endptr)
{					/* string to number (generalized strtod()) */
	const char *t;
	fp_t result;
	int sign;

	while (isspace(*s))		/* skip leading space */
		++s;

	if (*s == '-')
	{
		s++;
		sign = -1;
	}
	else if (*s == '+')
	{
		s++;
		sign = 1;
	}
	else
		sign = 1;

	t = Tolower(s);

	if (endptr != (char**)NULL)
		*endptr = (char*)strchr(s,'\0');

	/* C99 allows "NAN(n-char-sequence)" (and SGI IRIX already
	produces this in C89), but we don't check for a close
	parenthesis: C99 leaves it implementation dependent whether
	the parentheses are balanced. */

	if (STREQUAL(t,"nan")       || (strncmp(t,"nan(",4) == 0))
		result = NaN();
	else if (STREQUAL(t,"qnan") || (strncmp(t,"qnan(",5) == 0))
		result = QNaN();
	else if (STREQUAL(t,"snan") || (strncmp(t,"snan(",5) == 0))
		result = SNaN();
	else if (STREQUAL(t,"inf")  || STREQUAL(t,"infinity"))
		result = Infinity();
	else
	{
		char *t_endptr;

		/* Try the hexadecimal form first, and if that fails, use
		   whatever native strtod() returns */
		result = xstrtod(t, &t_endptr);

#if defined(HAVE_FP_T_QUADRUPLE)
		if (*t_endptr != '\0')
			result = (fp_t)strtold(t, &t_endptr);
#else
		if (*t_endptr != '\0')
			result = (fp_t)strtod(t, &t_endptr);
#endif

		if (endptr != (char**)NULL)
			*endptr = (char*)(s + (t_endptr - t));
	}
	efree((void*)t);
	if (sign < 0)
		result = -result;
	return (result);
}

const char *
Substr(const char *s, fp_t f_first, fp_t f_length)
{	/* extract (string,first,length) to new dynamic substring, with 1-based indexing */
	size_t first;
	size_t len_sub;
	size_t len_str;
	
	len_str = strlen(s);
	len_sub = (f_length < FP(0.0)) ? (size_t)0 : (size_t)f_length;
	first = (f_first <= FP(1.0)) ? 1 : ((size_t)f_first);
	first--;			/* convert to C/C++ 0-based index */
	if (first > len_str)
		first = len_str;	/* index of final NUL */

	if ((first + len_sub) > len_str)
		len_sub = len_str - first;

	if (len_str > 0)
	{
		char *p;

		p = (char*)emalloc((len_sub + 1)*sizeof(char));
		(void)strlcpy(p,&s[first],len_sub + 1);
		p[len_sub] = '\0';
		return (p);
	}
	else
		return(dupstr(""));
}


const char *
Tolower(const char *s)
{	/* return a dynamic copy of s, converted to lowercase */
	char *t;
	char *p;

	t = (char *)dupstr(s);
	for (p = t; *p; ++p)
		*p = (isupper(UC(*p)) ? tolower(UC(*p)) : *p);

	return (t);
}

const char *
Toupper(const char *s)
{	/* return a dynamic copy of s, converted to uppercase */
	char *t;
	char *p;

	t = (char *)dupstr(s);
	for (p = t; *p; ++p)
		*p = (islower(UC(*p)) ? toupper(UC(*p)) : *p);

	return (t);
}

const char *
xfptos(fp_t x)
{
	/* Convert a floating-point value to a hexadecimal floating-point
	   string, returning a pointer to a static internal buffer which will be
	   OVERWRITTEN on the next call.  The conversion is defined by the
	   description of the fprintf() %A and %a format items in

		``ISO/IEC 9899:1999 (E) Programming languages -- C'', Section
		7.19.6.1, p. 278:

	``a,A	A double argument representing a floating-point number is
		converted in the style [-]0xh.hhhhp+-d, where there is one
		hexadecimal digit (which is nonzero if the argument is a
		normalized floating-point number and is otherwise unspecified)
		before the decimal-point character
			[Footnote 235: Binary implementations can choose the
			hexadecimal digit to the left of the decimal-point
			character so that subsequent digits align to nibble
			(4-bit) boundaries.]
		and the number of hexadecimal digits after it is equal to the
		precision; if the precision is missing and FLT_RADIX is a power
		of 2, then the precision is sufficient for an exact
		representation of the value; if the precision is missing and
		FLT_RADIX is not a power of 2, then the precision is sufficient
		to distinguish
			[Footnote 236: The precision p is sufficient to
			distinguish values of the source type if 16^(p-1) > b^n
			where b is FLT_RADIX and n is the number of base-b
			digits in the significand of the source type. A smaller
			p might suffice depending on the implementation's scheme
			for determining the digit to the left of the
			decimal-point character.]
		values of type double, except that trailing zeros may be
		omitted; if the precision is zero and the # flag is not
		specified, no decimal point character appears. The letters
		abcdef are used for %a conversion and the letters ABCDEF for %A
		conversion. The A conversion specifier produces a number with X
		and P instead of x and p. The exponent always contains at least
		one digit, and only as many more digits as necessary to
		represent the decimal exponent of 2. If the value is zero, the
		exponent is zero.

		A double argument representing an infinity or NaN is converted
		in the style of an f or F conversion specifier.

		... ''

	   In this implementation, we choose to trim trailing zeros, leaving at
	   least one digit following the hexadecimal point.   We also make a
	   distinction between quiet and signalling NaNs, and include the
	   sign of the NaN. */

#if defined(HAVE_IEEE_754)
	/* This implementation requires knowledge of low-level formatting of
	   IEEE 754 64-bit floating-point data:

	bit:	6666555555555544444444443333333333222222222211111111110000000000
		3210987654321098765432109876543210987654321098765432109876543210
	data:	seeeeeeeeeeeffffffffffffffffffffffffffffffffffffffffffffffffffff
		|           ----------------------------------------------------
		|-----------                         |--significand
		|    |--exponent
		|--sign

	The binary point occurs before the significand, after the hidden bit,
	which is nonzero if the number is normalized, and zero otherwise. */

	static char s[sizeof("-0xd.ffffffffffffffffffffffffffffp+ddddd")];
	fp_t signif;
	FP_Parts d;
	int expon;

	int big_endian = IsBigEndian();

	if (IsNaN(x))
		return (NaN_string(x));
	else if (IsInf(x))
		return (Inf_string(x));
	else if (x == FP(0.0))
		return ("0");
	else
	{
		char *last;
		signif = Significand(x);
		expon = (int)Exponent(x);
		d.v = signif;

#if defined(HAVE_FP_T_DOUBLE)
		{
			unsigned int hi, lo;

			hi = d.i[1-big_endian];
			lo = d.i[big_endian];

			SNPRINTF7(s, sizeof(s), "%s0x%d.%05x%08x",
					((x < FP(0.0)) ? "-" : "+"),
					1, /* (int)IsNormal(x), */
					(0x000fffff & hi),
					lo);
		}
#endif

#if defined(HAVE_FP_T_QUADRUPLE)
		if (sizeof(d) == sizeof(d.v))	/* 128-bit */
		{
			if (big_endian)	/* 128-bit big endian */
				SNPRINTF9(s, sizeof(s), "%s0x%d.%04x%08x%08x%08x",
						((x < FP(0.0)) ? "-" : "+"),
						1, /* (int)IsNormal(x), */
						(0x0000ffff & d.i[0]),
						d.i[1], d.i[2], d.i[3]);
			else		/* 128-bit little endian */
				SNPRINTF9(s, sizeof(s), "%s0x%d.%04x%08x%08x%08x",
						((x < FP(0.0)) ? "-" : "+"),
						1, /* (int)IsNormal(x), */
						(0x0000ffff & d.i[3]),
						d.i[2], d.i[1], d.i[0]);
		}
		else if (sizeof(fp_t) == sizeof(double)) /* long double masquerading as double */
		{
			unsigned int hi, lo;

			hi = d.i[1-big_endian];
			lo = d.i[big_endian];

			SNPRINTF7(s, sizeof(s), "%s0x%d.%05x%08x",
					((x < FP(0.0)) ? "-" : "+"),
					1, /* (int)IsNormal(x), */
					(0x000fffff & hi),
					lo);
		}
		else				/* 80-bit Intel x86 format */
		{
			SNPRINTF7(s, sizeof(s), "%s0x%d.%08x%08x",
					((x < FP(0.0)) ? "-" : "+"),
					(d.i[1] >> 31),
					((d.i[1] << 1) | (d.i[0] >> 31)),
					(d.i[0] << 1));
		}
#endif

#if defined(HAVE_FP_T_SINGLE)
		SNPRINTF6(s, sizeof(s), "%s0x%d.%06x",
				((x < FP(0.0)) ? "-" : "+"),
				1, /* (int)IsNormal(x), */
				((0x007fffff & d.i[0]) << 1));
#endif

		/* Trim trailing zeros */
		last = strchr(s,'\0') - 1;
		while ((last[0] == '0') && (last[-1] != '.'))
			last--;

		SNPRINTF5(last + 1, (sizeof(s) - (last + 1 - s)),
				"p%s%d",
				((expon < 0) ? "-" : "+"),
				((expon < 0) ? -expon : expon));
	}
#else /* NOT defined(HAVE_IEEE_754) */
	/* cannot fiddle bits without further details, so fall back to decimal output */
	static char s[sizeof("-1.234567890123456789012345678901234567890E+dddd")];
#if defined(HAVE_FP_T_QUADRUPLE)
	SNPRINTF5(s, sizeof(s), "%.*Lg", default_precision(), (fp_t)x);
#else
	SNPRINTF5(s, sizeof(s), "%.*g", default_precision(), (double)x);
#endif
#endif /* defined(HAVE_IEEE_754) */

	return ((const char*)&s[0]);
}

static const char *
xinttos(fp_t x)
{
	/* Convert x to a hexadecimal integer, if this is exactly
	   representable, and otherwise, to a hexadecimal
	   floating-point value. */

	/* TO DO: Reimplement this code without requiring an integer
	   data type; that will allow increasing maxint to 2^23 - 1
	   (32-bit), 2^53 - 1 (64-bit), 2^64 - 1 (80-bit), and 2^113 - 1
	   (128-bit).  This increases maxint only for the 128-bit
	   case. */

#if defined(HAVE_IEEE_754)

	UNSIGNED_LONG_LONG n;
	fp_t xabs;

	static fp_t maxint = FP(0.0);

	if (maxint == FP(0.0))	      /* happens only on first call */
	{

#if defined(HAVE_LONG_LONG)

#if defined(HAVE_FP_T_DOUBLE)
		maxint = FP(9007199254740991.0); /* 2^53 - 1 */
#endif

#if defined(HAVE_FP_T_QUADRUPLE)
		maxint = FP(18446744073709551615.0); /* 2^64 - 1 */
#endif

#if defined(HAVE_FP_T_SINGLE)
		maxint = FP(16777215.0);	/* 2^24 - 1 */
#endif

#else /* NOT defined(HAVE_LONG_LONG) */

#if defined(HAVE_FP_T_SINGLE)
		maxint = FP(16777215.0);	/* 2^24 - 1 */
#else
		maxint = FP(4294967295.0);	/* 2^32 - 1 */
#endif

#endif /* defined(HAVE_LONG_LONG) */

	}

	if (IsNaN(x))
		return (xfptos(x));
	else if (IsInf(x))
		return (xfptos(x));
	else if ((x < -maxint) || (maxint < x))
		return (xfptos(x));	/* not representable as integer */
	else
	{
		static char buffer[sizeof("-0xhhhhhhhhhhhhhhhh")]; /* space for 64-bit value */
		char *p;

		xabs = (x < 0) ? -x : x;
		n = (UNSIGNED_LONG_LONG)xabs;	/* exact conversion */
		p = &buffer[elementsof(buffer)-1];
		*p-- = '\0';
		while (p >= &buffer[2])	/* leave room for "-0x" */
		{
			static const char hexchars[] = "0123456789abcdef";

			*p-- = hexchars[n & 0xf];
			n >>= 4;
			if (n == 0)
				break;
		}
		*p-- = 'x';
		*p-- = '0';
		if (x < 0)
			*p = '-';
		else
			*p = '+';
		return ((const char*)p);
	}
#else	/* NOT defined(HAVE_IEEE_754) */
	/* Use fallback of hexadecimal floating-point for now, but
	   ultimately, special case code is needed here for other
	   floating-point systems. */
	return (xfptos(x));
#endif	/* defined(HAVE_IEEE_754) */

}

#define XSTRTOD_FAILURE (FP(0.0))	/* mandated by C89 and C99 (*endptr disambiguates) */

fp_t
xstrtod(const char* s, char **endptr)
{	/* Convert C99 hexadecimal floating-point string
		   "[-+]?0[Xx][0-9A-Fa-z]*(.[0-9A-Fa-z])?[Pp][-+]?[0-9]+"
	   to floating-point. */
	fp_t d;
	int digit;
	int binary_power;
	int nfract;
	int nsign;

	while (isspace(*s))
		++s;
	if (*s == '-')
	{
		s++;
		nsign = -1;
	}
	else if (*s == '+')
	{
		s++;
		nsign = 1;
	}
	else
		nsign = 1;

	if (strncmp(s,"0x",2) != 0)
	{
		if (endptr != (char**)NULL)
			*endptr = (char*)s;
		return (XSTRTOD_FAILURE);
	}
	s += 2;
	for (d = FP(0.0); (digit = hexval(*s), digit) >= 0; ++s)
		d = FP(16.0) * d + (fp_t)digit;
	nfract = 0;
	if (*s == '.')
	{
		s++;
		for ( ; (digit = hexval(*s), digit) >= 0; ++s, ++nfract)
			d = FP(16.0) * d + (fp_t)digit;
	}
	binary_power = 0;
	if ((*s == 'p') || (*s == 'P'))
	{
		int exponent_sign;
		int n_exponent_digits;

		++s;
		if (*s == '-')
		{
			s++;
			exponent_sign = -1;
		}
		else if (*s == '+')
		{
			s++;
			exponent_sign = 1;
		}
		else
			exponent_sign = 1;

		for (n_exponent_digits = 0; (digit = decval(*s), digit) >= 0; ++s, n_exponent_digits++)
			binary_power = 10 * binary_power + digit;
		if (n_exponent_digits == 0)
		{
			if (endptr != (char**)NULL)
				*endptr = (char*)s;
			return (XSTRTOD_FAILURE);
		}
		if (exponent_sign < 0)
			binary_power = -binary_power;
	}
	d = ldexp(d, -4 * nfract + binary_power);
	if (endptr != (char**)NULL)
		*endptr = (char*)s;
	return ((nsign < 0) ? -d : d);
}
@


1.18
log
@Add new concat6() function.
@
text
@d590 1
a590 1
StoN(const char *s)
@


1.17
log
@Fix stupid error in Hex(): I forgot to include the decimal value
of x in the output string.
@
text
@d25 1
d86 18
d910 1
a910 1
const char *
@


1.16
log
@Add new functions: Abort(), FtoS(), Hex(), Hexfp(), Hexint(), Index(),
Length(), StoN(), and Substr().
@
text
@d251 1
a251 1
	return (concat3(buffer," == ",xfptos(x)));
@


1.15
log
@Change builtin string functions to return dynamic strings.  Change
string equality tests to use STREQUAL().
@
text
@d27 7
d195 6
d215 51
d411 9
d426 6
d570 6
d663 31
@


1.14
log
@Add new functions FtoH(), HtoF(), and htou().
@
text
@d110 1
a110 1
	return ("");			/* NOT REACHED */
d146 1
a146 1
{	/* native floating-point to hexadecimal */
d439 1
a439 1
	return ("");
d443 1
a443 1
protect(const char *s)
d544 1
a544 1
	if ((strcmp(t,"nan") == 0) || (strncmp(t,"nan(",4) == 0))
d546 1
a546 1
	else if ((strcmp(t,"qnan") == 0) || (strncmp(t,"qnan(",5) == 0))
d548 1
a548 1
	else if ((strcmp(t,"snan") == 0) || (strncmp(t,"snan(",5) == 0))
d550 1
a550 1
	else if ((strcmp(t,"inf") == 0) || (strcmp(t,"infinity") == 0))
@


1.13
log
@Rewrite one line of Char() to avoid getting incorrect results on IBM
AIX 4.2 with g++ 2.95.3.
@
text
@d24 2
d94 1
a94 1
	/* NB: (char)(unsigned char)n produced incorrect results on 
d145 43
d219 123
@


1.12
log
@Add new Char() and Ichar() functions.
@
text
@d92 3
a94 1
	s[0] = (char)n;
@


1.11
log
@Change calls to is_match() to match(), and rename prefix to pattern,
so that printenv(), save(), and who() are generalized to support
UNIX-shell-style patterns instead of simple prefixes.

Add protecting "&& !defined(HAVE_STRTOLD)" to preprocessor wrapper
around strtold().  Ours calls sscanf(), and the HP/Compaq/DEC Alpha
OSF/1 sscanf() calls strtold(), producing an infinite loop and stack
overflow without this protection.
@
text
@d89 8
d171 6
@


1.10
log
@Remove (void) cast on SNPRINTFn() calls, since they now expand into
do {...} while (0).
Correct size of buffer in xfptos(): it was too small for quadruple-precision
numbers.
@
text
@d186 1
a186 1
Printenv(const char *prefix)
d190 3
a192 1
	size_t len_prefix;
d198 5
a202 3
	if (prefix == (const char *)NULL)
		prefix = "";
	len_prefix = strlen(prefix);
d208 7
a214 1
		if (strncmp((const char *)*p,prefix,len_prefix) == 0)
d216 1
d218 3
d224 1
d236 7
a242 1
		if (strncmp(*p,prefix,len_prefix) == 0)
a243 2
			equals = strchr(*p,'=');
			*equals = '\0';
d247 2
a248 2
			prtext("\"\n");
			*equals = '=';
d250 1
d307 1
a307 1
#if defined(HAVE_FP_T_QUADRUPLE)
@


1.9
log
@Add simple implementation (interface to sscanf()) of strtold() when
it is not available on the local system.

Fix bug: strtod() was used instead of strtold() for string-to-number
conversions when quadruple precision was configured.
@
text
@d254 1
a254 1
			(void)SNPRINTF4(p, len_protected_s - (p - protected_s),
d260 1
a260 1
			(void)SNPRINTF4(p, len_protected_s - (p - protected_s),
d271 1
a271 1
			(void)SNPRINTF4(p, len_protected_s - (p - protected_s),
d467 1
a467 1
	static char s[sizeof("-0xd.ffffffffffffffffp+dddd")];
d494 1
a494 1
			(void)SNPRINTF7(s, sizeof(s), "%s0x%d.%05x%08x",
d506 1
a506 1
				(void)SNPRINTF9(s, sizeof(s), "%s0x%d.%04x%08x%08x%08x",
d512 1
a512 1
				(void)SNPRINTF9(s, sizeof(s), "%s0x%d.%04x%08x%08x%08x",
d525 1
a525 1
			(void)SNPRINTF7(s, sizeof(s), "%s0x%d.%05x%08x",
d533 1
a533 1
			(void)SNPRINTF7(s, sizeof(s), "%s0x%d.%08x%08x",
d542 1
a542 1
		(void)SNPRINTF6(s, sizeof(s), "%s0x%d.%06x",
d553 1
a553 1
		(void)SNPRINTF5(last + 1, (sizeof(s) - (last + 1 - s)),
d562 1
a562 1
	(void)SNPRINTF5(s, sizeof(s), "%.*Lg", default_precision(), (fp_t)x);
d564 1
a564 1
	(void)SNPRINTF5(s, sizeof(s), "%.*g", default_precision(), (double)x);
@


1.8
log
@Change sprintf() references to SNPRINTFn().
@
text
@d254 1
a254 1
			(void)SNPRINTF4(p, len_protected_s - (p - protected_s), 
d260 1
a260 1
			(void)SNPRINTF4(p, len_protected_s - (p - protected_s), 
d271 1
a271 1
			(void)SNPRINTF4(p, len_protected_s - (p - protected_s), 
d287 20
d356 4
d362 1
d553 1
a553 1
		(void)SNPRINTF5(last + 1, (sizeof(s) - (last + 1 - s)), 
@


1.7
log
@Add code to handle the case of long double masquerading as double.
@
text
@d12 1
a12 1
#include <stdio.h>			/* for sprintf() prototype */
d246 1
d248 2
a249 1
	protected_s = (char*)emalloc(4*strlen(s) + 1); /* for \ooo worst-case expansion */
d254 2
a255 1
			(void)sprintf(p, "\\%c", (unsigned int)UC(outputtab[q-inputtab]));
d260 2
a261 1
			(void)sprintf(p, "\\%c", (unsigned int)UC(*s));
d265 4
a268 1
			*p++ = *s;
d271 2
a272 1
			(void)sprintf(p, "\\%03o", (unsigned int)UC(*s));
d469 5
a473 5
			(void)sprintf(s, "%s0x%d.%05x%08x",
				      ((x < FP(0.0)) ? "-" : "+"),
				      1, /* (int)IsNormal(x), */
				      (0x000fffff & hi),
				      lo);
d481 5
a485 5
				(void)sprintf(s, "%s0x%d.%04x%08x%08x%08x",
					      ((x < FP(0.0)) ? "-" : "+"),
					      1, /* (int)IsNormal(x), */
					      (0x0000ffff & d.i[0]),
					      d.i[1], d.i[2], d.i[3]);
d487 5
a491 5
				(void)sprintf(s, "%s0x%d.%04x%08x%08x%08x",
					      ((x < FP(0.0)) ? "-" : "+"),
					      1, /* (int)IsNormal(x), */
					      (0x0000ffff & d.i[3]),
					      d.i[2], d.i[1], d.i[0]);
d500 5
a504 5
			(void)sprintf(s, "%s0x%d.%05x%08x",
				      ((x < FP(0.0)) ? "-" : "+"),
				      1, /* (int)IsNormal(x), */
				      (0x000fffff & hi),
				      lo);
d508 5
a512 5
			(void)sprintf(s, "%s0x%d.%08x%08x",
				      ((x < FP(0.0)) ? "-" : "+"),
				      (d.i[1] >> 31),
				      ((d.i[1] << 1) | (d.i[0] >> 31)),
				      (d.i[0] << 1));
d517 4
a520 4
		(void)sprintf(s, "%s0x%d.%06x",
			      ((x < FP(0.0)) ? "-" : "+"),
			      1, /* (int)IsNormal(x), */
			      ((0x007fffff & d.i[0]) << 1));
d528 4
a531 3
		(void)sprintf(last + 1, "p%s%d",
			      ((expon < 0) ? "-" : "+"),
			      ((expon < 0) ? -expon : expon));
d537 1
a537 1
	(void)sprintf(s,"%.*Lg", default_precision(), (fp_t)x);
d539 1
a539 1
	(void)sprintf(s,"%.*g", default_precision(), (double)x);
@


1.6
log
@Add support for three precisions.  Add FP() wrappers on floating-point
constants.  Rename xdbltos() to xfptos().
@
text
@d470 23
a492 2
		if (big_endian)
			(void)sprintf(s, "%s0x%d.%04x%08x%08x%08x",
d495 3
a497 8
				      (0x0000ffff & d.i[0]),
				      d.i[1], d.i[2], d.i[3]);
		else if (sizeof(d) == sizeof(d.v))	/* 128-bit little endian */
			(void)sprintf(s, "%s0x%d.%04x%08x%08x%08x",
				      ((x < FP(0.0)) ? "-" : "+"),
				      1, /* (int)IsNormal(x), */
				      (0x0000ffff & d.i[3]),
				      d.i[2], d.i[1], d.i[0]);
@


1.5
log
@Move several functions into new file, io.c.
@
text
@d173 2
a174 1
		return ((Copysign(1.0,x) * Copysign(1.0,NaN()) == -1.0) ? "-SNaN" : "+SNaN");
d176 2
a177 1
		return ((Copysign(1.0,x) * Copysign(1.0,NaN()) == -1.0) ? "-QNaN" : "+QNaN");
d179 2
a180 1
		return ((Copysign(1.0,x) * Copysign(1.0,NaN()) == -1.0) ? "-NaN" : "+NaN");
d367 1
a367 1
xdbltos(fp_t x)
d435 2
a436 2
	double signif;
	DoubleParts d;
a437 1
	unsigned int hi, lo;
d445 1
a445 1
	else if (x == 0.0)
a452 2
		hi = d.i[1-big_endian];
		lo = d.i[big_endian];
d454 41
a494 2
		(void)sprintf(s, "%s0x%d.%05x%08x",
			      ((x < 0.0) ? "-" : "+"),
d496 2
a497 2
			      (0x000fffff & hi),
			      lo);
d508 2
a509 1
#else /* cannot fiddle bits without further details, so fall back to decimal output */
d511 5
a515 1
	(void)sprintf(s,"%.17lg",(double)x);	/* use %.35lg for 128-bit precision */
d528 6
d536 26
a561 2
#if (HAVE_LONG_LONG)
#define MAXINT	9007199254740991.0	/* 2^53 - 1 */
d563 1
a563 1
#define MAXINT	4294967295.0		/* 2^32 - 1 */
d566 3
a568 2
	UNSIGNED_LONG_LONG n;
	fp_t xabs;
d571 1
a571 1
		return (xdbltos(x));
d573 3
a575 3
		return (xdbltos(x));
	else if ( (x < -MAXINT) || (MAXINT < x) || (x != Nint(x)) )
		return (xdbltos(x));	/* not representable as integer */
d578 1
a578 1
		static char buffer[sizeof("-0xhhhhhhhhhhhhhh")];
d606 1
a606 1
	return (xdbltos(x));
d611 1
a611 1
#define XSTRTOD_FAILURE (0.0)	/* mandated by C89 and C99 (*endptr disambiguates) */
d646 2
a647 2
	for (d = 0.0; (digit = hexval(*s), digit) >= 0; ++s)
		d = 16.0 * d + (fp_t)digit;
d653 1
a653 1
			d = 16.0 * d + (fp_t)digit;
@


1.4
log
@Add new functions EndInput() and Exit(), needed to support the
new endinput() and exit(reason) functions.
@
text
@a1 1
#include "y.tab.h"
d4 1
a4 1
#include <ctype.h>
d8 1
a8 1
#include <math.h>
d12 1
a12 1
#include <stdio.h>
a18 14
#if defined(HAVE_TIME_H)
#include <time.h>
#endif

#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif

#include "readline.h"

#if !defined(F_OK)
#define	F_OK	0		/* Test for file existence: access(filename, F_OK) */
#endif

a20 5
#define FILE_EXISTS(filename) ((int)access((const char*)(filename), F_OK) == 0)

FILE *fplog = (FILE*)NULL;

extern const char *current_filename;	/* defined in hoc.y */
d22 1
a22 16
extern FILE *fin;			/* defined in hoc.y */
extern int load_enabled;		/* defined in hoc.y */
extern int logfile_enabled;		/* defined in hoc.y */
extern int save_enabled;		/* defined in hoc.y */

static void 		save_symbols ARGS((FILE *, const char *));
EXTERN int		cmpsym ARGS((const void *, const void *));

#if defined(__cplusplus) || defined(c_plusplus)
extern "C"
#endif
int
cmpstr(const void *v1, const void *v2)
{
	return (strcmp(*(const char **)v1,*(const char **)v2));
}
a88 7
EndInput(void)
{
	EOF_flag = 1;
	return ("");
}

const char *
d102 31
a169 78
Load(const char *filename)
{
	FILE *old_fin;
	const char *old_current_filename;

	if (filename == (const char*)NULL) /* should never happen, but keeps lint happy */
		return ("");

	if (!load_enabled)
		return (msg_translate("load() command is disabled"));

	old_fin = fin;
	old_current_filename = dupstr(current_filename);
	fin = fopen(filename,"r");
	if (fin == (FILE*)NULL)
	{
		(void)fprintf(stderr,  msg_translate("%s: can't open %s\n"),
			      progname, filename);
		fin = old_fin;
		return(msg_translate("load() open failed"));
	}
	irl_push_input();
	set_filename(filename);
	run();
	set_filename(old_current_filename);
	irl_pop_input();
	efree((void*)old_current_filename);
	fin = old_fin;
	return ("");
}

const char *
Logfile(const char *filename)
{	/* close any open log file, open new one (error if it exists, for security reasons) */
	static const char *old_logfilename = "";

	if (filename == (char*)NULL)
		return ("");

	if (!logfile_enabled)
		return (msg_translate("logfile() command is disabled"));

	if (FILE_EXISTS(filename) &&
	    (strcmp(filename,"/dev/tty") != 0) &&
	    (strcmp(filename,"") != 0))
		execerror("logfile() will not overwrite existing file", filename);

	if ((fplog != (FILE*)NULL) && (strcmp(old_logfilename,"") != 0))
		(void)fclose(fplog);

	if (strcmp(filename,"") == 0)
		fplog = stdout;
	else
		fplog = fopen(filename,"w");

	if (fplog == (FILE*)NULL)
		execerror("logfile() open failed", filename);

	old_logfilename = dupstr(filename);
	logfile_enabled = 1;
	return ("");
}

const char *
Logoff(void)
{
	logfile_enabled = 0;
	return ("");
}

const char *
Logon(void)
{
	logfile_enabled = 1;
	return ("");
}

const char *
d235 1
a235 1
static const char *
d241 1
a241 1
	static const char inputtab[]  = "\a\b\f\n\r\t\v\033";
a271 3
	const char *oldval;

	oldval = Getenv(envvar);	/* NB: NOT getenv()! ... see Getenv() comments */
d273 1
a273 158
	return (oldval);
}

const char *
Save(const char *filename, const char *prefix)
{
	/* open new save file (error if it exists, for security reasons) */
	FILE *fpsave;

	if (filename == (char*)NULL)
		return ("");

	if (!save_enabled)
		return (msg_translate("save() command is disabled"));

	if (FILE_EXISTS(filename) && (strcmp(filename,"/dev/tty") != 0))
		execerror("save() will not overwrite existing file", filename);
	if (strcmp(filename,"") == 0)
		fpsave = stdout;
	else
		fpsave = fopen(filename,"w");
	if (fpsave == (FILE*)NULL)
		execerror("save() open failed", filename);

	if (prefix == (const char*)NULL)
		prefix = "";

	(void)fprintf(fpsave, "### -*-hoc-*-\n");
	(void)fprintf(fpsave, "### ====================================================================\n");
	(void)fprintf(fpsave, msg_translate("### This is hoc save file %s\n"), filename);
	if (*prefix)
		(void)fprintf(fpsave,
			      msg_translate("### WARNING: This file contains only symbols prefixed by \"%s\"\n"),
			      prefix);
	(void)fprintf(fpsave, msg_translate("### Creator:           %s version %s [%s]\n"),
		      PACKAGE_NAME, PACKAGE_VERSION, PACKAGE_DATE);
	(void)fprintf(fpsave, msg_translate("### CreationDate:      %s\n"), Now());
	(void)fprintf(fpsave, msg_translate("### PackageBugReports: %s\n"), PACKAGE_BUGREPORT);
	(void)fprintf(fpsave, "### ====================================================================\n\n");
	save_symbols(fpsave,prefix);
	if (strcmp(filename,"") != 0)
		(void)fclose(fpsave);
	return ("");
}

static void
save_symbols(FILE *fpsave, const char *prefix)
{
	Symbol **symtab;
	Symbol *sp;
	const char *p;
	fp_t d;
	int old_precision;
	size_t k;
	size_t max_symbols;
	size_t n_symtab;

	old_precision = get_precision();
	(void)set_precision(default_precision());

	max_symbols = 0;
	for (sp = first_symbol(); sp != (Symbol *)NULL; sp = next_symbol())
		max_symbols++;

	symtab = (Symbol**)emalloc(max_symbols * sizeof(Symbol*));

	/* First build a table of matching symbols that we can later sort */
	for (n_symtab = 0, sp = first_symbol(); sp != (Symbol *)NULL; sp = next_symbol())
	{
		if ((sp->name != (const char*)NULL) &&
		    *sp->name &&
		    (n_symtab < max_symbols) &&
		    !is_hidden(sp->name,prefix) &&
		    is_match(sp->name,prefix))
			symtab[n_symtab++] = sp;
	}

	qsort(symtab, n_symtab, sizeof(Symbol*), cmpsym);
	for (k = 0; k < n_symtab; ++k)
	{
		if (strncmp("__",symtab[k]->name,2) == 0)
			continue;	/* never save internal symbols! */

		/* TO-DO: What we really need here is a test for
		   predefined, NOT immutable.  However, the symbol
		   table does not yet contain that information, so for
		   now, we just assume immutable means built-in, which
		   is not true in general. */
		if (symtab[k]->immutable)
			continue;	/* never save immutable symbols! */

		switch(symtab[k]->type)
		{
		case BLTIN0:		/* FALL THROUGH */
		case BLTIN1:		/* FALL THROUGH */
		case BLTIN2:		/* FALL THROUGH */
		case HEX:		/* FALL THROUGH */
		case STRBLTIN0:		/* FALL THROUGH */
		case STRBLTIN1:		/* FALL THROUGH */
		case STRBLTIN2:
			break;		/* ignore all built-in functions and procedures */

		case NUMBER:		/* FALL THROUGH */
		case VAR:
			if (strcmp("_",symtab[k]->name) == 0)
				break;	/* skip _: last numeric result printed */
#if 0
			(void)fprintf(fpsave, "### DEBUG: name = %s\ttype = %d\n",
				      symtab[k]->name, symtab[k]->type);
#endif
			(void)fprintf(fpsave, "%-23s", symtab[k]->name);
			/* Special handling of PREC: we changed its value! */
			d = (strcmp("PREC", symtab[k]->name) == 0) ?
				(fp_t)old_precision : symtab[k]->u.val;
			(void)fprintf(fpsave, "\t%s",(symtab[k]->immutable ? ":=" : "="));
			if (Nint(d) == d)
				(void)fprintf(fpsave, " %s\n", fmtnum(d));
			else
				(void)fprintf(fpsave, " %s\t# %s\n", xdbltos(d), fmtnum(d));
			break;

		case STRING:		/* FALL THROUGH */
		case STRVAR:
#if 0
			(void)fprintf(fpsave, "### DEBUG: name = %s\ttype = %d\n",
				      symtab[k]->name, symtab[k]->type);
#endif
			(void)fprintf(fpsave, "%-23s", symtab[k]->name);
			p = protect(symtab[k]->u.str);
			(void)fprintf(fpsave, "\t%s \"%s\"\n",
				      (symtab[k]->immutable ? ":=" : "="), p);
			efree((void*)p);
			break;

		case FUNCTION:		/* FALL THROUGH */
#if 0
			(void)fprintf(fpsave, "### DEBUG: name = %s\ttype = %d\n",
				      symtab[k]->name, symtab[k]->type);
			(void)fprintf(fpsave, "### NOT-YET-IMPLEMENTED: func %s(){...}\n",
				      symtab[k]->name);
#endif
			break;

		case PROCEDURE:
#if 0
			(void)fprintf(fpsave, "### DEBUG: name = %s\ttype = %d\n",
				      symtab[k]->name, symtab[k]->type);
			(void)fprintf(fpsave, "### NOT-YET-IMPLEMENTED: proc %s(){...}\n",
				      symtab[k]->name);
#endif
			break;

		default:
			break;
		}
	}

	(void)set_precision(old_precision);
d471 1
a471 1
	sprintf(s,"%.17lg",(double)x);	/* use %.35lg for 128-bit precision */
@


1.3
log
@Remove declaration of unused variable eos.
@
text
@d124 20
@


1.2
log
@Add new function, strton(), to work like strtod(), but to
guarantee correct handling of Inf, Infinity, NaN, QNaN, and
SNaN.  The code for this already existed in code.c:str_to_num(),
but has been replaced there by a call to this function.
@
text
@a507 1
	const char *eos;
@


1.1
log
@Initial revision
@
text
@d505 62
@
