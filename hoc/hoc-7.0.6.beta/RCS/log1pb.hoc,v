head	1.3;
access;
symbols;
locks
	beebe:1.3; strict;
comment	@# @;


1.3
date	2002.08.06.13.35.52;	author beebe;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.11.02.33.34;	author beebe;	state Exp;
branches;
next	1.1;

1.1
date	2001.12.11.15.19.28;	author beebe;	state Exp;
branches;
next	;


desc
@Original version.
@


1.3
log
@Update to used named, rather than numbered, function/procedure
arguments.
@
text
@### -*-hoc-*-
### /usr/local/src/hoc/hoc-7.0.0.beta/log1pb.hoc, Sat Dec  8 14:51:02 2001
### Edit by Nelson H. F. Beebe <beebe@@math.utah.edu>
### ====================================================================
### Provide an implementation of, and test package for, Logp1(x).  This
### is the second trial implementation, using a Taylor series expansion
### for ln((z+1)/(z-1)).
### [08-Dec-2001]
### ====================================================================

func Log1p(x) \
{
	### Compute Log1p(x) = ln(1 + x) accurately.  The cutoffs at
	### which at least one bit is lost in substraction were
	### accurately determined in Maple with this code:
	###
	###	Digits := 50;
	###	g := proc(x) return (evalf(log(1 + x))); end proc;
	###	plot(g(x), x = -0.5..0.5);
	###	fsolve(g(x) = -0.5, x, -0.5..0);
	###	        -.39346934028736657639620046500881954655808186451281
	###	fsolve(g(x) = 0.5, x, 0..1);
	###		.64872127070012814684865078781416357165377610071015
	###
	### For small values between the cutoffs, we use the Taylor
	### series expansion, adding terms until they are small enough
	### to be ignored.
	###
	### The ___test_log1p() function produces output that looks like
	### this (on a Sun Solaris 2.7 system, using the vendor's native
	### expm1() function for comparison):
	###
	###     x               # terms         error in Log1p(x)       Ulps
	###     -0.4            0               0                       0
	###     -0.35           13              -5.55e-17              -0.25
	###     -0.3            11              0                       0
	###     -0.25           10              5.55e-17                0.25
	###     -0.2            9               0                       0
	###     -0.15           8               2.78e-17                0.125
	###     -0.1            7               1.39e-17                0.0625
	###     -0.05           6               6.94e-18                0.0312
	###     -6.94e-17       2               0                       0
	###     0.05            6               6.94e-18                0.0312
	###     0.1             7               0                       0
	###     0.15            8               -2.78e-17              -0.125
	###     0.2             9               0                       0
	###     0.3             10              -5.55e-17              -0.25
	###     0.4             11              0                       0
	###     0.45            12              1.11e-16                0.5
	###     0.55            13              5.55e-17                0.25
	###     0.65            0               -1.11e-16              -0.5
	###
	###     -0.393          14              0                       0
	###     0.649           14              -5.55e-17              -0.25
	###
	### Thus, we need from 1 (x near 0) to 14 (x near cutoffs)
	### terms of the Taylor series.  A polynomial appoximation
	### would be faster, and more efficient, but this code is
	### simple and acceptable for now.

	global k, xcutneg, xcutpos
	k = 0

	### Give names to the cutoff values:
	xcutneg = -0.39346934028736657639620046500881954655808186451281
	xcutpos = +0.64872127070012814684865078781416357165377610071015

	### Handle easy special cases first:
	if (isnan(x)) \
		return (x) \
	else if (x == 0) \
		return (0) \
	else if (x >= xcutpos) \
		return (log(1 + x)) \
	else if (x <= xcutneg) \
		return (log(1 + x)) \

	### Use Taylor series expansion (Abramowitz and Stegun, NBS#55, 4.1.28) for
	### ln((z+1)/(z-1)) = 2(1/z + 1/(3z^3) + 1/(5z^5) + ...)
	### With 1+x = (z+1)/(z-1), we find z = (1 + 2/x) and 1/z = x/(2 + x).
	k = 1
	sum = 0
	one_over_z = x/(2 + x)
	one_over_z_sq = one_over_z * one_over_z
	one_over_z_to_2km1 = one_over_z
	term = one_over_z_to_2km1
	while ((sum + term) != sum) \
	{
		sum += term
		k++
		one_over_z_to_2km1 *= one_over_z_sq
		term = one_over_z_to_2km1 / (2*k - 1)
		## print k, term, sum
		## print "\n"
	}
	sum *= 2
	return (sum)
}

func ___log1p_err() return (Log1p($1) - log1p($1))

proc ___test_log1p_print() \
{
	global xx, k, e, epsilon
	printf "%7.2e\t%7d\t%15.2e\t%15.2f\n", xx, k, e, e/epsilon
}

proc ___test_log1p() \
{
	global xx, k, e, epsilon
	k = 0
	epsilon = macheps(1)
	PREC = 3
	print "x\t\t# terms\t\terror in Log1p(x)\tUlps\n"
	last_k = -1
	for (xx = -0.4; xx < 0.7; xx += 0.05) \
	{
		e = ___log1p_err(xx)
		if (k != last_k) ___test_log1p_print()
		last_k = k
	}
	xx = xcutneg + epsilon
	e = ___log1p_err(xx)
	___test_log1p_print()

	xx = xcutpos - epsilon
	e = ___log1p_err(xx)
	___test_log1p_print()
}

proc help_Log1p() \
{
	print "\tLog1p(x) returns log(1 + x), but without accuracy loss for\n"
	print "\tsmall |x|.  x must be in (-1.0,infinity].\n\n"
}
@


1.2
log
@Change double underscore to triple underscore to make those
variables hidden.
@
text
@d11 1
a11 1
func Log1p() \
d61 2
a62 2
	___x = $1
	___k = 0
d65 2
a66 2
	___xcutneg = -0.39346934028736657639620046500881954655808186451281
	___xcutpos = +0.64872127070012814684865078781416357165377610071015
d69 3
a71 3
	if (isnan(___x)) \
		return (___x) \
	else if (___x == 0) \
d73 4
a76 4
	else if (___x >= ___xcutpos) \
		return (log(1 + ___x)) \
	else if (___x <= ___xcutneg) \
		return (log(1 + ___x)) \
d81 7
a87 7
	___k = 1
	___sum = 0
	___one_over_z = ___x/(2 + ___x)
	___one_over_z_sq = ___one_over_z * ___one_over_z
	___one_over_z_to_2km1 = ___one_over_z
	___term = ___one_over_z_to_2km1
	while ((___sum + ___term) != ___sum) \
d89 5
a93 5
		___sum += ___term
		___k++
		___one_over_z_to_2km1 *= ___one_over_z_sq
		___term = ___one_over_z_to_2km1 / (2*___k - 1)
		## print ___k, ___term, ___sum
d96 2
a97 2
	___sum *= 2
	return (___sum)
d104 2
a105 8
	print ___xx
	print "\t\t"
	print ___k
	print "\t\t"
	print ___e
	print "\t\t"
	print ___e/___macheps
	print "\n"
d110 3
a112 2
	___k = 0
	___macheps = macheps(1)
d115 2
a116 2
	___last_k = -1
	for (___xx = -0.4; ___xx < 0.7; ___xx += 0.05) \
d118 3
a120 3
		___e = ___log1p_err(___xx)
		if (___k != ___last_k) ___test_log1p_print()
		___last_k = ___k
d122 2
a123 2
	___xx = ___xcutneg + ___macheps
	___e = ___log1p_err(___xx)
d126 2
a127 2
	___xx = ___xcutpos - ___macheps
	___e = ___log1p_err(___xx)
@


1.1
log
@Initial revision
@
text
@d29 1
a29 1
	### The __test_log1p() function produces output that looks like
d61 2
a62 2
	__x = $1
	__k = 0
d65 2
a66 2
	__xcutneg = -0.39346934028736657639620046500881954655808186451281
	__xcutpos = +0.64872127070012814684865078781416357165377610071015
d69 3
a71 3
	if (isnan(__x)) \
		return (__x) \
	else if (__x == 0) \
d73 4
a76 4
	else if (__x >= __xcutpos) \
		return (log(1 + __x)) \
	else if (__x <= __xcutneg) \
		return (log(1 + __x)) \
d81 7
a87 7
	__k = 1
	__sum = 0
	__one_over_z = __x/(2 + __x)
	__one_over_z_sq = __one_over_z * __one_over_z
	__one_over_z_to_2km1 = __one_over_z
	__term = __one_over_z_to_2km1
	while ((__sum + __term) != __sum) \
d89 5
a93 5
		__sum += __term
		__k++
		__one_over_z_to_2km1 *= __one_over_z_sq
		__term = __one_over_z_to_2km1 / (2*__k - 1)
		## print __k, __term, __sum
d96 2
a97 2
	__sum *= 2
	return (__sum)
d100 1
a100 1
func __log1p_err() return (Log1p($1) - log1p($1))
d102 1
a102 1
proc __test_log1p_print() \
d104 1
a104 1
	print __xx
d106 1
a106 1
	print __k
d108 1
a108 1
	print __e
d110 1
a110 1
	print __e/__macheps
d114 1
a114 1
proc __test_log1p() \
d116 2
a117 2
	__k = 0
	__macheps = macheps(1)
d120 2
a121 2
	__last_k = -1
	for (__xx = -0.4; __xx < 0.7; __xx += 0.05) \
d123 3
a125 3
		__e = __log1p_err(__xx)
		if (__k != __last_k) __test_log1p_print()
		__last_k = __k
d127 7
a133 7
	__xx = __xcutneg + __macheps
	__e = __log1p_err(__xx)
	__test_log1p_print()

	__xx = __xcutpos - __macheps
	__e = __log1p_err(__xx)
	__test_log1p_print()
@
