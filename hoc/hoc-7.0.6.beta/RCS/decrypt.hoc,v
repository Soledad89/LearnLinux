head	1.4;
access;
symbols;
locks
	beebe:1.4; strict;
comment	@# @;


1.4
date	2002.08.08.22.18.51;	author beebe;	state Exp;
branches;
next	1.3;

1.3
date	2002.08.08.01.22.13;	author beebe;	state Exp;
branches;
next	1.2;

1.2
date	2002.07.27.03.49.15;	author beebe;	state Exp;
branches;
next	1.1;

1.1
date	2002.07.26.21.48.10;	author beebe;	state Exp;
branches;
next	;


desc
@Original version.
@


1.4
log
@Revise code to use the new string-returning function capability.
@
text
@### -*-hoc-*-
### ====================================================================
### Demonstrate a simple one-time-pad decryption based on a
### pseudo-random number generator.
### [23-Jul-2002]
### ====================================================================

### Usage: isprint(c)
### Return 1 if c is printable, and 0 otherwise.
func isprint(c) \
{
    return ((c == 9) || (c == 10) || ((32 <= c) && (c < 127)))
}

__hex_decrypt = "0123456789abcdef"

### Usage: decrypt(key,ciphertext)
### Return the decryption of ciphertext, which will be the original
### plaintext message if the key is correct.
func decrypt(key,ciphertext) \
{
    global __hex_decrypt
    setrand(key)
    plaintext = ""
    for (k = 1; k < length(ciphertext); k++) \
    {
	n = index(__hex_decrypt,substr(ciphertext,k,1))
	if (n > 0) \
	{				# have hex digit: decode hex pair
	    k++
	    c = 16 * (n - 1) + index(__hex_decrypt,substr(ciphertext,k,1)) - 1
	    n = int((c + 256 - randint(0,255)) % 256) # recover plaintext char
	    if (n == 255) \
		break;
	    if (!isprint(n)) \
		n = ichar("?")	# mask unprintable characters
	    plaintext = plaintext char(n)
	}
    }
    return (plaintext)
}
@


1.3
log
@Update to use named instead of numbered arguments.
@
text
@d18 3
a20 2
### The printed output is the original plaintext message.
proc decrypt(key,ciphertext) \
d24 1
d37 1
a37 1
	    printf "%c", n
d40 1
a40 1
    println ""
@


1.2
log
@Change code to add newly-added break statement.
@
text
@d10 1
a10 1
func isprint() \
d12 1
a12 1
    return (($1 == 9) || ($1 == 10) || ((32 <= $1) && ($1 < 127)))
a14 4
__c = 0				# temporary hack
__k = 0
__s = ""
__n = 0
d19 1
a19 1
proc decrypt() \
d21 3
a23 3
    setrand($1)
    __s = $$2
    for (__k = 1; __k < length(__s); __k++) \
d25 2
a26 2
	__n = index(__hex_decrypt,substr(__s,__k,1))
	if (__n > 0) \
d28 4
a31 4
	    __k++
	    __c = 16 * (__n - 1) + index(__hex_decrypt,substr(__s,__k,1)) - 1
	    __n = int((__c + 256 - randint(0,255)) % 256) # recover plaintext char
	    if (__n == 255) \
d33 3
a35 3
	    if (!isprint(__n)) \
		__n = ichar("?")	# mask unprintable characters
	    printf "%c", __n
@


1.1
log
@Initial revision
@
text
@d36 4
a39 7
		__k = length(__s) \
	    else \
	    {
		if (!isprint(__n)) \
		    __n = ichar("?")	# mask unprintable characters
		printf "%c", __n
	    }
@
