head	1.4;
access;
symbols;
locks
	beebe:1.4; strict;
comment	@# @;


1.4
date	2002.01.27.17.56.26;	author beebe;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.02.21.42.21;	author beebe;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.01.14.43.42;	author beebe;	state Exp;
branches;
next	1.1;

1.1
date	2001.12.11.15.19.28;	author beebe;	state Exp;
branches;
next	;


desc
@Original version.
@


1.4
log
@Log more system problems discovered during testing.
@
text
@------------------------------------------------------------------------
Wed Dec  5 11:59:55 2001
Even though -Wl,-rpath /usr/local/lib is accepted by many GNU
compilers, it fails on some systems:

	----------------------------------------------------------------
	Apple Darwin:
	g++ -I/usr/local/include -DHAVE_CONFIG_H
		-I. -I/usr/local/include -g code.o hoc.o init.o math.o
		symbol.o -o hoc -R/usr/local/lib -L/usr/local/lib -lreadline
		-L/usr/local/lib
	g++: unrecognized option `-R/usr/local/lib'

	["make LDFLAGS=" fixes the problem]
	----------------------------------------------------------------
	IBM AIX:
	gcc -I/usr/local/include -DHAVE_CONFIG_H
		-I. -I/usr/local/include -g code.o hoc.o init.o math.o
		symbol.o -o hoc -Wl,-rpath /usr/local/lib -L/usr/local/lib
		-lncurses -L/usr/local/lib -lreadline -lm
	ld: 0706-012 The -p flag is not recognized.
	ld: 0706-012 The -a flag is not recognized.
	ld: 0706-012 The -t flag is not recognized.
	ld: 0706-012 The -h flag is not recognized.
	collect2: ld returned 255 exit status

	["make LDFLAGS=" fixes the problem]
	----------------------------------------------------------------
------------------------------------------------------------------------
Wed Dec  5 12:01:26 2001
	Compaq/DEC Alpha:
	cxx -x cxx -I/usr/local/include -ieee -DHAVE_CONFIG_H
		-I. -I/usr/local/include -g code.o hoc.o init.o math.o symbol.o -o hoc
		-R/usr/local/lib -L/usr/local/lib -lreadline -lncurses
		-L/usr/local/lib -lm
	cc: Warning: -R option ignored
	cc: Warning: -R option ignored
------------------------------------------------------------------------
RESOLVED: Wed Dec  5 18:46:16 2001: Error in g++ 2.95.3 and 3.0.x header files
Wed Dec  5 12:07:25 2001
On fokine.hec:
	/home/beebe/ppc/local/bin/g++ -I/home/beebe/ppc/local/test/include -DHAVE_CONFIG_H  -I. -I/usr/local/include  -g   -DSYSHOCRC=\"/usr/local/share/lib/hoc/hoc.rc\" -c hoc.c
	hoc.y: In function `char * rl_gets(FILE *)':
	/usr/include/readline/readline.h:144: too many arguments to function `char * readline()'
	hoc.y:242: at this point in file
	/usr/include/readline/history.h:67: too many arguments to function `void add_history()'
	hoc.y:246: at this point in file
	hoc.y: In function `int main(int, char **)':
	/usr/include/readline/readline.h:161: too many arguments to function `int rl_bind_key()'
	hoc.y:630: at this point in file
	/usr/include/readline/readline.h:161: too many arguments to function `int rl_bind_key()'
	hoc.y:631: at this point in file
	make: *** [hoc.o] Error 1

------------------------------------------------------------------------
Wed Dec 12 09:12:59 2001
On Compaq/DEC Alpha, OSF/1 4.0 and OSF/1 5.0, pow(x,y) misbehaves:

	% hoc
	hoc> (-Infinity)^2
	NaNQ
	hoc> (-Infinity)*(-Infinity)
	Inf

The correct answer, from all other systems, is

	./hoc
	hoc> (-Infinity)^2
	Inf
	hoc> (-Infinity)*(-Infinity)
	Inf

I modified the test/sqrt.hoc file to use squaring, rather than powers
of 2, to avoid this problem.
------------------------------------------------------------------------
Sun Dec 16 16:06:15 2001
The Portland Group compilers, pgcc and pgCC, on Intel x86 produce an
incorrectly-functioning isnan().  The test (store(x) != x) fails when
X is a NaN because the code generated is an integer, rather than
floating-point, compare instruction.  One workaround would be to
examine the low-level bits in math.c:IsNaN(), but that is ugly.
Since that is the only solution I could think of, in math.c,
IsInf() and IsNaN() now have conditionals for these compilers.
------------------------------------------------------------------------
Tue Dec 18 06:57:00 2001
Even after the patch to math.c for IsInf() and IsNaN(), the runtime
math library for the Portland Group compilers, pgcc and pgCC, produces
incorrect results for exp() with Infinity arguments:

	% hoc
	hoc[1]: isinf(Inf)
	1

	hoc[2]: isinf(-Inf)
	1

	hoc[3]: exp(Inf)
	nan

	hoc[4]: exp(-Inf)
	nan

This is handled by yet another patch, to math.c:Exp().  With those
three patches, the validation suite now passes correctly.
------------------------------------------------------------------------
Fri Dec 28 17:22:26 2001
Hewlett-Packard HP-UX 10.01 has this peculiar behavior:

	hoc> x = 1.0e+300
	hoc> x
	1.0000000000000001e+300
	hoc> x^2
	1.7976931348623157e+308
	hoc> x*x
	Inf

Evidently, pow(x,y) returns MAXNORMAL, instead of Infinity, for
overflow conditions!  This causes a test failure:

	Check group B (mostly numeric new hoc 7 tests) ...
	...
	infinity
	-rw-rw-rw-    1 beebe    facility      118 Dec 29 06:50 infinity.out
	1,3d0
	< Test 5 failed: [isinf(1.0e+300^2)]
	< Test 6 failed: [isinf(-(1.0e+300^2))]
	< Partial success: 56 tests: 54 okay, 2 failed
------------------------------------------------------------------------
Wed Jan  2 08:52:47 2002
The Hewlett-Packard HP-UX 10.01 cc compiler botches the handling of
signed zeros.  The zero.c test file (retrofitted for K&R C) produces
these results:

	% cc zeroknr.c && ./a.out

	Zero handling in single-precision IEEE 754 arithmetic:
	sizeof(float) = 4
	+zero is unsigned               (CORRECT)
	-zero is unsigned               (WRONG)
	0 - 0 is unsigned               (CORRECT)
	(-0) - (+0) is unsigned         (WRONG)
	(+1)*(0) is unsigned            (CORRECT)
	(-1)*(0) is unsigned            (WRONG)

	Zero handling in double-precision IEEE 754 arithmetic:
	sizeof(double) = 8
	+zero is unsigned               (CORRECT)
	-zero is unsigned               (WRONG)
	0 - 0 is unsigned               (CORRECT)
	(-0) - (+0) is unsigned         (WRONG)
	(+1)*(0) is unsigned            (CORRECT)
	(-1)*(0) is unsigned            (WRONG)

The PA-RISC 2.0 Architecture manual certainly seems to indicate that
signed zero is supported, and this little test program shows that
-0 can be created by bit manipulation:

	% cat z.c
	#include <math.h>
	#include <stdio.h>

	double store();

	int main()
	{
	    union { double v; unsigned int i[2] } D;
	    double d;


	    D.v = 0.0;
	    printf("0x%08x_%08x\t%g\n", D.i[0], D.i[1], D.v);

	    D.v = -0.0;
	    printf("0x%08x_%08x\t%g\n", D.i[0], D.i[1], D.v);

	    D.v = -store(0.0);
	    printf("0x%08x_%08x\t%g\n", D.i[0], D.i[1], D.v);

	    D.i[0] = 0x80000000;
	    D.i[1] = 0x00000000;

	    printf("0x%08x_%08x\t%g\n", D.i[0], D.i[1], D.v);

	    d = copysign(1.0, D.v);

	    D.v = d;
	    printf("0x%08x_%08x\t%g\n", D.i[0], D.i[1], D.v);

	    return (0);
	}

	double store(d) double d; { return (d); }

	% cc z.c -lm && ./a.out
	0x00000000_00000000     0
	0x00000000_00000000     0
	0x00000000_00000000     0
	0x80000000_00000000     0
	0xbff00000_00000000     -1

The problem is that the run-time library outputs 0 instead of -0, for
a negative zero, and the compiler converts -0 to +0, and the compiler
generates FSUB instructions for negation, which loses the sign of
zero, instead of using FNEG, which would preserve it.
------------------------------------------------------------------------
Sat Jan 26 19:08:27 2002
A build of hoc using --with-float on Compaq/DEC Alpha GNU/Linux
turned up erroneous handling of denormalized numbers, as illustrated
by this test program:

% cat foo3.c
/***********************************************************************
[26-Jan-2002]
***********************************************************************/

#include <stdio.h>
#include <stdlib.h>

#if defined(__STDC__) || defined(__cplusplus)
#define ARGS(parenthesized_list) parenthesized_list
#else
#define ARGS(parenthesized_list) ()
#endif

#ifndef EXIT_SUCCESS
#define EXIT_SUCCESS 0
#endif

int	main ARGS((int argc, char* argv[]));

int
main(int argc, char* argv[])
{

    float x;
    int k;
    union
	{
	    float v;
	    unsigned int i[4];
    } d;


    for (x = 1.0, k = 0; x/2 > 0.0; x /= 2, k--)
    {
	d.i[0] = 0xdeadbeef;
	d.i[1] = 0xdeadbeef;
	d.i[2] = 0xdeadbeef;
	d.i[3] = 0xdeadbeef;
	d.v = x;
	printf("%7d\t%.36Lg\t0x%08x_%08x_%08x_%08x\n", 
	       k, x, d.i[0], d.i[1], d.i[2], d.i[3]); 
    }

    return (EXIT_SUCCESS);
}

% g++ -mieee foo3.c && ./a.out
      0 1       0x3f800000_deadbeef_deadbeef_deadbeef
     -1 0.5     0x3f000000_deadbeef_deadbeef_deadbeef
     -2 0.25    0x3e800000_deadbeef_deadbeef_deadbeef
     -3 0.125   0x3e000000_deadbeef_deadbeef_deadbeef
 ...
   -125 2.35098870164457501593747307444449136e-38       0x01000000_deadbeef_deadbeef_deadbeef
   -126 1.17549435082228750796873653722224568e-38       0x00800000_deadbeef_deadbeef_deadbeef
   -127 1.11253692925360069154511635866620203e-308      0x00400000_deadbeef_deadbeef_deadbeef
   -128 5.56268464626800345772558179333101016e-309      0x00200000_deadbeef_deadbeef_deadbeef
...
   -147 1.06099789548263615755569110743160442e-314      0x00000004_deadbeef_deadbeef_deadbeef
   -148 5.30498947741318078777845553715802208e-315      0x00000002_deadbeef_deadbeef_deadbeef

While the hexadecimal form shows that the arithmetic is correct, the
decimal form is wrong!

On another Compaq/DEC Alpha running OSF/1 4.0, the same program
produces correct output:

% g++ -mieee foo3.c && ./a.out
      0 1       0x3f800000_deadbeef_deadbeef_deadbeef
     -1 0.5     0x3f000000_deadbeef_deadbeef_deadbeef
     -2 0.25    0x3e800000_deadbeef_deadbeef_deadbeef
     -3 0.125   0x3e000000_deadbeef_deadbeef_deadbeef
...
   -125 2.350988701644575e-38   0x01000000_deadbeef_deadbeef_deadbeef
   -126 1.1754943508222875e-38  0x00800000_deadbeef_deadbeef_deadbeef
   -127 5.8774717541114375e-39  0x00400000_deadbeef_deadbeef_deadbeef
   -128 2.9387358770557188e-39  0x00200000_deadbeef_deadbeef_deadbeef
...
   -146 1.1210387714598537e-44  0x00000008_deadbeef_deadbeef_deadbeef
   -147 5.6051938572992683e-45  0x00000004_deadbeef_deadbeef_deadbeef
   -148 2.8025969286496341e-45  0x00000002_deadbeef_deadbeef_deadbeef
------------------------------------------------------------------------
Sat Jan 26 19:13:35 2002
On IBM RS/6000 AIX and SGI IRIX 6.x, long double is implemented as
a pair of doubles.  In particular, this makes determination of the
machine epsilon problematic, and also makes the default long double
bsetting of EBIAS, EBITS, EMAX, EMIN, and P wrong.  There are many
other anomalies with long double on these systems (described in a
forthcoming paper by the author and J. W. Ball in ACM Transactions on
Mathematical Software), so the configure.in script has been modified
to revert to --with-double for these (and some other broken) systems.
------------------------------------------------------------------------
Sat Jan 26 19:16:33 2002
Addition of the --with-float and --with-long-double options, and their
testing on a broad range of systems showed that float and long double
are poorly handled by most compilers.  There are numerous functions
with missing prototypes in system header files, and functions
documented in manual pages but absent from the runtime libraries.
Where possible, I have added suitable code in fp_t.h and hoc.h to provide
suitable prototypes, or remapping of function names to alternate ones,
so that none of the *.c files have to know about this horrid mess.
------------------------------------------------------------------------
Sat Jan 26 19:20:37 2002
On Compaq/DEC Alpha OSF/1 5.x, output of long double values with
fprintf(), printf(), and sprintf() will not print more than 17 decimal
figures, making long double effectively useless for practical
computations!
------------------------------------------------------------------------
Sat Jan 26 19:25:12 2002
trunc() and significand() have problems on several systems with signed
zeros.  Special code has been added to ieee754.c:Significand() and
ieee754.c:Trunc() to correct this.
------------------------------------------------------------------------
@


1.3
log
@Routine update
@
text
@d206 118
@


1.2
log
@Add new problem reports.
@
text
@d129 77
@


1.1
log
@Initial revision
@
text
@d56 73
@
