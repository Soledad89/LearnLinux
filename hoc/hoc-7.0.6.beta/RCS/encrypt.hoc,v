head	1.3;
access;
symbols;
locks
	beebe:1.3; strict;
comment	@# @;


1.3
date	2002.08.08.22.18.51;	author beebe;	state Exp;
branches;
next	1.2;

1.2
date	2002.08.08.01.22.13;	author beebe;	state Exp;
branches;
next	1.1;

1.1
date	2002.07.26.21.48.10;	author beebe;	state Exp;
branches;
next	;


desc
@Original version.
@


1.3
log
@Revise code to use the new string-returning function capability.
@
text
@### -*-hoc-*-
### ====================================================================
### Demonstrate a simple one-time-pad encryption based on a
### pseudo-random number generator.
### [23-Jul-2002]
### ====================================================================

### Usage: encrypt(key,plaintext)
### The returned string is an encrypted text stream: the ciphertext.
func encrypt(key,plaintext) \
{
    plaintext = (plaintext char(255))		# add message terminator
    while (length(plaintext) < 32) \
	plaintext = (plaintext char(randint(1,255))) # pad to 32*n characters
    setrand(key)				# restart the generator
    n = 0
    ciphertext = "\n\t"					   
    for (k = 1; k <= length(plaintext); ++k) \
    {
	## Output 32-character lines in 4 chunks of 8 characters each

	if ((n > 0) && (n % 32 == 0)) \
	    ciphertext = ciphertext "\n\t" \
	else if ((n > 0) && (n % 4 == 0)) \
	    ciphertext = ciphertext " "

	ciphertext = sprintf "%s%02x", ciphertext, \
		((ichar(substr(plaintext,k,1)) + randint(0,255)) % 256)
	n++
    }
    ciphertext = ciphertext "\n"
    return (ciphertext)
}
@


1.2
log
@Update to use named instead of numbered arguments.
@
text
@d9 2
a10 2
### The printed output is an encrypted text stream: the ciphertext.
proc encrypt(key,plaintext) \
d14 1
a14 1
	plaintext = (plaintext char(randint(0,255))) # pad to 32*n characters
d17 1
d21 1
d23 1
a23 1
	    println "" \
d25 4
a28 2
	    print " "
	printf "%02x", ((ichar(substr(plaintext,k,1)) + randint(0,255)) % 256)
d31 2
a32 1
    println ""
@


1.1
log
@Initial revision
@
text
@a7 4
__k = 0				# temporary hack
__n = 0
__s = ""

d10 1
a10 1
proc encrypt() \
d12 6
a17 7
    __s = $$2
    __s = (__s char(255))		# add message terminator
    while (length(__s) < 32) \
	__s = (__s char(randint(0,255))) # pad to 32*n characters
    setrand($1)				# restart the generator
    __n = 0
    for (__k = 1; __k <= length(__s); ++__k) \
d20 1
a20 1
	if ((__n > 0) && (__n % 32 == 0)) \
d22 1
a22 1
	else if ((__n > 0) && (__n % 4 == 0)) \
d24 2
a25 2
	printf "%02x", ((ichar(substr(__s,__k,1)) + randint(0,255)) % 256)
	__n++
@
