head	1.13;
access;
symbols;
locks
	beebe:1.13; strict;
comment	@ * @;


1.13
date	2002.08.08.22.19.57;	author beebe;	state Exp;
branches;
next	1.12;

1.12
date	2002.08.05.11.20.43;	author beebe;	state Exp;
branches;
next	1.11;

1.11
date	2002.08.01.12.22.38;	author beebe;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.24.14.49.26;	author beebe;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.23.01.37.00;	author beebe;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.20.23.05.35;	author beebe;	state Exp;
branches;
next	1.7;

1.7
date	2002.07.04.15.07.34;	author beebe;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.04.14.45.31;	author beebe;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.30.17.06.18;	author beebe;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.27.18.15.20;	author beebe;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.11.02.30.17;	author beebe;	state Exp;
branches;
next	1.2;

1.2
date	2002.01.02.21.38.04;	author beebe;	state Exp;
branches;
next	1.1;

1.1
date	2002.01.01.13.18.21;	author beebe;	state Exp;
branches;
next	;


desc
@Original version.
@


1.13
log
@Revise overriding declarations of missing library functions.
@
text
@#include "hoc.h"

#if defined(HAVE_ERRNO_H)
#include <errno.h>
#endif

#if defined(HAVE_FLOAT_H)
#include <float.h>
#endif

#if defined(HAVE_MATH_H)
#include <math.h>
#endif

#if defined(DEBUG_MACHEPS)
#if defined(HAVE_STDIO_H)
#include <stdio.h>
#endif
#endif

/* These functions are in -lm, but are missing from math.h, sigh... */

#if defined(__linux)
EXTERN float (truncf) ARGS((float));		/* all GNU/Linux */
EXTERN double (trunc) ARGS((double));		/* all GNU/Linux */
#if defined(HAVE_FP_T_QUADRUPLE)
EXTERN long double (truncl) ARGS((long double));/* all GNU/Linux */
#endif
#endif

#if defined(__osf__)
EXTERN int (ilogbf) ARGS((float));		/* Compaq/DEC OSF/1 */
EXTERN int (ilogb) ARGS((double));		/* Compaq/DEC OSF/1 */
#if defined(HAVE_FP_T_QUADRUPLE)
EXTERN int (ilogbl) ARGS((long double));		/* Compaq/DEC OSF/1 */
#endif
#if defined(HAVE_NEAREST)
EXTERN float (nearestf) ARGS((float,float));	/* Compaq/DEC OSF/1 */
EXTERN double (nearest) ARGS((double,double));	/* Compaq/DEC OSF/1 */
#if defined(HAVE_FP_T_QUADRUPLE)
EXTERN long double (nearestl) ARGS((long double,long double));	/* Compaq/DEC OSF/1 */
#endif
#endif
#endif

#define TWOTO23		FP(8388608.0)					/* 2^23 */
#define TWOTO52		FP(4503599627370496.0)				/* 2^52 */
#define TWOTO64		FP(18446744073709551616.0)			/* 2^64 */
#define TWOTO112	FP(5192296858534827628530496329220096.0)	/* 2^112 */

#define STORE(expr)	(temp__ = (expr), store(&temp__))

fp_t
Ceil(fp_t x)
{
	fp_t y;

	/* TO DO: Should Ceil(-Infinity) return a finite number or
	not? Sun's returns ceil(Infinity) as 2^63, and ceil(-Infinity)
	as -2^63, which both seem inconsistent. */

	if (IsNaN(x))
		return (x);
	else if (IsInf(x))
		return (x);

#if defined(HAVE_CEIL)
	y = ceil(x);
#else
	/* Simply using (integer cast)x here is not sufficient, because
	   the result can be negative in the case of integer overflow.

	   The solution is to clear fractional bits by adding and
	   subtracting a suitable large power of the base, then to add
	   one to the result to guarantee that x <= ceil(x).

	   This seems a much cleaner, and much more portable, solution
	   than the extensive bit manipulations that are used in Sun's
	   fdlibm (freely-distributable math library) code. */
#if 0
	y = (fp_t)((LONG_LONG)(x));
#else
	{
		static fp_t base_to_Pm1 = FP(0.0);
		fp_t xabs;

		if (base_to_Pm1 == FP(0.0))	/* normally happens only on first call */
			base_to_Pm1 = Pow(BASE,(P - 1));
		xabs = fabs(x);
		if (xabs == FP(0.0))
			y = x;		/* preserve sign of zero */
		else if (xabs > base_to_Pm1)
			y = x; /* x has no representable fractional part, so ceil(x) = x */
		else
		{
			fp_t temp__;

			y = STORE(STORE(base_to_Pm1 + xabs) - base_to_Pm1);
			if (x < FP(0.0))
				y = -y;
		}
	}
#endif
	if (x > y)
		y += FP(1.0);
#endif
	return (y);
}

fp_t
Class(fp_t x)
{
	if (IsQNaN(x))
		return (CLASS_QNAN);
	else if (IsSNaN(x))
		return (CLASS_SNAN);
	else if (IsInf(x))
		return ((x < FP(0.0)) ? CLASS_NEGINF : CLASS_POSINF);
	else if (x <= -MinNormal())
		return (CLASS_NEGNORMAL);
	else if (x <= -MinSubnormal())
		return (CLASS_NEGSUBNORMAL);
	else if ((x == FP(0.0)) && (Copysign(FP(1.0),x) == FP(-1.0)))
		return (CLASS_NEGZERO);
	else if ((x == FP(0.0)) && (Copysign(FP(1.0),x) == FP(1.0)))
		return (CLASS_POSZERO);
	else if (x >= MinNormal())
		return (CLASS_POSNORMAL);
	else if (x >= MinSubnormal())
		return (CLASS_POSSUBNORMAL);
	else
		return (CLASS_UNKNOWN);
}

static unsigned int
high_word(fp_t x)
{
	FP_Parts d;
	int big_endian = IsBigEndian();
	unsigned int hi;

	d.v = x;

#if defined(HAVE_FP_T_SINGLE)
	hi = d.i[0];
#elif defined(HAVE_FP_T_DOUBLE)
	hi = d.i[1-big_endian];
#elif defined(HAVE_FP_T_QUADRUPLE)
	if (sizeof(d) == sizeof(d.v))	/* 128-bit */
		hi = d.i[3*(1-big_endian)];
	else if (sizeof(fp_t) == sizeof(double)) /* long double masquerading as double */
		hi = d.i[1-big_endian];
	else				/* 80-bit Intel x86 format */
		hi = d.i[2];
#else
	hi = 0;
	execerror("internal error at " __FILE__ ":" __LINE__, (const char*)NULL)
#endif
	return (hi);
}


fp_t
Copysign(fp_t x, fp_t y)
{

#if defined(HAVE_COPYSIGN) && !defined(__sgi) /* SGI IRIX copysign() is wrong for NaN arguments */

#if defined(FP_ARCH_IA32) || defined(FP_ARCH_ALPHA)
	/* Preserve hoc's convention that IEEE 754 NaN is unsigned by
	   default, even though on this architecture, the reverse is
	   true. */
	if (IsNaN(y))
		return (-copysign(x,y));
	else
		return (copysign(x,y));
#else
	return (copysign(x,y));
#endif

#else /* NOT defined(HAVE_COPYSIGN) */
	return ((high_word(y) >> 31) ? -x : x);
#endif

}

fp_t
Exponent(fp_t x)
{	/* Return the unbiased base-2 exponent of x */
#if defined(HAVE_IEEE_754)
	FP_Parts d;
	fp_t xabs;
	int big_endian = IsBigEndian();
	int offset;

	xabs = (x < FP(0.0)) ? -x : x;

	if (!IsNaN(x) && (xabs < MinNormal())) /* protect against NaN botch! */
	{

#if defined(HAVE_FP_T_DOUBLE)
		offset = -52;
		x *= TWOTO52;
#endif

#if defined(HAVE_FP_T_QUADRUPLE)
		if (sizeof(d) == sizeof(d.v))	/* 128-bit */
		{
		    offset = -112;
		    x *= TWOTO112;
		}
		else if (sizeof(fp_t) == sizeof(double)) /* long double masquerading as double */
		{
			offset = -52;
			x *= TWOTO52;
		}
		else			/* 80-bit Intel x86 format */
		{
		    offset = -64;
		    x *= TWOTO64;
		}
#endif

#if defined(HAVE_FP_T_SINGLE)
		offset = -23;
		x *= TWOTO23;
#endif

	}
	else
		offset = 0;

	d.v = x;

#if defined(HAVE_FP_T_DOUBLE)
	return ((fp_t)((int)((d.i[1-big_endian] & UL(0x7ff00000)) >> 20) - 1023 + offset));
#endif

#if defined(HAVE_FP_T_QUADRUPLE)
	if (sizeof(d) == sizeof(d.v))	/* 128-bit */
		return ((fp_t)((int)((d.i[3*(1-big_endian)] & UL(0x7fff0000)) >> 16)) - 16383 + offset);
	else if (sizeof(fp_t) == sizeof(double)) /* long double masquerading as double */
		return ((fp_t)((int)((d.i[1-big_endian] & UL(0x7ff00000)) >> 20) - 1023 + offset));
	else				/* 80-bit Intel x86 format */
		return ((fp_t)((int)(d.i[2] & UL(0x7fff)) - 16383 + offset));
#endif

#if defined(HAVE_FP_T_SINGLE)
	return ((fp_t)((int)((d.i[0] & UL(0x7f800000)) >> 23) - 127 + offset));
#endif

#else
	return ((fp_t)Nint(Log2(xabs))); /* TO DO: implement efficiently for non-IEEE 754 systems */
#endif
}

fp_t
Floor(fp_t x)
{
	fp_t y;

	/* TO DO: Should Floor(-Infinity) return a finite number or
	not? Sun's returns floor(Infinity) as 2^63, and floor(-Infinity)
	as -2^63, which both seem inconsistent. */

	if (IsNaN(x))
		return (x);
	else if (IsInf(x))
		return (x);

#if defined(HAVE_FLOOR)
	y = floor(x);
#else
#if 0
	y = (fp_t)((LONG_LONG)(x));
#else
	y = Ceil(x);			/* see implementation comments in Ceil() */
#endif
	if (x < y)
		y--;
#endif
	return (y);
}

fp_t
Fmod(fp_t x, fp_t y)
{
#if defined(HAVE_FMOD)
	return (fmod(x,y));
#else
	execerror("fmod(x,y) is not available on this system", (const char*)NULL);
	return (FP(0.0));			/* NOT REACHED */
#endif
}

fp_t
Ilogb(fp_t x)
{
#if defined(HAVE_ILOGB)
	return ((fp_t)ilogb(x));
#else
	return ((fp_t)(int)Log2(x));
#endif
}

fp_t
Infinity(void)
{
	static fp_t infinity = FP(0.0);

	if (infinity == FP(0.0))	/* normally happens only on first call */
	{
		fp_t temp__;

#if defined(HAVE_IEEE_754)
		infinity = STORE(FP(1.0));
		infinity /= STORE(FP(0.0));
#elif defined(DBL_MAX)
		infinity = DBL_MAX;
#else
		execerror("Infinity() is not available on this system",
			  (const char*)NULL);
#endif
	}
	return (infinity);
}

fp_t
Integer(fp_t x)
{
#if 0
	return (fp_t)(long)x;
#else
	/* Since all numbers are represented as type fp_t, we can
	provided a wider range of integers than long provides: */
	if (IsNaN(x))
	{
		execerror("int(NaN) is undefined", (const char*)NULL);
		return (FP(0.0));		/* NOT REACHED */
	}
	else if (x < FP(0.0))
		return (Ceil(x));
	else /* (x >= FP(0.0)) */
		return (Floor(x));
#endif
}

int
IsBigEndian(void)
{
	FP_Parts d;
	d.v = FP(1.0);
	return ((d.i[0] != 0) ? 1 : 0);
}

fp_t
IsFinite(fp_t x)
{
	return ((fp_t)(!IsNaN(x) && !IsInf(x)));
}

fp_t
IsInf(fp_t x)
{
	/* This portable implementation that does not require IEEE 754
	   arithmetic to function properly is due to Norman
	   L. Schryer, and used in his FPTEST package.  See ``A Test
	   of a Computer's Floating-Point Arithmetic Unit'', Bell
	   Laboratories Computing Science Technical Report no. 89,
	   February 4, 1981.  Available, with the software (under
	   license), at http://www.bell-labs.com/project/fptest/ */

#if defined(HAVE_NAN_BOTCH)		/* see IsNaN() for why */
	if (IsNaN(x))
		return (FP(0.0));
#endif

	if (x < FP(0.0))
		x = -x;			/* force positive */
	if (x < FP(1.0))		/* small, so finite */
		return (FP(0.0));
	else if ((x / BASE) == x)	/* only Inf/BASE == Inf */
		return (FP(1.0));
	else				/* must be finite */
		return (FP(0.0));
}

fp_t
IsNaN(fp_t x)
{
	fp_t temp__;

#if defined(HAVE_NAN_BOTCH)
	/* The Portland Group compilers, pgcc and pgCC, on Intel x86 */
	/* incorrectly generate a 64-bit integer comparison, instead */
	/* of a floating-point one.  This is wrong for NaNs, so even */
	/* the STORE() subterfuge does not produce the right answer. */
	/* Therefore, we have to grovel around in the bits.          */
	FP_Parts d;
	int big_endian = IsBigEndian();

	d.v = x;

#if defined(HAVE_FP_T_DOUBLE)
	return ((fp_t)(((d.i[1-big_endian] & UL(0x7ff00000)) == UL(0x7ff00000)) &&
			 ((d.i[1-big_endian] & UL(~0xfff00000)) ||
			  d.i[big_endian])));
#endif

#if defined(HAVE_FP_T_QUADRUPLE)
	if (sizeof(d) == sizeof(d.v))	/* 128-bit */
		return ((fp_t)(((d.i[3*(1-big_endian)] & UL(0x7fff0000)) == UL(0x7fff0000)) &&
			       ((d.i[3*(1-big_endian)] & UL(~0x7fff0000)) ||
				d.i[1] || d.i[2] || d.i[3*big_endian])));
	else if (sizeof(fp_t) == sizeof(double)) /* long double masquerading as double */
		return ((fp_t)(((d.i[1-big_endian] & UL(0x7ff00000)) == UL(0x7ff00000)) &&
				 ((d.i[1-big_endian] & UL(~0xfff00000)) ||
				  d.i[big_endian])));
	else				/* 80-bit Intel x86 format */
		return ((fp_t)(((d.i[2] & UL(0x7fff)) == UL(0x7fff)) && (d.i[1] || d.i[0])));
#endif

#if defined(HAVE_FP_T_SINGLE)
	return ((fp_t)(((d.i[0] & UL(0x7f800000)) == UL(0x7f800000)) &&
		       (d.i[0] & UL(~0xff800000))));
#endif

#else
	return ((fp_t)(STORE(x) != x));	/* should thwart optimizers */
#endif
}

fp_t
IsNormal(fp_t x)
{
	return (fp_t)((IsFinite(x) && !IsSubnormal(x)));
}

/***********************************************************************
The implementation of IsQNaN() is unavoidably system-dependent, and for
two of these architectures, there is only one type of NaN, so for them,
both IsSNaN() and IsQNaN() should be true!

From p. 4-59 of the Alpha AXP Architecture Manual:
	quiet NaN:	initial fraction bit of 1
	signaling NaN:	initial fraction bit of 0
------------------------------------------------------------------------
From p. 21 of SPARC Architecture Manual v8:
[same choice as Alpha]
	quiet NaN:	initial fraction bit of 1
	signaling NaN:	initial fraction bit of 0
------------------------------------------------------------------------
From p. 145 of The PowerPC Architecture:
[same as Alpha and SPARC]
	quiet NaN:	initial fraction bit of 1
	signaling NaN:	initial fraction bit of 0
------------------------------------------------------------------------
From p. 2-5 of i860 Microprocessor Programmer's Reference Manual:
[same as Alpha, SPARC, PowerPC]
	quiet NaN:	initial fraction bit of 1
	signaling NaN:	initial fraction bit of 0
------------------------------------------------------------------------
From p. 2-15 of MC68881 Floating-Point Coprocessor Users Manual:
[same as Alpha, SPARC, PowerPC, Intel i860]
	quiet NaN:	initial fraction bit of 1
	signaling NaN:	initial fraction bit of 0
------------------------------------------------------------------------
From p. 5-3 (sequential 87 of 216) Intel IA-64 Architecture Software
Developer's Manual, Rev 1.0:
[same as Alpha, SPARC, PowerPC, Intel i860, MC68881]
	quiet NaN:	initial fraction bit of 1
	signaling NaN:	initial fraction bit of 0
------------------------------------------------------------------------
From p. 8-7 of PA-RISC 2.0 Architecture:
[opposite of Alpha, SPARC, PowerPC, i860]
	quiet NaN:	initial fraction bit of 0
	signaling NaN:	initial fraction bit of 1
------------------------------------------------------------------------
From p. E-2 of MIPS RISC Architecture:
[no distinction between NaNs]
	NaN:		initial fraction bit of 0
------------------------------------------------------------------------
From Palmer and Morse The 8087 Primer and p. I-25 of iAPX 286
Programmer's Reference Manual:
[no distinction between NaNs]
	NaN:		at least one nonzero fraction bit
Generated NaNs have negative sign bit.

Experiments on Pentium III show 0/0 -> 0xfff80000_00000000, so the
leading fraction bit is the only nonzero generated.  However, this can
be explicitly negated to obtain 0x7ff80000_00000000.
------------------------------------------------------------------------
***********************************************************************/

#if defined(HAVE_FP_T_SINGLE)
static fp_t
IsQNaN32(float x)
{
	SP_Parts d;
	fp_t temp__;

	d.v = x;

#if defined(FP_ARCH_ALPHA)
	return ((fp_t)((d.i[0] & UL(0x00400000)) != 0));
#elif defined(FP_ARCH_SPARC)
	return ((fp_t)((d.i[0] & UL(0x00400000)) != 0));
#elif defined(FP_ARCH_I860)
	return ((fp_t)((d.i[0] & UL(0x00400000)) != 0));
#elif defined(FP_ARCH_POWER)
	return ((fp_t)((d.i[0] & UL(0x00400000)) != 0));
#elif defined(FP_ARCH_IA64)
	return ((fp_t)((d.i[0] & UL(0x00400000)) != 0));
#elif defined(FP_ARCH_PA_RISC)
	return ((fp_t)((d.i[0] & UL(0x00400000)) == 0));
#elif defined(FP_ARCH_IA32)
	(void)STORE(d.v);	/* avoid complaints about unused d */
	return (FP(1.0));
#elif defined(FP_ARCH_MIPS)
	(void)STORE(d.v);	/* avoid complaints about unused d */
	return (FP(1.0));
#else  /* fall back to majority style, which could still be wrong */
	(void)STORE(d.v);	/* avoid complaints about unused d */
	return (FP(1.0));
#endif
}
#endif

static fp_t
IsQNaN64(double x)
{
	DP_Parts d;
	int big_endian = IsBigEndian();
	fp_t temp__;

	d.v = x;

#if defined(FP_ARCH_ALPHA)
	return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) != 0));
#elif defined(FP_ARCH_SPARC)
	return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) != 0));
#elif defined(FP_ARCH_I860)
	return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) != 0));
#elif defined(FP_ARCH_POWER)
	return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) != 0));
#elif defined(FP_ARCH_IA64)
	return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) != 0));
#elif defined(FP_ARCH_PA_RISC)
	return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) == 0));
#elif defined(FP_ARCH_IA32)
	(void)STORE(d.v);	/* avoid complaints about unused d */
	return ((fp_t)(big_endian == big_endian)); /* avoids compiler warnings about unused big_endian*/
#elif defined(FP_ARCH_MIPS)
	(void)STORE(d.v);	/* avoid complaints about unused d */
	return ((fp_t)(big_endian == big_endian)); /* avoids compiler warnings about unused big_endian*/
#else  /* fall back to majority style, which could still be wrong */
	return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) != 0));
#endif

}

#if defined(HAVE_FP_T_QUADRUPLE)
static fp_t
IsQNaN128(long double x)
{
	QP_Parts d;
	int big_endian = IsBigEndian();
	fp_t temp__;

	d.v = x;

#if defined(FP_ARCH_ALPHA)
	return ((fp_t)((d.i[3*(1 - big_endian)] & UL(0x00008000)) != 0));
#elif defined(FP_ARCH_SPARC)
	return ((fp_t)((d.i[3*(1 - big_endian)] & UL(0x00008000)) != 0));
#elif defined(FP_ARCH_I860)
	return ((fp_t)((d.i[3*(1 - big_endian)] & UL(0x00008000)) != 0));
#elif defined(FP_ARCH_POWER)
	return ((fp_t)((d.i[3*(1 - big_endian)] & UL(0x00008000)) != 0));
#elif defined(FP_ARCH_IA64)
	return ((fp_t)((d.i[3*(1 - big_endian)] & UL(0x00008000)) != 0));
#elif defined(FP_ARCH_PA_RISC)
	return ((fp_t)((d.i[3*(1 - big_endian)] & UL(0x00008000)) == 0));
#elif defined(FP_ARCH_IA32)
	(void)STORE(d.v);	/* avoid complaints about unused d */
	return ((fp_t)(big_endian == big_endian)); /* avoids compiler warnings about unused big_endian*/
#elif defined(FP_ARCH_MIPS)
	(void)STORE(d.v);	/* avoid complaints about unused d */
	return ((fp_t)(big_endian == big_endian)); /* avoids compiler warnings about unused big_endian*/
#else  /* fall back to majority style, which could still be wrong */
	return ((fp_t)((d.i[3*(1 - big_endian)] & UL(0x00008000)) != 0));
#endif

}
#endif


fp_t
IsQNaN(fp_t x)
{
	if (IsNaN(x))
	{

#if defined(HAVE_FP_T_DOUBLE)
		return (IsQNaN64(x));
#endif

#if defined(HAVE_FP_T_QUADRUPLE)
		if (sizeof(fp_t) == sizeof(double)) /* long double masquerading as double */
			return (IsQNaN64(x));
		else
			return (IsQNaN128(x));
#endif

#if defined(HAVE_FP_T_SINGLE)
		return (IsQNaN32(x));
#endif

	}
	else
		return (FP(0.0));
}

#if defined(HAVE_FP_T_SINGLE)
static fp_t
IsSNaN32(float x)
{
	SP_Parts d;
	fp_t temp__;

	d.v = x;

#if defined(FP_ARCH_ALPHA)
	return ((fp_t)((d.i[0] & UL(0x00400000)) == 0));
#elif defined(FP_ARCH_SPARC)
	return ((fp_t)((d.i[0] & UL(0x00400000)) == 0));
#elif defined(FP_ARCH_I860)
	return ((fp_t)((d.i[0] & UL(0x00400000)) == 0));
#elif defined(FP_ARCH_POWER)
	return ((fp_t)((d.i[0] & UL(0x00400000)) == 0));
#elif defined(FP_ARCH_IA64)
	return ((fp_t)((d.i[0] & UL(0x00400000)) == 0));
#elif defined(FP_ARCH_PA_RISC)
	return ((fp_t)((d.i[0] & UL(0x00400000)) != 0));
#elif defined(FP_ARCH_IA32)
	(void)STORE(d.v);	/* avoid complaints about unused d */
	return (FP(1.0));
#elif defined(FP_ARCH_MIPS)
	(void)STORE(d.v);	/* avoid complaints about unused d */
	return (FP(1.0));
#else  /* fall back to majority style, which could still be wrong */
	return ((fp_t)((d.i[0] & UL(0x00400000)) == 0));
#endif
}
#endif

static fp_t
IsSNaN64(double x)
{
	DP_Parts d;
	int big_endian = IsBigEndian();
	fp_t temp__;

	d.v = x;

#if defined(FP_ARCH_ALPHA)
	return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) == 0));
#elif defined(FP_ARCH_SPARC)
	return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) == 0));
#elif defined(FP_ARCH_I860)
	return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) == 0));
#elif defined(FP_ARCH_POWER)
	return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) == 0));
#elif defined(FP_ARCH_IA64)
	return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) == 0));
#elif defined(FP_ARCH_PA_RISC)
	return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) != 0));
#elif defined(FP_ARCH_IA32)
	(void)STORE(d.v);	/* avoid complaints about unused d */
	return ((fp_t)(big_endian == big_endian)); /* avoids compiler warnings about unused big_endian*/
#elif defined(FP_ARCH_MIPS)
	(void)STORE(d.v);	/* avoid complaints about unused d */
	return ((fp_t)(big_endian == big_endian)); /* avoids compiler warnings about unused big_endian*/
#else  /* fall back to majority style, which could still be wrong */
	return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) == 0));
#endif
}

#if defined(HAVE_FP_T_QUADRUPLE)
static fp_t
IsSNaN128(long double x)
{
	QP_Parts d;
	int big_endian = IsBigEndian();
	fp_t temp__;

	d.v = x;

#if defined(FP_ARCH_ALPHA)
		return ((fp_t)((d.i[3*(1 - big_endian)] & UL(0x00008000)) == 0));
#elif defined(FP_ARCH_SPARC)
		return ((fp_t)((d.i[3*(1 - big_endian)] & UL(0x00008000)) == 0));
#elif defined(FP_ARCH_I860)
		return ((fp_t)((d.i[3*(1 - big_endian)] & UL(0x00008000)) == 0));
#elif defined(FP_ARCH_POWER)
		return ((fp_t)((d.i[3*(1 - big_endian)] & UL(0x00008000)) == 0));
#elif defined(FP_ARCH_IA64)
		return ((fp_t)((d.i[3*(1 - big_endian)] & UL(0x00008000)) == 0));
#elif defined(FP_ARCH_PA_RISC)
		return ((fp_t)((d.i[3*(1 - big_endian)] & UL(0x00008000)) != 0));
#elif defined(FP_ARCH_IA32)
		(void)STORE(d.v);	/* avoid complaints about unused d */
		return ((fp_t)(big_endian == big_endian)); /* avoids compiler warnings about unused big_endian*/
#elif defined(FP_ARCH_MIPS)
		(void)STORE(d.v);	/* avoid complaints about unused d */
		return ((fp_t)(big_endian == big_endian)); /* avoids compiler warnings about unused big_endian*/
#else  /* fall back to majority style, which could still be wrong */
		return ((fp_t)((d.i[3*(1 - big_endian)] & UL(0x00008000)) == 0));
#endif
}
#endif

fp_t
IsSNaN(fp_t x)
{
	if (IsNaN(x))
	{

#if defined(HAVE_FP_T_DOUBLE)
		return (IsSNaN64(x));
#endif

#if defined(HAVE_FP_T_QUADRUPLE)
		if (sizeof(fp_t) == sizeof(double)) /* long double masquerading as double */
			return (IsSNaN64(x));
		else
			return (IsSNaN128(x));
#endif

#if defined(HAVE_FP_T_SINGLE)
		return (IsSNaN32(x));
#endif

	}
	else
		return (FP(0.0));
}

fp_t
IsSubnormal(fp_t x)
{
	if (x == FP(0.0))
		return (FP(0.0));
	else if (IsNaN(x))
		return (FP(0.0));
	else if (IsInf(x))
		return (FP(0.0));
	else
	{
#if defined(HAVE_IEEE_754)
		return ((fp_t)(Exponent(x) < EMIN));
#else
		return (FP(0.0));
#endif
	}
}

fp_t
Ldexp(fp_t x, fp_t y)
{
#if defined(HAVE_LDEXP)
	return (ldexp(x,(int)y));
#else
	return (x * pow(BASE, (fp_t)(int)y));
#endif
}

#if defined(HAVE_FP_T_QUADRUPLE)
/* Sun Solaris <sunmath.h> contains this note: ``ANSI C Future Library
   Directions {4.13.4}: Note that frexpf, ldexpf, modff, frexpl, ldexpl
   and modfl are _not_ provided. */
fp_t
ldexpl(fp_t x, int n)
{					/* return x * 2**n */
	fp_t result;

	if (IsNaN(x))
		result = x;
	else if (IsInf(x))
		result = x;
	else
	{
		result = x * powl(FP(2.0), (fp_t)n);
		if (IsInf(result))
		{
			/* Sun documentation says that ldexp() returns
			   +/-HUGE_VAL on overflow, and sets errno to
			   ERANGE */
			result = (x < FP(0.0)) ? -MaxNormal() : MaxNormal();
			errno = ERANGE;
		}
	}
	return (result);
}
#endif /* defined(HAVE_FP_T_QUADRUPLE) */

#if defined(HAVE_FP_T_SINGLE)
/* Sun Solaris <sunmath.h> contains this note: ``ANSI C Future Library
   Directions {4.13.4}: Note that frexpf, ldexpf, modff, frexpl, ldexpl
   and modfl are _not_ provided. */
fp_t
ldexpf(fp_t x, int n)
{					/* return x * 2**n */
	fp_t result;

	if (IsNaN(x))
		result = x;
	else if (IsInf(x))
		result = x;
	else
	{
		result = x * pow(FP(2.0), (fp_t)n); /* NB: pow, not powf, for macro substitution */
		if (IsInf(result))
		{
			/* Sun documentation says that ldexp() returns
			   +/-HUGE_VAL on overflow, and sets errno to
			   ERANGE */
			result = (x < FP(0.0)) ? -MaxNormal() : MaxNormal();
			errno = ERANGE;
		}
	}
	return (result);
}
#endif /* defined(HAVE_FP_T_SINGLE) */

#if defined(DEBUG_MACHEPS)
void
Dump(const char *s, fp_t x)
{
	FP_Parts d;
	int big_endian = IsBigEndian();
	d.v = x;

#if defined(HAVE_FP_T_DOUBLE)
	(void)fprintf(stderr,"%s: %g\t0x%08x_%08x\n",
		      s, d.v, d.i[1-big_endian], d.i[big_endian]);
#endif

#if defined(HAVE_FP_T_QUADRUPLE)
	if (sizeof(d) == sizeof(d.v))	/* 128-bit */
	{
		if (big_endian)		/* 128-bit big endian */
			(void)fprintf(stderr,"%s: %g\t0x%08x_%08x_%08x_%08x\n",
				      s, d.v, d.i[0], d.i[1], d.i[2], d.i[3]);
		else			/* 128-bit little endian */
			(void)fprintf(stderr,"%s: %g\t0x%08x_%08x_%08x_%08x\n",
				      s, d.v, d.i[3], d.i[2], d.i[1], d.i[0]);
	}
	else if (sizeof(fp_t) == sizeof(double)) /* long double masquerading as double */
		(void)fprintf(stderr,"%s: %g\t0x%08x_%08x\n",
			      s, d.v, d.i[1-big_endian], d.i[big_endian]);
	else				/* 80-bit Intel x86 format */
		(void)fprintf(stderr,"%s: %g\t0x%04x_%08x_%08x\n",
			      s, d.v, (d.i[2] & 0xffff), d.i[1], d.i[0]);
#endif

#if defined(HAVE_FP_T_SINGLE)
	(void)fprintf(stderr,"%s: %g\t0x%08x\n", s, d.v, d.i[0]);
#endif
}
#endif

fp_t
Macheps(fp_t x)
{
	/* Macheps(x) returns the generalized machine epsilon of x,
	   the smallest number which, when added to x, produces a sum
	   that still differs from x: (x + macheps(x)) != x.

	   NB: This code guarantees these results:
		  macheps(Inf)  -> NaN
		  macheps(-Inf) -> NaN
		  macheps(NaN)  -> NaN
		  macheps(-NaN) -> -NaN
	*/

	fp_t epsilon;
	fp_t temp;
	fp_t temp__;

#if !defined(HAVE_NAN_BOTCH)
	static fp_t macheps_1 = FP(0.0);

	if ((x == FP(1.0)) && (macheps_1 != FP(0.0))) /* handle common case fast */
		return (macheps_1);
#endif

	if (IsNaN(x))
		return (x);

	if (IsInf(x))
		return (NaN());

	if (x == FP(0.0))
		epsilon = FP(1.0);
	else
		epsilon = fabs(x);

#if defined(DEBUG_MACHEPS)
	Dump("macheps(): 1: x = ", x);
	Dump("macheps(): 1: epsilon = ", epsilon);
	Dump("macheps(): 1: epsilon/BASE = ", epsilon/BASE);
#if 1
	temp = STORE(x + STORE(epsilon/BASE));
#else
	temp = STORE(x + epsilon/BASE);
#endif
	Dump("macheps(): 1: temp = ", temp);
	while (STORE(temp) != x)
	{
		epsilon /= BASE;
		Dump("macheps(): 2: epsilon = ", epsilon);
#if 1
		temp = STORE(x + STORE(epsilon/BASE));
#else
		temp = STORE(x + epsilon/BASE);
#endif
		Dump("macheps(): 2: temp = ", temp);
	}
#else
	while (STORE(x + STORE(epsilon/BASE)) != x)
		epsilon /= BASE;
#endif

	/* purify epsilon to eliminate all but high-order bit */
	temp = STORE(x + epsilon);
	if (IsInf(temp))/* x == MAXNORMAL: avoid overflow in purification */
		epsilon = STORE(x  + STORE(epsilon - x));
	else
		epsilon = STORE(temp - x);

#if !defined(HAVE_NAN_BOTCH)
	if (x == FP(1.0))			/* remember common case */
		macheps_1 = epsilon;
#endif

	return (epsilon);
}

fp_t
MaxNormal(void)
{
	static fp_t maxnormal = FP(0.0);

	if (maxnormal == FP(0.0))	      /* happens only on first call */
		maxnormal = (BASE * ((FP(1.0) - Pow(BASE, -P)) * Pow(BASE, EMAX)));
	return (maxnormal);
}

fp_t
MaxSubnormal(void)
{
	static fp_t maxsubnormal = FP(0.0);

	if (maxsubnormal == FP(0.0))	/* happens only on first call */
	{
		maxsubnormal = (FP(1.0) - Pow(BASE, -(P - FP(1.0)))) * MinNormal();
		if (maxsubnormal == FP(0.0)) /* then this system lacks subnormals */
			maxsubnormal = Macheps(FP(0.0));
	}
	return (maxsubnormal);
}

fp_t
MinNormal(void)
{
	static fp_t minnormal = FP(0.0);

	if (minnormal == FP(0.0))	      /* happens only on first call */
		minnormal = Pow(BASE, EMIN);
	return (minnormal);
}

fp_t
MinSubnormal(void)
{
	/* Return the minimimum subnormal number.  If subnormals are
	   not supported, then return the minimim normal number instead. */
	static fp_t minsubnormal = FP(0.0);

	if (minsubnormal == FP(0.0))	/* normally happens only on first call */
	{
		/* This code works for IEEE 754 (with or without subnormals),
		   and also non-IEEE 754. */
		minsubnormal = Macheps(FP(0.0));
	}
	return (minsubnormal);
}

fp_t
NaN(void)
{
	static fp_t nan = FP(0.0);
	fp_t temp__;

	if (nan == FP(0.0))	/* normally happens only on first call */
	{
#if defined(HAVE_IEEE_754)
		nan = STORE(FP(0.0));
		nan /= STORE(FP(0.0));
#else
		/* ISO/IEC 9899:1999(E) Programming languages -- C, Second
		edition 1999-12-01, says in section 7.12.11.2 on p. 236: ``If
		the implementation does not support quiet NaNs, the functions
		[nan(""), nanf(""), nanl("")] return zero.'' */
#endif
	}
	return (nan);
}

fp_t
Nearest(fp_t x, fp_t y)
{
#if defined(HAVE_NEAREST)
	return (nearest(x,y));
#else
	return (Nextafter(x,y));		/* TO BE FIXED: incorrect translation */
#endif
}

fp_t
Nextafter(fp_t x, fp_t y)
{
	/* hoc testing showed that SGI IRIX 6.5 native nextafter()
	   does not handle Infinity and NaN arguments as required by
	   IEEE 754.  We therefore handle the special cases ourselves,
	   and use the native one only if it is available. */
	if (IsNaN(x))
		return (NaN());
	else if (IsNaN(y))
		return (NaN());
	else if (IsInf(x) && (x > FP(0.0)) && ((y < FP(0.0)) || (y < x)))
		return (MaxNormal());
	else if (IsInf(x) && (x < FP(0.0)) && ((y > FP(0.0)) || (y > x)))
		return (-MaxNormal());
	else if (IsInf(x) && (x == y))
		return (x);
	else if ((x == MaxNormal()) && (x < y))
		return (Infinity());
	else if ((x == -MaxNormal()) && (x > y))
		return (-Infinity());

#if defined(HAVE_NEXTAFTER) && defined(HAVE_FP_T_DOUBLE) /* cannot substitute alternate precision for this one! */
	else
		return (nextafter(x,y));
#else
	else if (x < y)
		return (x + Macheps(x));
	else if (x > y)
		return (x - Macheps(-x));
	else /* (x == y) */
		return (x);
#endif
}

fp_t
Nint(fp_t x)
{
	return ((x >= FP(0.0)) ?
		(fp_t)((LONG_LONG)(x + FP(0.5))) :
		(fp_t)((LONG_LONG)(x - FP(0.5))));
}

fp_t
QNaN(void)
{
	return (NaN());
}

fp_t
Remainder(fp_t x, fp_t y)
{
#if defined(HAVE_REMAINDER)
	return (remainder(x,y));
#else
	execerror("remainder(x) is not available on this system", (const char*)NULL);
	return (FP(0.0));			/* NOT REACHED */
#endif
}

#if defined(HAVE_FP_T_QUADRUPLE)
fp_t
remainderl(fp_t x, fp_t y)
{
	fp_t result;

	if (y == FP(0.0))
		result = QNaN();
	else if (IsNaN(x))
		result = x;
	else if (IsNaN(y))
		result = y;
	else if (IsInf(x))
		result = QNaN();
	else if (IsInf(y))
		result = x;
	else
	{
		/* TO DO: What should happen when x/y is not representable as an integer? */
		LONG_LONG n;

		n = (LONG_LONG)Nint(x/y);
		if (fabs((fp_t)n - x/y) == FP(0.5)) /* then must ensure that n is even */
		{
			if (n < 0)
				n = (n - 1) & ~1;
			else
				n = (n + 1) & ~1;
		}
		result = x - (fp_t)n * y;
	}
	return (result);
}
#endif

fp_t
Rint(fp_t x)
{
#if defined(HAVE_RINT)
	return (rint(x));
#else
	execerror("rint(x) is not available on this system", (const char*)NULL);
	return (FP(0.0));			/* NOT REACHED */
#endif
}

fp_t
Scalb(fp_t x, fp_t y)
{
	y = Integer(y);		/* to match documentation in help_scalb() */
				/* and get consistency across platforms */
				/* NB: Use Integer(), not (LONG_LONG)(), to */
				/* handle NaN as documented */
#if defined(HAVE_SCALB)
	return (scalb(x,y));
#else
	return (x * pow(BASE, y));
#endif
}

fp_t
Significand(fp_t x)
{
	fp_t result;
	fp_t temp__;

#if defined(HAVE_SIGNIFICAND)
	result = significand(x);

	/* Some systems produce incorrect signs from significand(). */

	if ((result == FP(0.0)) && (copysign(FP(1.0), x) == FP(-1.0)))
	{
		result = FP(0.0);
		result = -result;	/* generate negative zero */
	}
#else
	/* Scale subnormal numbers into the normal range to avoid
	problems with subnormals in Trunc() and Log2() (e.g.,
	Compaq/DEC Alpha OSF/1 4.0). */

	if (IsNaN(x))
		result = copysign(FP(1.0),x) * NaN();
	else if (IsInf(x))
		result = copysign(FP(1.0),x) * Infinity();
	else if (x == FP(0.0))
		result = copysign(FP(1.0),x) * STORE(FP(0.0));
	else
	{
		FP_Parts d;
		fp_t xabs;
		int big_endian = IsBigEndian();

		xabs = (x < FP(0.0)) ? -x : x;

#if defined(HAVE_FP_T_DOUBLE)
		if (xabs < MinNormal())	/* scale to force normalization */
			x *= TWOTO52;
		d.v = x;
		d.i[1-big_endian] &= UL(0x000fffff);
		d.i[1-big_endian] |= (x < FP(0.0)) ? UL(0xbff00000) : UL(0x3ff00000);
#endif

#if defined(HAVE_FP_T_QUADRUPLE)
		if (xabs < MinNormal())	/* scale to force normalization */
		{
			if (sizeof(d) == sizeof(d.v))	/* 128-bit */
				x *= TWOTO112;
			else if (sizeof(fp_t) == sizeof(double)) /* long double masquerading as double */
				x *= TWOTO52;
			else				/* 80-bit Intel x86 format */
				x *= TWOTO64;
		}
		d.v = x;
		if (sizeof(d) == sizeof(d.v))	/* 128-bit */
		{
			d.i[3*(1-big_endian)] &= UL(0x0000ffff);
			d.i[3*(1-big_endian)] |= (x < FP(0.0)) ? UL(0xbfff0000) : UL(0x3fff0000);
		}
		else if (sizeof(fp_t) == sizeof(double)) /* long double masquerading as double */
		{
			d.i[1-big_endian] &= UL(0x000fffff);
			d.i[1-big_endian] |= (x < FP(0.0)) ? UL(0xbff00000) : UL(0x3ff00000);
		}
		else				/* 80-bit Intel x86 format */
		{
			d.i[2] &= UL(0xffff0000);
			d.i[2] |= (x < FP(0.0)) ? UL(0xbfff) : UL(0x3fff);
		}
#endif

#if defined(HAVE_FP_T_SINGLE)
		if (xabs < MinNormal())	/* scale to force normalization */
			x *= TWOTO23;
		d.v = x;
		d.i[0] &= UL(0x007fffff);
		d.i[0] |= (x < FP(0.0)) ? UL(0xbf800000) : UL(0x3f800000);
#endif

		result = d.v;
	}
#endif

	return (result);
}

#if defined(HAVE_FP_T_SINGLE)
static float
SNaN32(int count)
{
	SP_Parts d;
	fp_t temp__;
	d.v = NaN();

	d.i[0] = (d.i[0] & UL(0xff800000)) | (count & UL(~0xff800000));

#if defined(FP_ARCH_ALPHA)
	d.i[0] &= UL(~0x00400000);
#elif defined(FP_ARCH_SPARC)
	d.i[0] &= UL(~0x00400000);
#elif defined(FP_ARCH_I860)
	d.i[0] &= UL(~0x00400000);
#elif defined(FP_ARCH_POWER)
	d.i[0] &= UL(~0x00400000);
#elif defined(FP_ARCH_IA64)
	d.i[0] &= UL(~0x00400000);
#elif defined(FP_ARCH_PA_RISC)
	d.i[0] |=  0x00400000;
#elif defined(FP_ARCH_IA32)
	(void)STORE(d.v); /* No signaling NaN in the Intel IA-32 architecture */
#elif defined(FP_ARCH_MIPS)
	(void)STORE(d.v);      /* No signaling NaN in the MIPS architecture */
#else  /* fall back to majority style, which could still be wrong */
	d.i[0] &= UL(~0x00400000);
#endif

	return (d.v);
}

#endif /* defined(HAVE_FP_T_SINGLE) */

static double
SNaN64(int count)
{
	DP_Parts d;
	int big_endian = IsBigEndian();
	fp_t temp__;

	d.v = (double)NaN();

	d.i[big_endian] = count;

#if defined(FP_ARCH_ALPHA)
	d.i[1 - big_endian] &= UL(~0x000fffff);
#elif defined(FP_ARCH_SPARC)
	d.i[1 - big_endian] &= UL(~0x000fffff);
#elif defined(FP_ARCH_I860)
	d.i[1 - big_endian] &= UL(~0x000fffff);
#elif defined(FP_ARCH_POWER)
	d.i[1 - big_endian] &= UL(~0x000fffff);
#elif defined(FP_ARCH_IA64)
	d.i[1 - big_endian] &= UL(~0x000fffff);
#elif defined(FP_ARCH_PA_RISC)
	d.i[1 - big_endian] |=  0x000fffff;
#elif defined(FP_ARCH_IA32)
	(void)STORE(d.v); /* No signaling NaN in the Intel IA-32 architecture */
#elif defined(FP_ARCH_MIPS)
	(void)STORE(d.v);      /* No signaling NaN in the MIPS architecture */
#else  /* fall back to majority style, which could still be wrong */
	d.i[1 - big_endian] &= UL(~0x000fffff);
#endif
	return (d.v);
}

#if defined(HAVE_FP_T_QUADRUPLE)
static fp_t
SNaN128(int count)
{
	QP_Parts d;
	int big_endian = IsBigEndian();
	fp_t temp__;

	d.v = NaN();

	d.i[3*big_endian] = count;
	d.i[1] = 0;
	if (sizeof(d) == sizeof(d.v))	/* 128-bit */
		d.i[2] = 0;
	else				/* 80-bit  */
		/* NO-OP */;

#if defined(FP_ARCH_ALPHA)
	d.i[3*(1 - big_endian)] &= UL(~0x0000bfff);
#elif defined(FP_ARCH_SPARC)
	d.i[3*(1 - big_endian)] &= UL(~0x0000bfff);
#elif defined(FP_ARCH_I860)
	d.i[3*(1 - big_endian)] &= UL(~0x0000bfff);
#elif defined(FP_ARCH_POWER)
	d.i[3*(1 - big_endian)] &= UL(~0x0000bfff);
#elif defined(FP_ARCH_IA64)
	d.i[3*(1 - big_endian)] &= UL(~0x0000bfff);
#elif defined(FP_ARCH_PA_RISC)
	d.i[3*(1 - big_endian)] |=  0x0000bfff;
#elif defined(FP_ARCH_IA32)
	(void)STORE(d.v); /* No signaling NaN in the Intel IA-32 architecture */
#elif defined(FP_ARCH_MIPS)
	(void)STORE(d.v);      /* No signaling NaN in the MIPS architecture */
#else  /* fall back to majority style, which could still be wrong */
	d.i[3*(1 - big_endian)] &= UL(~0x0000bfff);
#endif

	return (d.v);
}
#endif /* defined(HAVE_FP_T_QUADRUPLE) */

fp_t
SNaN(void)
{					/* return a distinct SNaN on each call */
	fp_t maybe_NaN = NaN();
	static unsigned int SNaN_count = 0;

	if (IsNaN(maybe_NaN))		/* false on non IEEE 754 systems */
	{
		FP_Parts d;
		int big_endian = IsBigEndian();

		d.v = maybe_NaN;

		/* A NaN must have a nonzero significand, so we
		   choose to create up to 2^23 - 1 unique SNaNs.
		   For the moment, only two are generated by hoc,
		   for the constants SNAN and SNaN. */
		SNaN_count++;
		if (SNaN_count >= (int)0x7fffff) /* then 23-bit counter wrapped */
			SNaN_count = 1;

#if defined(HAVE_FP_T_DOUBLE)
		d.v = SNaN64(SNaN_count);
#endif

#if defined(HAVE_FP_T_QUADRUPLE)
		if (sizeof(fp_t) == sizeof(double)) /* long double masquerading as double */
			d.v = (fp_t)SNaN64(SNaN_count); /* NB: cast is no-op */
		else
			d.v = SNaN128(SNaN_count);
#endif

#if defined(HAVE_FP_T_SINGLE)
		d.v = SNaN32(SNaN_count);
#endif

		maybe_NaN = d.v;
	}
	return (maybe_NaN);
}

fp_t
Trunc(fp_t x)
{
	fp_t result;

#if defined(HAVE_TRUNC)
	result = trunc(x);
#else
	result = Integer(x);
#endif

	/* Some systems produce incorrect signs from trunc(). */

	if ((result == FP(0.0)) && (x < FP(0.0)))
	{
		result = FP(0.0);
		result = -result;	/* generate negative zero */
	}
	return (result);
}

fp_t
Unordered(fp_t x, fp_t y)
{
	return (IsNaN(x) || IsNaN(y));
}
@


1.12
log
@Add preprocessor conditional in Nextafter() to avoid use of native
nextafter() on SGI systems, since that version fails to handle NaN and
Infinity arguments correctly.
@
text
@d24 5
a28 1
EXTERN fp_t trunc ARGS((fp_t));		/* all GNU/Linux */
d32 5
a36 1
EXTERN int ilogb ARGS((fp_t));		/* Compaq/DEC OSF/1 */
d38 5
a42 1
EXTERN fp_t nearest ARGS((fp_t,fp_t));	/* Compaq/DEC OSF/1 */
@


1.11
log
@Remove one unneeded typecast.
@
text
@d155 1
a155 1
#if defined(HAVE_COPYSIGN)
d1022 4
a1025 3
#if defined(HAVE_NEXTAFTER) && defined(HAVE_FP_T_DOUBLE) /* cannot substitute alternate precision for this one! */
	return (nextafter(x,y));
#else
d1040 5
@


1.10
log
@Add two STORE() wrappers in Ceil().
@
text
@d598 1
a598 1
			return ((fp_t)IsQNaN64(x)); /* NB: cast is no-op */
@


1.9
log
@Provide a new implementation of Ceil() that appears to be considerably
cleaner and more portable than the bit-fiddling version that is used
in the Sun fdlibm (freely-distributable math library), and use it to
implement Floor().  The new code does not require conversion to an
integer data type, thereby eliminating the problems of wraparound to
negative values when the floating-point value is too large to
represent as an integer.
@
text
@d84 3
a86 1
			y = (base_to_Pm1 + xabs) - base_to_Pm1;
@


1.8
log
@Add special code in Copysign() to handle inverted sign of NaN on Intel
IA-32 and HP/Compaq/DEC Alpha architectures.

Add implementation of copysign() for those systems that lack it.
@
text
@d58 11
d70 20
d91 1
a91 1
		y++;
d260 1
d262 3
@


1.7
log
@Add some forgotten declarations of temp__ (used by STORE()).
@
text
@d90 28
d121 1
d123 10
a133 3
#else
	execerror("copysign(x,y) is not available on this system", (const char*)NULL);
	return (FP(0.0));			/* NOT REACHED */
d135 5
@


1.6
log
@Update to use revised store() function.
@
text
@d410 1
d444 1
d478 1
d539 1
d572 1
d605 1
d1059 1
d1146 1
d1181 1
d1215 1
@


1.5
log
@Simplify code in IsQNaN(), IsSNaN(), and SNaN() by splitting out the
three precision-dependent blocks into new private functions,
IsQNaN{32,64,128}(), IsSNaN{32,64,128}(), and SNaN{32,64,128}(), and
using the new FP_ARCH_xxx symbols from fp_arch.h, instead of
compiler-dependent ones.

Add code to handle the case of long double masquerading as double.

Fix bug in Nextafter() in one branch of the long if statement: the old
code had macheps(x)/BASE, which is incorrect when x == 0.
@
text
@d39 2
d223 2
d226 2
a227 1
		infinity = store(FP(1.0)) / store(FP(0.0));
d301 2
d307 1
a307 1
	/* the store() subterfuge does not produce the right answer. */
d311 1
d339 1
a339 1
	return ((fp_t)(store(x) != x));	/* should thwart optimizers */
d426 1
a426 1
	(void)store(d.v);	/* avoid complaints about unused d */
d429 1
a429 1
	(void)store(d.v);	/* avoid complaints about unused d */
d432 1
a432 1
	(void)store(d.v);	/* avoid complaints about unused d */
d459 1
a459 1
	(void)store(d.v);	/* avoid complaints about unused d */
d462 1
a462 1
	(void)store(d.v);	/* avoid complaints about unused d */
d492 1
a492 1
	(void)store(d.v);	/* avoid complaints about unused d */
d495 1
a495 1
	(void)store(d.v);	/* avoid complaints about unused d */
d552 1
a552 1
	(void)store(d.v);	/* avoid complaints about unused d */
d555 1
a555 1
	(void)store(d.v);	/* avoid complaints about unused d */
d584 1
a584 1
	(void)store(d.v);	/* avoid complaints about unused d */
d587 1
a587 1
	(void)store(d.v);	/* avoid complaints about unused d */
d616 1
a616 1
		(void)store(d.v);	/* avoid complaints about unused d */
d619 1
a619 1
		(void)store(d.v);	/* avoid complaints about unused d */
d793 1
d818 1
a818 1
	temp = store(x + store(epsilon/BASE));
d820 1
a820 1
	temp = store(x + epsilon/BASE);
d823 1
a823 1
	while (store(temp) != x)
d828 1
a828 1
		temp = store(x + store(epsilon/BASE));
d830 1
a830 1
		temp = store(x + epsilon/BASE);
d835 1
a835 1
	while (store(x + store(epsilon/BASE)) != x)
d840 1
a840 1
	temp = store(x + epsilon);
d842 1
a842 1
		epsilon = store(x  + store(epsilon - x));
d844 1
a844 1
		epsilon = store(temp - x);
d908 1
d913 2
a914 1
		nan = store(FP(0.0)) / store(FP(0.0));
d1074 1
a1074 1
		result = copysign(FP(1.0),x) * store(FP(0.0));
d1156 1
a1156 1
	(void)store(d.v); /* No signaling NaN in the Intel IA-32 architecture */
d1158 1
a1158 1
	(void)store(d.v);      /* No signaling NaN in the MIPS architecture */
d1191 1
a1191 1
	(void)store(d.v); /* No signaling NaN in the Intel IA-32 architecture */
d1193 1
a1193 1
	(void)store(d.v);      /* No signaling NaN in the MIPS architecture */
d1229 1
a1229 1
	(void)store(d.v); /* No signaling NaN in the Intel IA-32 architecture */
d1231 1
a1231 1
	(void)store(d.v);      /* No signaling NaN in the MIPS architecture */
@


1.4
log
@Add support for three precisions, and implementations of the new
Class(), MaxSubnormal(), and Unordered() functions.  Add private
ldexpf(), ldexpl(), and remainderl() implementations.
@
text
@d124 5
d154 2
d317 4
d397 100
a501 4
		FP_Parts d;
		int big_endian = IsBigEndian();

		d.v = x;
d504 1
a504 20
#if defined(__alpha)
		return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) != 0));
#elif defined(__sparc)
		return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) != 0));
#elif defined(__i860)
		return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) != 0));
#elif defined(_POWER) || defined(__PPC) || defined(__powerpc)
		return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) != 0));
#elif defined(__ia64)
		return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) != 0));
#elif defined(__hppa)
		return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) == 0));
#elif defined(__i386) || defined(__i486) || defined(__i586) || defined(__i686)
		(void)store(d.v);	/* avoid complaints about unused d */
		return ((fp_t)(big_endian == big_endian)); /* avoids compiler warnings about unused big_endian*/
#elif defined(__mips)
		(void)store(d.v);	/* avoid complaints about unused d */
		return ((fp_t)(big_endian == big_endian)); /* avoids compiler warnings about unused big_endian*/
#else  /* fall back to majority style, which could still be wrong */
		return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) != 0));
a505 1
#endif /* defined(HAVE_FP_T_DOUBLE) */
d508 4
a511 20
#if defined(__alpha)
		return ((fp_t)((d.i[3*(1 - big_endian)] & UL(0x00008000)) != 0));
#elif defined(__sparc)
		return ((fp_t)((d.i[3*(1 - big_endian)] & UL(0x00008000)) != 0));
#elif defined(__i860)
		return ((fp_t)((d.i[3*(1 - big_endian)] & UL(0x00008000)) != 0));
#elif defined(_POWER) || defined(__PPC) || defined(__powerpc)
		return ((fp_t)((d.i[3*(1 - big_endian)] & UL(0x00008000)) != 0));
#elif defined(__ia64)
		return ((fp_t)((d.i[3*(1 - big_endian)] & UL(0x00008000)) != 0));
#elif defined(__hppa)
		return ((fp_t)((d.i[3*(1 - big_endian)] & UL(0x00008000)) == 0));
#elif defined(__i386) || defined(__i486) || defined(__i586) || defined(__i686)
		(void)store(d.v);	/* avoid complaints about unused d */
		return ((fp_t)(big_endian == big_endian)); /* avoids compiler warnings about unused big_endian*/
#elif defined(__mips)
		(void)store(d.v);	/* avoid complaints about unused d */
		return ((fp_t)(big_endian == big_endian)); /* avoids compiler warnings about unused big_endian*/
#else  /* fall back to majority style, which could still be wrong */
		return ((fp_t)((d.i[3*(1 - big_endian)] & UL(0x00008000)) != 0));
a512 1
#endif /* defined(HAVE_FP_T_QUADRUPLE) */
d515 1
a515 20
#if defined(__alpha)
		return ((fp_t)((d.i[0] & UL(0x00400000)) != 0));
#elif defined(__sparc)
		return ((fp_t)((d.i[0] & UL(0x00400000)) != 0));
#elif defined(__i860)
		return ((fp_t)((d.i[0] & UL(0x00400000)) != 0));
#elif defined(_POWER) || defined(__PPC) || defined(__powerpc)
		return ((fp_t)((d.i[0] & UL(0x00400000)) != 0));
#elif defined(__ia64)
		return ((fp_t)((d.i[0] & UL(0x00400000)) != 0));
#elif defined(__hppa)
		return ((fp_t)((d.i[0] & UL(0x00400000)) == 0));
#elif defined(__i386) || defined(__i486) || defined(__i586) || defined(__i686)
		(void)store(d.v);	/* avoid complaints about unused d */
		return ((fp_t)(big_endian == big_endian)); /* avoids compiler warnings about unused big_endian*/
#elif defined(__mips)
		(void)store(d.v);	/* avoid complaints about unused d */
		return ((fp_t)(big_endian == big_endian)); /* avoids compiler warnings about unused big_endian*/
#else  /* fall back to majority style, which could still be wrong */
		return ((fp_t)((d.i[0] & UL(0x00400000)) != 0));
a516 1
#endif /* defined(HAVE_FP_T_DOUBLE) */
d523 3
a525 2
fp_t
IsSNaN(fp_t x)
d527 1
a527 4
	if (IsNaN(x))
	{
		FP_Parts d;
		int big_endian = IsBigEndian();
d529 1
a529 1
		d.v = x;
d531 18
a548 19
#if defined(HAVE_FP_T_DOUBLE)
#if defined(__alpha)
		return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) == 0));
#elif defined(__sparc)
		return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) == 0));
#elif defined(__i860)
		return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) == 0));
#elif defined(_POWER) || defined(__PPC) || defined(__powerpc)
		return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) == 0));
#elif defined(__ia64)
		return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) == 0));
#elif defined(__hppa)
		return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) != 0));
#elif defined(__i386) || defined(__i486) || defined(__i586) || defined(__i686)
		(void)store(d.v);	/* avoid complaints about unused d */
		return ((fp_t)(big_endian == big_endian)); /* avoids compiler warnings about unused big_endian*/
#elif defined(__mips)
		(void)store(d.v);	/* avoid complaints about unused d */
		return ((fp_t)(big_endian == big_endian)); /* avoids compiler warnings about unused big_endian*/
d550 3
a552 1
		return ((fp_t)((d.i[1 - big_endian] & UL(0x00080000)) == 0));
d554 29
d584 1
d587 9
a595 1
#if defined(__alpha)
d597 1
a597 1
#elif defined(__sparc)
d599 1
a599 1
#elif defined(__i860)
d601 1
a601 1
#elif defined(_POWER) || defined(__PPC) || defined(__powerpc)
d603 1
a603 1
#elif defined(__ia64)
d605 1
a605 1
#elif defined(__hppa)
d607 1
a607 1
#elif defined(__i386) || defined(__i486) || defined(__i586) || defined(__i686)
d610 1
a610 1
#elif defined(__mips)
d616 18
d637 1
a637 21
#if defined(__alpha)
		return ((fp_t)((d.i[0] & UL(0x00400000)) == 0));
#elif defined(__sparc)
		return ((fp_t)((d.i[0] & UL(0x00400000)) == 0));
#elif defined(__i860)
		return ((fp_t)((d.i[0] & UL(0x00400000)) == 0));
#elif defined(_POWER) || defined(__PPC) || defined(__powerpc)
		return ((fp_t)((d.i[0] & UL(0x00400000)) == 0));
#elif defined(__ia64)
		return ((fp_t)((d.i[0] & UL(0x00400000)) == 0));
#elif defined(__hppa)
		return ((fp_t)((d.i[0] & UL(0x00400000)) != 0));
#elif defined(__i386) || defined(__i486) || defined(__i586) || defined(__i686)
		(void)store(d.v);	/* avoid complaints about unused d */
		return ((fp_t)(big_endian == big_endian)); /* avoids compiler warnings about unused big_endian*/
#elif defined(__mips)
		(void)store(d.v);	/* avoid complaints about unused d */
		return ((fp_t)(big_endian == big_endian)); /* avoids compiler warnings about unused big_endian*/
#else  /* fall back to majority style, which could still be wrong */
		return ((fp_t)((d.i[0] & UL(0x00400000)) == 0));
#endif
a731 1

d746 12
a757 6
	if (big_endian)
		(void)fprintf(stderr,"%s: %g\t0x%08x_%08x_%08x_%08x\n",
			      s, d.v, d.i[0], d.i[1], d.i[2], d.i[3]);
	else if (sizeof(d) == sizeof(d.v))	/* 128-bit little endian */
		(void)fprintf(stderr,"%s: %g\t0x%08x_%08x_%08x_%08x\n",
			      s, d.v, d.i[3], d.i[2], d.i[1], d.i[0]);
a765 1

a768 1

d927 1
a927 1
#if defined(HAVE_NEXTAFTER)
d945 1
a945 1
		return (x + macheps(x));
d947 1
a947 1
		return (x - macheps(x)/BASE);
d1085 2
d1096 5
d1123 106
d1231 1
a1231 1
{
d1251 1
a1251 20
		d.i[big_endian] = SNaN_count;
#if defined(__alpha)
		d.i[1 - big_endian] &= UL(~0x00080000);
#elif defined(__sparc)
		d.i[1 - big_endian] &= UL(~0x00080000);
#elif defined(__i860)
		d.i[1 - big_endian] &= UL(~0x00080000);
#elif defined(_POWER) || defined(__PPC) || defined(__powerpc)
		d.i[1 - big_endian] &= UL(~0x00080000);
#elif defined(__ia64)
		d.i[1 - big_endian] &= UL(~0x00080000);
#elif defined(__hppa)
		d.i[1 - big_endian] |=  0x00080000;
#elif defined(__i386) || defined(__i486) || defined(__i586) || defined(__i686)
		(void)store(d.v); /* No signaling NaN in the Intel IA-32 architecture */
#elif defined(__mips)
		(void)store(d.v);      /* No signaling NaN in the MIPS architecture */
#else  /* fall back to majority style, which could still be wrong */
		d.i[1 - big_endian] &= UL(~0x00080000);
#endif
d1255 4
a1258 20
		d.i[3*big_endian] = SNaN_count;
#if defined(__alpha)
		d.i[3*(1 - big_endian)] &= UL(~0x00008000);
#elif defined(__sparc)
		d.i[3*(1 - big_endian)] &= UL(~0x00008000);
#elif defined(__i860)
		d.i[3*(1 - big_endian)] &= UL(~0x00008000);
#elif defined(_POWER) || defined(__PPC) || defined(__powerpc)
		d.i[3*(1 - big_endian)] &= UL(~0x00008000);
#elif defined(__ia64)
		d.i[3*(1 - big_endian)] &= UL(~0x00008000);
#elif defined(__hppa)
		d.i[3*(1 - big_endian)] |=  0x00008000;
#elif defined(__i386) || defined(__i486) || defined(__i586) || defined(__i686)
		(void)store(d.v); /* No signaling NaN in the Intel IA-32 architecture */
#elif defined(__mips)
		(void)store(d.v);      /* No signaling NaN in the MIPS architecture */
#else  /* fall back to majority style, which could still be wrong */
		d.i[3*(1 - big_endian)] &= UL(~0x00008000);
#endif
d1262 1
a1262 20
		d.i[0] = (d.i[0] & UL(0xff800000)) | (SNaN_count & UL(~0xff800000));
#if defined(__alpha)
		d.i[0] &= UL(~0x00400000);
#elif defined(__sparc)
		d.i[0] &= UL(~0x00400000);
#elif defined(__i860)
		d.i[0] &= UL(~0x00400000);
#elif defined(_POWER) || defined(__PPC) || defined(__powerpc)
		d.i[0] &= UL(~0x00400000);
#elif defined(__ia64)
		d.i[0] &= UL(~0x00400000);
#elif defined(__hppa)
		d.i[0] |=  0x00400000;
#elif defined(__i386) || defined(__i486) || defined(__i586) || defined(__i686)
		(void)store(d.v); /* No signaling NaN in the Intel IA-32 architecture */
#elif defined(__mips)
		(void)store(d.v);      /* No signaling NaN in the MIPS architecture */
#else  /* fall back to majority style, which could still be wrong */
		d.i[0] &= UL(~0x00400000);
#endif
@


1.3
log
@Add conditional for __osf__ to avoid clash on other systems, sigh...

Add missing (void) typecast on one fprintf() call.

Put macheps_1 handling inside conditionals to avoid compiler warnings.
@
text
@d3 4
d21 1
d23 1
a23 1
/* These functions are in -lm, but are missing from math.h, sigh... */
d25 1
d34 4
a37 1
#define TWOTO52	4503599627370496.0	/* 2^52 */
d64 25
d95 1
a95 1
	return (0.0);			/* NOT REACHED */
d103 1
a103 1
	DoubleParts d;
d108 1
a108 1
	xabs = (x < 0) ? -x : x;
d110 1
a110 1
	if (xabs < MinNormal())
d112 2
d116 20
d142 15
a156 1
	return ((fp_t)(((d.i[1-big_endian] & UL(0x7ff00000)) >> 20)) - 1023 + offset);
d158 1
a158 1
	return ((fp_t)Nint(Log2(x))); /* TO DO: implement efficiently for non-IEEE 754 systems */
d193 1
a193 1
	return (0.0);			/* NOT REACHED */
d210 1
a210 1
	static fp_t infinity = 0.0;
d212 1
a212 1
	if (infinity == 0.0)	/* normally happens only on first call */
d215 1
a215 1
		infinity = store(1.0) / store(0.0);
d237 1
a237 1
		return (0.0);		/* NOT REACHED */
d239 1
a239 1
	else if (x < 0.0)
d241 1
a241 1
	else /* (x >= 0.0) */
d249 2
a250 2
	DoubleParts d;
	d.v = 1.0;
d273 1
a273 1
		return (0.0);
d276 1
a276 1
	if (x < 0.0)
d278 4
a281 4
	if (x < 1.0)			/* small, so finite */
		return (0.0);
	else if ((x / 2.0) == x)	/* only Inf/2 == Inf */
		return (1.0);
d283 1
a283 1
		return (0.0);
d295 1
a295 1
	DoubleParts d;
d298 2
d303 16
d391 1
a391 1
		DoubleParts d;
d396 1
d418 49
d470 1
a470 1
		return (0.0);
d478 1
a478 1
		DoubleParts d;
d483 1
d505 49
d557 1
a557 1
		return (0.0);
d563 2
a564 2
	if (x == 0.0)
		return (0.0);
d566 1
a566 1
		return (0.0);
d568 1
a568 1
		return (0.0);
d572 1
a572 1
		return ((fp_t)(Exponent(x) <= -1023.0));
d574 1
a574 1
		return (0.0);
d585 1
a585 1
	return (x * pow(2.0,(fp_t)(int)y));
d589 59
d652 1
a652 1
	DoubleParts d;
d656 1
d659 18
d699 1
a699 1
	static fp_t macheps_1 = 0.0;
d701 1
a701 1
	if ((x == 1.0) && (macheps_1 != 0.0)) /* handle common case fast */
d711 2
a712 2
	if (x == 0.0)
		epsilon = 1.0;
d719 1
a719 1
	Dump("macheps(): 1: epsilon/2.0 = ", epsilon/2.0);
d721 1
a721 1
	temp = store(x + store(epsilon/2.0));
d723 1
a723 1
	temp = store(x + epsilon/2.0);
d728 1
a728 1
		epsilon /= 2.0;
d731 1
a731 1
		temp = store(x + store(epsilon/2.0));
d733 1
a733 1
		temp = store(x + epsilon/2.0);
d738 2
a739 2
	while (store(x + store(epsilon/2.0)) != x)
		epsilon /= 2.0;
d750 1
a750 1
	if (x == 1.0)			/* remember common case */
d760 1
a760 1
	static fp_t maxnormal = 0.0;
d762 4
a765 2
	if (maxnormal == 0.0)	/* normally happens only on first call */
	{
d767 4
a770 8
#if defined(HAVE_IEEE_754)
		maxnormal = (2.0*((1.0 - Pow(2.0,-53.0)) * Pow(2.0, 1023.0)));
#elif defined(DBL_MAX)
		maxnormal = DBL_MAX;
#else
		execerror("maximum normal number is not yet programmed in hoc for this system",
			  (const char*)NULL);
#endif
d772 5
d778 1
a778 1
	return (maxnormal);
d784 1
a784 4
	static fp_t minnormal = 0.0;

	if (minnormal == 0.0)	/* normally happens only on first call */
	{
d786 2
a787 7
#if defined(HAVE_IEEE_754)
		minnormal = Pow(2.0, -1022.0);
#else
		minnormal = Macheps(0.0);
#endif

	}
d796 1
a796 1
	static fp_t minsubnormal = 0.0;
d798 1
a798 1
	if (minsubnormal == 0.0)	/* normally happens only on first call */
d802 1
a802 1
		minsubnormal = Macheps(0.0);
d810 1
a810 1
	static fp_t nan = 0.0;
d812 1
a812 1
	if (nan == 0.0)	/* normally happens only on first call */
d815 1
a815 1
		nan = store(0.0) / store(0.0);
d846 1
a846 1
	else if (IsInf(x) && (x > 0.0) && ((y < 0.0) || (y < x)))
d848 1
a848 1
	else if (IsInf(x) && (x < 0.0) && ((y > 0.0) || (y > x)))
d859 1
a859 1
		return (x - macheps(x)/2.0);
d868 3
a870 3
	return ((x >= 0.0) ?
		(fp_t)((LONG_LONG)(x + 0.5)) :
		(fp_t)((LONG_LONG)(x - 0.5)));
d886 1
a886 1
	return (0.0);			/* NOT REACHED */
d890 35
d932 1
a932 1
	return (0.0);			/* NOT REACHED */
d946 1
a946 1
	return (x * pow(2.0, y));
d953 2
d956 9
a964 1
	return (significand(x));
d971 1
a971 1
		return (copysign(1.0,x) * NaN());
d973 3
a975 3
		return (copysign(1.0,x) * Infinity());
	else if (x == 0.0)
		return (copysign(1.0,x) * 0.0);
d978 1
a978 1
		DoubleParts d;
d982 3
a984 1
		xabs = (x < 0) ? -x : x;
d987 4
d992 24
d1017 5
a1021 3
		d.i[1-big_endian] &= UL(0x000fffff);
		d.i[1-big_endian] |= (x < 0.0) ? UL(0xbff00000) : UL(0x3ff00000);
		return (d.v);
d1024 2
d1036 1
a1036 1
		DoubleParts d;
d1042 1
a1042 1
		   choose to create up to 2^32 - 1 unique SNaNs.
d1046 2
a1047 2
		if (SNaN_count == 0)	/* then counter wrapped */
			SNaN_count++;
d1049 1
a1050 1

d1070 48
d1126 2
d1129 1
a1129 1
	return (trunc(x));
d1131 1
a1131 1
	return (Integer(x));
d1133 15
@


1.2
log
@Revise Macheps() to correctly handle the case of x == MAXNORMAL.
Implement nextafter() for non-IEEE 754 systems.
@
text
@d20 2
d26 1
d409 2
a410 2
	fprintf(stderr,"%s: %g\t0x%08x_%08x\n",
		s, d.v, d.i[1-big_endian], d.i[big_endian]);
d431 2
a434 1
#if !defined(HAVE_NAN_BOTCH)
d483 1
d486 1
@


1.1
log
@Initial revision
@
text
@d474 2
a475 4
	if (IsInf(temp))
	{	/* Generate NaN by subtracting infinities */
		epsilon = store(x - epsilon);
	}
d477 1
a477 4
	{
		epsilon = store(x + epsilon);
		epsilon = store(epsilon - x);
	}
d575 20
a594 2
	execerror("nextafter(x,y) is not available on this system", (const char*)NULL);
	return (0.0);			/* NOT REACHED */
@
