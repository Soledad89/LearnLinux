head	1.19;
access;
symbols;
locks
	beebe:1.19; strict;
comment	@ * @;


1.19
date	2002.08.08.01.25.09;	author beebe;	state Exp;
branches;
next	1.18;

1.18
date	2002.08.06.13.30.44;	author beebe;	state Exp;
branches;
next	1.17;

1.17
date	2002.08.05.11.21.08;	author beebe;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.31.17.26.09;	author beebe;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.30.18.27.59;	author beebe;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.28.01.40.34;	author beebe;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.20.23.13.26;	author beebe;	state Exp;
branches;
next	1.12;

1.12
date	2002.06.15.22.44.50;	author beebe;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.19.01.00.31;	author beebe;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.27.18.23.12;	author beebe;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.11.18.44.45;	author beebe;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.11.16.48.07;	author beebe;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.11.02.39.16;	author beebe;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.05.14.46.23;	author beebe;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.05.13.23.53;	author beebe;	state Exp;
branches;
next	1.4;

1.4
date	2002.01.04.17.44.52;	author beebe;	state Exp;
branches;
next	1.3;

1.3
date	2002.01.01.14.56.55;	author beebe;	state Exp;
branches;
next	1.2;

1.2
date	2001.12.12.01.31.45;	author beebe;	state Exp;
branches;
next	1.1;

1.1
date	2001.11.25.23.03.06;	author beebe;	state Exp;
branches;
next	;


desc
@Original version.
@


1.19
log
@Make first_symbol_name(), next_matching_symbol_name(), and
next_symbol_name() static.
@
text
@#include "hoc.h"
#include "xtab.h"

#if defined(HAVE_CTYPE_H)
#include <ctype.h>
#endif

#if defined(HAVE_STDIO_H)
#include <stdio.h>
#endif

#if defined(HAVE_STRING_H)
#include <string.h>
#endif

#undef MAX
#define MAX(a,b) (((a) > (b)) ? (a) : (b))

#define MSG_PREFIX "___msg_"	/* NB: 3+ leading underscores hide names from who("") output */

static Symbol *		symlist = (Symbol*)NULL;	/* symbol table: linked list */
static Symbol *		this_symbol = (Symbol*)NULL;	/* set by first_symbol_name() */
static Symbol *		this_sym = (Symbol*)NULL;	/* set by first_symbol() */

static const char *	title = (const char*)NULL;

static int		delete_symbol_unchecked ARGS((Symbol *));
static const char *	first_symbol_name ARGS((void));
static const char *	make_pname ARGS((Symbol *));
static const char *	next_matching_symbol_name ARGS((const char *));
static const char *	next_symbol_name ARGS((void));
static void		set_title ARGS((const char*));

#if defined(__cplusplus) || defined(c_plusplus)
extern "C"
#endif
int
cmpsym(const void *v1, const void *v2)
{
	return (strcmp((*(Symbol**)v1)->name, (*(Symbol**)v2)->name));
}

static int
compare_format_items(const char *s, const char *t)
{
	/* In order to prevent denial-of-service attacks from bogus
	   translations of format strings, we require that all %<CHAR>
	   sequences in s match those in t.  This is a small subset of
	   printf() formats: the only one needed so far in hoc message
	   translations is %s. */
	for (s = (const char*)strchr(s,'%');
	     s != (const char*)NULL;
	     s = (const char*)strchr(s + 1,'%'))
	{
		t = (const char *)strchr(t,'%');
		if (t == (const char*)NULL)
			return (0);
		if (s[1] != t[1])
			return (0);
	}
	return (1);
}

int
delete_symbol(Symbol *sp)
{	/* return 1 if deletion was allowed and successful, else 0 */

	/* TO DO: should we allow deletion of user-defined function/procedure names? */
	if (sp == (Symbol*)NULL)
		return (0);
	else if (((sp->type == VAR) || (sp->type == STRVAR)) && !(sp->immutable))
		return (delete_symbol_unchecked(sp));
	else
		return (0);
}

static int
delete_symbol_unchecked(Symbol *sp)
{	/* delete ANY requested symbol, and return 1 on success, and 0 on failure */
	Symbol *tp;
	Symbol *last;

	for (last = (Symbol*)NULL, tp = symlist; tp != (Symbol *)NULL; tp = tp->next)
	{
		if (tp == sp)
		{
			if (last == (Symbol*)NULL)
				symlist = symlist->next;
			else
				last->next = tp->next;
#if defined(DEBUG_LOOKUP)
			if (last == (Symbol*)NULL)
				tp = symlist;
			else
				tp = last;
			(void)fprintf(stderr,
				      "\t%%DEBUG: delete(%s): tp = %p\ttp->next = %p\tname = %s\tnext->name = %s\n\n",
				      sp->name, tp, tp->next, tp->name,
				      (tp->next == (Symbol*)NULL) ? "" : tp->next->name);
#endif
			efree((void*)sp);
			return (1);
		}
		last = tp;
	}

	return (0);
}

static void
dump_one_type(const char *pattern, int is_constant, int type)
{
	Symbol *sp;
	Symbol **symtab;
	size_t k;
	size_t max_symbols;
	size_t n_symtab;

	max_symbols = (size_t)0;
	for (sp = symlist; sp != (Symbol *)NULL; sp = sp->next)
		max_symbols++;

	symtab = (Symbol**)emalloc(max_symbols * sizeof(Symbol*));

	/* First build a table of matching symbols that we can later sort */
	for (n_symtab = 0, sp = symlist; sp != (Symbol *)NULL; sp = sp->next)
	{
		if (type != sp->type)
			continue;
		if (is_constant && !sp->immutable)
			continue;
		if (!is_constant && sp->immutable)
			continue;
		if ((sp->name != (const char*)NULL) &&
		    *sp->name &&
		    (n_symtab < max_symbols) &&
		    !is_hidden(sp->name,pattern) &&
		    is_match(sp->name,pattern))
			symtab[n_symtab++] = sp;
	}

	qsort(symtab, n_symtab, sizeof(Symbol*), cmpsym);
	for (k = 0; k < n_symtab; ++k)
	{
		if (title != (const char*)NULL)
		{
			prtext(msg_translate(title));
			title = (const char*)NULL;
		}
		prtext("\t\t");
		prtext2(symtab[k]->name, 23);
		switch (symtab[k]->type)
		{
		case NUMBER:		/* FALL THROUGH */
		case VAR:
			prtext("\t= ");
			prnum(symtab[k]->u.val);
			break;

		case STRING:		/* FALL THROUGH */
		case STRVAR:
			prtext("\t= ");
			prtext("\"");
			prtext(symtab[k]->u.str);
			prtext("\"");
			break;

		default:
			break;
		}
		prnl();
	}
	efree((void*)symtab);
}

void
dump_syms(const char *pattern)
{
	int old_precision;

	old_precision = get_precision();
	(void)set_precision(default_precision());

	if ((pattern != (char*)NULL) && (*pattern != '\0'))
	{
		prtext(msg_translate("Symbols matching "));
		prtext("\"");
		prtext(pattern);
		prtext("\":");
		prnl();
	}
	else
	{
		prtext(msg_translate("Symbols:"));
		prnl();
	}

	set_title("\n\tNumeric named constants:\n");
	dump_one_type(pattern, 1, NUMBER);
	dump_one_type(pattern, 1, VAR);

	set_title("\n\tString named constants:\n");
	dump_one_type(pattern, 1, STRING);
	dump_one_type(pattern, 1, STRVAR);

	set_title("\n\tNumeric variables:\n");
	dump_one_type(pattern, 0, NUMBER);
	dump_one_type(pattern, 0, VAR);

	set_title("\n\tString variables:\n");
	dump_one_type(pattern, 0, STRING);
	dump_one_type(pattern, 0, STRVAR);

	set_title("\n\tBuilt-in numeric functions (zero arguments):\n");
	dump_one_type(pattern, 0, BLTIN0);

	set_title("\n\tBuilt-in numeric functions (one numeric argument):\n");
	dump_one_type(pattern, 0, BLTIN1);

	set_title("\n\tBuilt-in numeric functions (one string argument):\n");
	dump_one_type(pattern, 0, BLTIN1S);

	set_title("\n\tBuilt-in numeric functions (one symbol argument):\n");
	dump_one_type(pattern, 0, BLTIN1I);

	set_title("\n\tBuilt-in numeric functions (two numeric arguments):\n");
	dump_one_type(pattern, 0, BLTIN2);

	set_title("\n\tBuilt-in numeric functions (two string arguments):\n");
	dump_one_type(pattern, 0, BLTIN2S);

	set_title("\n\tBuilt-in string functions (zero arguments):\n");
	dump_one_type(pattern, 0, STRBLTIN0);

	set_title("\n\tBuilt-in string functions (one string argument):\n");
	dump_one_type(pattern, 0, STRBLTIN1);

	set_title("\n\tBuilt-in string functions (one numeric argument):\n");
	dump_one_type(pattern, 0, STRBLTIN1N);

	set_title("\n\tBuilt-in string functions (two string arguments):\n");
	dump_one_type(pattern, 0, STRBLTIN2);

	set_title("\n\tBuilt-in string functions (one string and one numeric arguments):\n");
	dump_one_type(pattern, 0, STRBLTIN2SN);

	set_title("\n\tBuilt-in string functions (one string and two numeric arguments):\n");
	dump_one_type(pattern, 0, STRBLTIN3SNN);

	set_title("\n\tUser-defined functions:\n");
	dump_one_type(pattern, 0, FUNCTION);

	set_title("\n\tUser-defined procedures:\n");
	dump_one_type(pattern, 0, PROCEDURE);

	prnl();
	(void)set_precision(old_precision);
}

const char *
dupstr(const char *s)
{
	char *t;
	size_t len_t;

	if (s == (const char*)NULL)	/* treat NULL like "" */
		s = "";
	len_t = strlen(s) + 1;
	t = (char *)emalloc(len_t); /* +1 for '\0' */
	(void)strlcpy(t,s,len_t);
	return ((const char*)t);
}

void*
egrow(void* s, size_t *p_old_size, size_t element_size)
{	/* grow the dynamic array s, and update *p_old_size to the new size on return */
	size_t new_bytes;

	if (element_size < 1)		/* safety check */
		element_size = 1;
	new_bytes = 2 * (*p_old_size) * element_size;
	if (new_bytes == (size_t)0)
		new_bytes = (size_t)16 * element_size;
	else if (new_bytes >= (size_t)8192)
		new_bytes = (*p_old_size) * element_size + (size_t)MAX(8192, 4*element_size);
	s = erealloc(s, *p_old_size * element_size, new_bytes);
	*p_old_size = new_bytes / element_size;
	return (s);
}

#if defined(DEBUG_EMALLOC)

#define MAXBLOCKS 10000			/* enough for hoc testing */

static size_t nblocks = 0;

static struct memblock
{
	char *adr;
	size_t len;
	int in_use;
} blocks[MAXBLOCKS];

static const char magic[] = { 0xde, 0xad, 0xbe, 0xef, 0xca, 0xfe, 0xba, 0xbe };

static int
echeck(void)
{	/* return 1 if magic bytes are still intact in all allocated blocks, else 0 (in which case,
	   print an error message) */
	size_t k;

	for (k = 0; k < nblocks; ++k)
	{
		if (blocks[k].in_use &&
		    (memcmp((void*)(blocks[k].adr + blocks[k].len), (void*)magic, sizeof(magic)) != 0))
		{
			(void)fprintf(stderr, "ERROR: Corruption in block %u [%.8s]\n", k, blocks[k].adr);
			if (k > 0)
				(void)fprintf(stderr, "\t Previous block %u [%.8s]\n", k-1, blocks[k-1].adr);
			return (0);
		}
	}
	return (1);
}

void
efree(void *p)
{
	(void)fprintf(stderr, "%%DEBUG: efree(%p)\n", p);
	if (p != (void*)NULL)	/* because some older free() implementations fail with NULL arguments */
	{
		if (echeck())
		{
			size_t k;

			for (k = 0; k < nblocks; ++k)
			{
				if (blocks[k].in_use && (p == blocks[k].adr))
				{
					blocks[k].in_use = 0;
					free(p);
					return;
				}
			}
			(void)fprintf(stderr, "ERROR: Attempt to free unallocated block at %p\n", p);
		}
	}
}

void*
emalloc(size_t n)	/* check return from malloc */
{
	char *p;

	if (n == 0)	/* some malloc()'s fail for zero-size requests */
		n = 1;

	(void)echeck();

	p = (char*)malloc(n + sizeof(magic));

	if (p == 0)
		execerror("out of memory", (const char *)NULL);

	(void)memset(p, (int)0xee, n);

	blocks[nblocks].adr = p;
	blocks[nblocks].len = n;
	blocks[nblocks].in_use = 1;
	(void)memcpy((void*)(blocks[nblocks].adr + blocks[nblocks].len), (void*)magic, sizeof(magic));
	nblocks++;
	if (nblocks >= MAXBLOCKS)
		nblocks = 0;

	(void)fprintf(stderr, "%%DEBUG: emalloc(%u) -> %p\n", n, p);
	return (p);
}

void *
erealloc(void *p, size_t old_size, size_t new_size)
{
	void *old_p;
	old_p = p;
	p = emalloc(new_size);
	if ((old_size > 0) && (old_p != (char*)NULL))
		(void)memcpy(p, old_p, (old_size > new_size ? new_size : old_size));
	(void)fprintf(stderr, "%%DEBUG: erealloc(%p,%u,%u) -> %p\n", old_p, old_size, new_size, p);
	efree(old_p);
	return (p);
}

#else /* normal emalloc(), efree(), erealloc() */

void
efree(void *p)
{
	if (p != (void*)NULL)	/* because some older free() implementations fail with NULL arguments */
		free(p);
}

void*
emalloc(size_t n)	/* check return from malloc */
{
	char *p;

	if (n == 0)	/* some malloc()'s fail for zero-size requests */
		n = 1;

	p = (char*)malloc(n);

	if (p == 0)
		execerror("out of memory", (const char *)NULL);

	return p;
}

void *
erealloc(void *p, size_t old_size, size_t new_size)
{
	/* some realloc()'s do not handle NULL pointers, so use malloc() */
	return ((p == (void*)NULL) ? malloc(new_size) : realloc(p,new_size));
}

#endif /* defined(DEBUG_EMALLOC) */

static const char *
first_matching_symbol_name(const char *pattern)	/* NO LONGER USED */
{	/* return first symbol name matching pattern, or NULL */
	const char *name;

	name = first_symbol_name();
	while ((name != (const char*)NULL) && !is_match(name,pattern))
		name = next_symbol_name();
	return (name);
}

Symbol *
first_symbol(void)
{
	this_sym = symlist;
	return (this_sym);
}


static const char *
first_symbol_name(void)
{
	this_symbol = symlist;
	return (this_symbol->name);
}

const char *
first_symbol_pname(void)
{	/* return dynamic copy of first symbol, with optional () */
	this_symbol = symlist;
	return (make_pname(this_symbol));
}

void
free_symbol_table(void)
{
	Symbol *sp;
	Symbol *next_sp;

	for (sp = symlist; sp != (Symbol *)NULL; sp = next_sp)
	{
		next_sp = sp->next;
		if (sp->type == STRVAR)
			efree((void*)sp->u.str);
		efree((void*)sp->name);
		efree(sp);
	}
	symlist = (Symbol*)NULL;
}

fp_t
get_number(const char *name)
{
	/* Return the numeric value of name, or 0.0 if it does not
	   exist, or does not have a conversion to numeric */

	Symbol *sp;

	sp = lookup(name);
	if (sp == (Symbol *)NULL)
		return (FP(0.0));
	else if (sp->type == VAR)
		return (sp->u.val);
	else if (sp->type == STRVAR)
	{
		char *end_ptr;
		fp_t result;

		result = strton(sp->u.str, &end_ptr);
		return ((*end_ptr == '\0') ? FP(0.0) : result);
	}
	else
		return (FP(0.0));
}

const char *
get_string(const char *name)
{
	/* Return the string value of name, or "" if it does not
	   exist, or does not have a conversion to string.  The caller
	   should use dupstr() to make a copy if the result is needed
	   more than ephemerally.  */

	Symbol *sp;

	sp = lookup(name);
	if (sp == (Symbol *)NULL)
		return ("");
	else if (sp->type == STRVAR)
		return (sp->u.str);
	else if (sp->type == VAR)
		return (fmtnum(sp->u.val));
	else
		return ("");
}

Symbol*
install(const char* s, int t, fp_t d)  /* install s in symbol table */
{
	Symbol *sp;

	sp = (Symbol *)emalloc(sizeof(Symbol));
	memset(sp, 0, sizeof(Symbol));	/* ensure that all bits are zero */
	sp->name = dupstr(s);
	sp->builtin = 0;
	sp->immutable = 0;
	sp->type = t;
	sp->u.val = d;
	sp->next = symlist; /* put at front of list */
	symlist = sp;

#if defined(DEBUG_LOOKUP) || defined(DEBUG_INSTALL)
	(void)fprintf(stderr,
		      "%%DEBUG: install(%s,%d,%g)\tsp = %p\tsp->next = %p\tname = %s\tnext->name = %s\n",
		      s, t, (double)d, sp, sp->next, sp->name,
		      (sp->next == (Symbol*)NULL) ? "" : sp->next->name);
#endif

	return sp;
}

Symbol*
install_const_number(const char* s, fp_t d)  /* install s in symbol table */
{
	Symbol *sp;

	sp = install(s, VAR, d);
	make_immutable(sp);
	return sp;
}

Symbol*
install_const_string(const char* s, const char *value)  /* install s in symbol table */
{
	Symbol *sp;

	sp = install_string(s, value);
	make_immutable(sp);
	return sp;
}

Symbol*
install_number(const char* s, fp_t d)	/* install s in symbol table */
{
	Symbol *sp;

	sp = install(s, VAR, d);
	sp->immutable = 0;
	return sp;
}

Symbol*
install_string(const char* s, const char *value)  /* install s in symbol table */
{
	Symbol *sp;

	sp = install(s, VAR, FP(0.0));
	sp->immutable = 0;
	sp->type = STRVAR;
	sp->u.str = dupstr(value);
	return sp;
}

int
is_debug(const char *name)
{
	Symbol *sp;

	sp = lookup(name);
	return ((sp != (Symbol*)NULL) && (sp->u.val != 0));
}

int
is_hidden(const char *name, const char *pattern)
{	/* return 1 if name is hidden (i.e., had 3 or more leading underscores)
	   and pattern is NULL or empty */
	return (((pattern == (const char *)NULL) || (*pattern == '\0')) &&
		(strncmp(name,"___",3) == 0));
}

int
is_immutable(const char *name)
{	/* return 1 if name exists and is immutable, else 0 */
	Symbol *sp;
	sp = lookup(name);
	return ((sp != (Symbol*)NULL) && sp->immutable);
}

int
is_local(const char *name)
{
	/* return 1 if name exists and is an internal local variable, else 0 */
	return (strchr(name,'@@') != (char*)NULL);
}

int
is_match(const char *name, const char *pattern)
{	/* return 1 if name matches pattern, else 0 */
	size_t len_name;
	size_t len_pattern;

	if ((pattern == (const char*)NULL) || (*pattern == '\0'))
		return (1);		/* empty or NULL pattern matches everything */
	if ((name == (const char*)NULL) || (*name == '\0'))
		return (0);		/* empty or NULL name matches nothing */

	len_name = strlen(name);
	len_pattern = strlen(pattern);

#if 0
	if (len_name < len_pattern)
		return (0);		/* short name cannot match long pattern */
#endif

	/* Triple underscore (i.e., hidden) symbols match only patternes
	   with triple underscore */
	if (((len_name >= 3) && (strncmp(name,"___",3) == 0)) &&
		 ((len_pattern < 3) || (strncmp(pattern,"___",3) != 0)))
		return (0);
	else
#if 0
		return (strncmp(name,pattern,len_pattern) == 0);
#else
		return (match(name,pattern));
#endif
}

Symbol*
lookup(const char* s)	/* find s in symbol table */
{
	Symbol *sp;

#if defined(DEBUG_LOOKUP)
	(void)fprintf(stderr,"\n%%DEBUG: lookup(%s)\n", s);
#endif

#if 0
	for (sp = symlist; sp != (Symbol *)NULL; sp = sp->next)
	{
#if defined(DEBUG_LOOKUP)
		(void)fprintf(stderr,
			      "\t%%DEBUG: lookup(%s)\tsp = %p\tsp->next = %p\tname = %s\tnext->name = %s\n",
			      s, sp, sp->next, sp->name,
			      (sp->next == (Symbol*)NULL) ? "" : sp->next->name);
#endif
		if (STREQUAL(sp->name, s))
		{
#if defined(DEBUG_LOOKUP)
			(void)fprintf(stderr,"\t%%DEBUG: lookup(%s) matched!\n", s);
#endif
			return sp;
		}
	}
#else
	/* Revise to use move-to-front algorithm for (probably) faster lookup */
	Symbol *last_sp = (Symbol *)NULL;
	Symbol *old_symlist = symlist;

	for (sp = symlist; sp != (Symbol *)NULL; sp = sp->next)
	{
#if defined(DEBUG_LOOKUP)
		(void)fprintf(stderr,
			      "\t%%DEBUG: lookup(%s)\tsp = %p\tsp->next = %p\tname = %s\tnext->name = %s\n",
			      s, sp, sp->next, sp->name,
			      (sp->next == (Symbol*)NULL) ? "" : sp->next->name);
#endif
		if (STREQUAL(sp->name, s))
		{
#if defined(DEBUG_LOOKUP)
			(void)fprintf(stderr,"\t%%DEBUG: lookup(%s) matched!\n", s);
#endif
			if (sp != symlist) /* then not at head */
			{
				if (last_sp != (Symbol*)NULL) /* link previous to next */
					last_sp->next = sp->next;
				symlist = sp;	/* move this one to front */
				symlist->next = old_symlist; /* and link to old list */
#if defined(DEBUG_LOOKUP)
				(void)fprintf(stderr,
					      "\t%%DEBUG: lookup(%s): new head: sp = %p\tsp->next = %p\tname = %s\tnext->name = %s\n\n",
					      s, sp, sp->next, sp->name,
					      (sp->next == (Symbol*)NULL) ? "" : sp->next->name);
#endif
			}
			return (sp);
		}
		last_sp = sp;
	}
#endif

#if defined(DEBUG_LOOKUP)
	(void)fprintf(stderr,"\n%%DEBUG: lookup(%s): not found\n", s);
#endif

	return (Symbol*)NULL;	/* 0 ==> not found */
}

void
make_immutable(Symbol *s)		/* NB: there is intentionally NO make_mutable()! */
{
	if (s != (Symbol *)NULL)
		s->immutable = 1;
}

static const char *
make_pname(Symbol *s)
{
	if (s == (Symbol*)NULL)
		return ((const char*)NULL);
	switch (s->type)
	{
	case BLTIN0:		/* FALL THROUGH */
	case BLTIN1:		/* FALL THROUGH */
	case BLTIN1I:		/* FALL THROUGH */
	case BLTIN1S:		/* FALL THROUGH */
	case BLTIN2:		/* FALL THROUGH */
	case BLTIN2S:		/* FALL THROUGH */
	case FUNCTION:		/* FALL THROUGH */
	case PROCEDURE:		/* FALL THROUGH */
	case STRBLTIN0:		/* FALL THROUGH */
	case STRBLTIN1:		/* FALL THROUGH */
	case STRBLTIN1N:	/* FALL THROUGH */
	case STRBLTIN2:		/* FALL THROUGH */
	case STRBLTIN2SN:	/* FALL THROUGH */
	case STRBLTIN3SNN:
		return (concat2(s->name,"()")); /* functions and procedures need final () */

	default:
		return (dupstr(s->name)); /* ordinary symbol */
	}
}


static const char *
msg_name(const char *msg)
{ /* return a dynamically-allocated string with the translation variable corresponding to msg */
	char *new_msg;
	char *new_msg_start;
	char *p;
	size_t new_size;

	new_size = sizeof(MSG_PREFIX) + strlen(msg) + 1;
	new_msg = (char *)emalloc(new_size);
	(void)strlcpy(new_msg,MSG_PREFIX,new_size);

	while (*msg && isspace(*msg))	/* remove leading space */
		msg++;

	new_msg_start = new_msg + sizeof(MSG_PREFIX) - 1;

	for (p = new_msg_start; *msg; msg++) /* copy alphanumerics, reducing */
	{				/* runs of all else to single underscores */
		if (isalnum(*msg))
		{
			*p = *msg;
			if (isupper(*p))
				*p = tolower(*p);
			p++;
		}
		else if (p[-1] != '_')
			*p++ = '_';
	}
	*p-- = '\0';
	while ((p > new_msg_start) && (*p == '_')) /* remove trailing underscores */
		*p-- = '\0';
	return ((const char*)new_msg);
}

const char *
msg_translate(const char *msg)
{		/* return static string translation of msg, or NULL if msg is NULL or empty */
	const char *name;
	const char *new_msg;
	Symbol *sp;

	if ((msg == (const char *)NULL) || (*msg == '\0'))
		return ((const char *)NULL);
	else
	{
		name = msg_name(msg);
		sp = lookup(name);
		efree((void*)name);

		if (sp == (Symbol*)NULL)	/* then no translation variable found: */
			new_msg = msg;		/* return copy of original message */
		else if (*(sp->u.str) == '\0')	/* variable found with empty value: */
			new_msg = msg;		/* return copy of original message */
		else
			new_msg = compare_format_items(msg,sp->u.str) ? sp->u.str : msg;
		return (new_msg);
	}
}

static const char *
next_matching_symbol_name(const char *pattern)
{	/* return next symbol name matching pattern, or NULL */
	const char *name;

	name = next_symbol_name();
	while ((name != (const char*)NULL) && !is_match(name,pattern))
		name = next_symbol_name();
	return (name);
}

Symbol *
next_symbol(void)
{
	if (this_sym == (Symbol*)NULL)
		return ((Symbol*)NULL);
	else
	{
		this_sym = this_sym->next;
		return (this_sym);
	}
}

static const char *
next_symbol_name(void)
{
	if (this_symbol == (Symbol*)NULL)
		return ((const char*)NULL);
	else
	{
		this_symbol = this_symbol->next;
		return ((this_symbol == (Symbol*)NULL) ? (const char*)NULL :
			this_symbol->name);
	}
}

const char *
next_symbol_pname(void)
{	/* return dynamic copy of next symbol, with optional () */
	if (this_symbol == (Symbol*)NULL)
		return ((const char*)NULL);
	else
	{
		this_symbol = this_symbol->next;
		return (make_pname(this_symbol));
	}
}

static Symbol *
set_number(Symbol *s, fp_t d)		/* NO LONGER USED */
{
	/* Store d in s, IGNORING the immutable flag, and return s. */

	s->u.val = d;
	return (s);
}

Symbol *
set_string(Symbol *s, const char *name)
{
	/* Store a copy of name in s, IGNORING the immutable flag, and
	   return s.  Any previous string storage is released. */

	if (s->u.str != (const char*)NULL)
		efree((void*)s->u.str);
	s->u.str = dupstr(name);
	return (s);
}

static void
set_title(const char* s)
{
	title = s;
}

Symbol*
update_const_number(const char* s, fp_t d)
{
	/* Replace d in a symbol, creating the symbol first if needed,
	   and return a pointer to the symbol.  The immutable flag is
	   set, but not tested. */

	Symbol *sp;

	sp = lookup(s);
	if (sp == (Symbol*)NULL)
		sp = install(s, VAR, d);
	else
		sp->u.val = d;
	sp->type = VAR;
	sp->immutable = 1;
	return sp;
}

Symbol*
update_const_string(const char* s, const char *value)
{
	/* Replace s in a symbol, creating the symbol first if needed,
	   and return a pointer to the symbol.  The immutable flag is
	   set, but not tested. */

	Symbol *sp;

	sp = lookup(s);
	if (sp == (Symbol*)NULL)
		sp = install(s, STRVAR, FP(0.0));
	else
		efree((void*)sp->u.str);
	sp->immutable = 1;
	sp->type = STRVAR;
	sp->u.str = dupstr(value);
	return sp;
}

Symbol*
update_number(const char* s, fp_t d)	/* install s in symbol table */
{
	/* Replace d in a symbol, creating the symbol first if needed,
	   and return a pointer to the symbol */

	Symbol *sp;

	sp = lookup(s);
	if (sp == (Symbol*)NULL)
		sp = install(s, VAR, d);
	else if (sp->immutable)
		execerror("illegal reassignment to immutable named constant", sp->name);
	else
		sp->u.val = d;
	sp->type = VAR;
	sp->immutable = 0;
	return sp;
}

Symbol*
update_string(const char* s, const char *value)  /* install s in symbol table */
{
	/* Replace s in a symbol, creating the symbol first if needed,
	   and return a pointer to the symbol */

	Symbol *sp;

	sp = lookup(s);
	if (sp == (Symbol*)NULL)
		sp = install(s, STRVAR, FP(0.0));
	else if (sp->immutable)
		execerror("illegal reassignment to immutable named constant", sp->name);
	else
		efree((void*)sp->u.str);
	sp->immutable = 0;
	sp->type = STRVAR;
	sp->u.str = dupstr(value);
	return sp;
}
@


1.18
log
@Add new function is_local().
@
text
@d28 1
d30 2
d43 1
a43 1
int
d97 1
a97 1
				      "\t%%DEBUG: delete(%s): tp = %p\ttp->next = %p\tname = %s\tnext->name = %s\n\n", 
d426 2
a427 2
const char *
first_matching_symbol_name(const char *pattern)
d445 1
a445 1
const char *
d705 1
a705 1
					      "\t%%DEBUG: lookup(%s): new head: sp = %p\tsp->next = %p\tname = %s\tnext->name = %s\n\n", 
d819 1
a819 1
const char *
d842 1
a842 1
const char *
d867 2
a868 2
Symbol *
set_number(Symbol *s, fp_t d)
@


1.17
log
@Add symbol table debugging code in delete_symbol_unchecked(),
install(), and lookup().  Parenthesize arguments in two calls to
memcpy() and memcmp() so that the (void*) cast works as intended.
@
text
@d534 1
a534 1
#if defined(DEBUG_LOOKUP)
d612 7
@


1.16
log
@Revise dump_syms() and make_pname() to handle names for the new
function types, and delete code corresponding to functions moved from
the grammar rules into function tables.
@
text
@d88 10
d312 1
a312 1
		    (memcmp((void*)blocks[k].adr + blocks[k].len, (void*)magic, sizeof(magic)) != 0))
d326 1
d351 1
d367 1
a367 1
	(void)memcpy((void*)blocks[nblocks].adr + blocks[nblocks].len, (void*)magic, sizeof(magic));
d372 2
a373 1
	return p;
d384 1
d533 8
d648 4
d654 7
d662 4
d667 2
a673 4
#if 0
	(void)fprintf(stderr,"\n%%DEBUG: lookup(%s)\n", s);
#endif

d676 5
a680 2
#if 0
		(void)fprintf(stderr,"\t%%DEBUG: sp = %p\tname = %s\n", sp, sp->name);
d684 2
a685 2
#if 0
			(void)fprintf(stderr,"\t%%DEBUG: matched!\n");
d693 5
a697 2
#if 0
				(void)fprintf(stderr,"\t%%DEBUG: sp = %p\tnew head = %s\n\n", sp, sp->name);
d705 5
@


1.15
log
@Add new free_symbol_table() function that main() can use during final
clean up.  Change string equality tests to use STREQUAL().
@
text
@d204 1
a204 1
	set_title("\n\tBuilt-in numeric functions (one argument):\n");
d207 7
a213 1
	set_title("\n\tBuilt-in numeric functions (two arguments):\n");
d216 3
d222 1
a222 1
	set_title("\n\tBuilt-in string functions (one argument):\n");
d225 4
a228 1
	set_title("\n\tBuilt-in string functions (two arguments):\n");
d231 5
a235 15
	set_title("\n\tMiscellaneous built-in functions:\n");
	dump_one_type(pattern, 0, ABORT);
	dump_one_type(pattern, 0, DEFINED);
	dump_one_type(pattern, 0, DELETE);
	dump_one_type(pattern, 0, HEX);
	dump_one_type(pattern, 0, HEXFP);
	dump_one_type(pattern, 0, HEXINT);
	dump_one_type(pattern, 0, INDEX);
	dump_one_type(pattern, 0, LENGTH);
	dump_one_type(pattern, 0, NUMTOSTR);
	dump_one_type(pattern, 0, STRFTIME);
	dump_one_type(pattern, 0, STRTONUM);
	dump_one_type(pattern, 0, STRTOSYMNUM);
	dump_one_type(pattern, 0, STRTOSYMSTR);
	dump_one_type(pattern, 0, SUBSTR);
d446 1
a446 1
	Symbol *next_sp;	
a680 1
	case ABORT:		/* FALL THROUGH */
d683 2
d686 1
a686 2
	case DEFINED:		/* FALL THROUGH */
	case DELETE:		/* FALL THROUGH */
a687 6
	case HEX:		/* FALL THROUGH */
	case HEXFP:		/* FALL THROUGH */
	case HEXINT:		/* FALL THROUGH */
	case INDEX:		/* FALL THROUGH */
	case LENGTH:		/* FALL THROUGH */
	case NUMTOSTR:		/* FALL THROUGH */
d691 1
d693 2
a694 5
	case STRFTIME:		/* FALL THROUGH */
	case STRTONUM:		/* FALL THROUGH */
	case STRTOSYMNUM:	/* FALL THROUGH */
	case STRTOSYMSTR:	/* FALL THROUGH */
	case SUBSTR:
@


1.14
log
@Revise erealloc() to call malloc() when the pointer is NULL, because
pre-Standard-C realloc()'s do not handle that case.

In install(), call memset() to clear the symbol table before setting
fields in it: the union element sizes differ across platforms, and on
some not all bits are cleared by the assignments, leading to possible
later reference to garbage bits.
@
text
@d440 17
d626 1
a626 1
		if (strcmp(sp->name, s) == 0)
d642 1
a642 1
		if (strcmp(sp->name, s) == 0)
d875 2
d916 2
@


1.13
log
@Change calls to is_match() to match(), and rename prefix to pattern,
so that printenv(), save(), and who() are generalized to support
UNIX-shell-style patterns instead of simple prefixes.
@
text
@d401 2
a402 1
	return (realloc(p,new_size));
d492 1
@


1.12
log
@Fix bug: symbol table was corrupted by delete() because a
pointer update was missing.
@
text
@d98 1
a98 1
dump_one_type(const char *prefix, int is_constant, int type)
d124 2
a125 2
		    !is_hidden(sp->name,prefix) &&
		    is_match(sp->name,prefix))
d158 1
a158 1
		prtext("\n");
d164 1
a164 1
dump_syms(const char *prefix)
d171 1
a171 1
	if ((prefix != (char*)NULL) && (*prefix != '\0'))
d175 3
a177 2
		prtext(prefix);
		prtext("\":\n");
d180 4
a183 1
		prtext(msg_translate("Symbols:\n"));
d186 2
a187 2
	dump_one_type(prefix, 1, NUMBER);
	dump_one_type(prefix, 1, VAR);
d190 2
a191 2
	dump_one_type(prefix, 1, STRING);
	dump_one_type(prefix, 1, STRVAR);
d194 2
a195 2
	dump_one_type(prefix, 0, NUMBER);
	dump_one_type(prefix, 0, VAR);
d198 2
a199 2
	dump_one_type(prefix, 0, STRING);
	dump_one_type(prefix, 0, STRVAR);
d202 1
a202 1
	dump_one_type(prefix, 0, BLTIN0);
d205 1
a205 1
	dump_one_type(prefix, 0, BLTIN1);
d208 1
a208 1
	dump_one_type(prefix, 0, BLTIN2);
d211 1
a211 1
	dump_one_type(prefix, 0, STRBLTIN0);
d214 1
a214 1
	dump_one_type(prefix, 0, STRBLTIN1);
d217 1
a217 1
	dump_one_type(prefix, 0, STRBLTIN2);
d220 14
a233 14
	dump_one_type(prefix, 0, ABORT);
	dump_one_type(prefix, 0, DEFINED);
	dump_one_type(prefix, 0, DELETE);
	dump_one_type(prefix, 0, HEX);
	dump_one_type(prefix, 0, HEXFP);
	dump_one_type(prefix, 0, HEXINT);
	dump_one_type(prefix, 0, INDEX);
	dump_one_type(prefix, 0, LENGTH);
	dump_one_type(prefix, 0, NUMTOSTR);
	dump_one_type(prefix, 0, STRFTIME);
	dump_one_type(prefix, 0, STRTONUM);
	dump_one_type(prefix, 0, STRTOSYMNUM);
	dump_one_type(prefix, 0, STRTOSYMSTR);
	dump_one_type(prefix, 0, SUBSTR);
d236 1
a236 1
	dump_one_type(prefix, 0, FUNCTION);
d239 1
a239 1
	dump_one_type(prefix, 0, PROCEDURE);
d241 1
a241 1
	prtext("\n");
d407 2
a408 2
first_matching_symbol_name(const char *prefix)
{	/* return first symbol name matching prefix, or NULL */
d412 1
a412 1
	while ((name != (const char*)NULL) && !is_match(name,prefix))
d553 1
a553 1
is_hidden(const char *name, const char *prefix)
d555 2
a556 2
	   and prefix is NULL or empty */
	return (((prefix == (const char *)NULL) || (*prefix == '\0')) &&
d569 2
a570 2
is_match(const char *name, const char *prefix)
{	/* return 1 if name matches prefix, else 0 */
d572 1
a572 1
	size_t len_prefix;
d574 2
a575 2
	if ((prefix == (const char*)NULL) || (*prefix == '\0'))
		return (1);		/* empty or NULL prefix matches everything */
d580 1
a580 1
	len_prefix = strlen(prefix);
d582 4
a585 2
	if (len_name < len_prefix)
		return (0);		/* short name cannot match long prefix */
d587 1
a587 1
	/* Triple underscore (i.e., hidden) symbols match only prefixes
d589 2
a590 2
	else if (((len_name  >= 3) && (strncmp(name,"___",3) == 0)) &&
		 ((len_prefix < 3) || (strncmp(prefix,"___",3) != 0)))
a591 1

d593 5
a597 1
		return (strncmp(name,prefix,len_prefix) == 0);
d751 2
a752 2
next_matching_symbol_name(const char *prefix)
{	/* return next symbol name matching prefix, or NULL */
d756 1
a756 1
	while ((name != (const char*)NULL) && !is_match(name,prefix))
@


1.11
log
@Use safe string routines, strlcat() and strlcpy().
Add new function compare_format_items() to prevent denial-of-service
attacks.
@
text
@d91 1
@


1.10
log
@Add FP() wrappers on floating-point constants.
@
text
@d41 21
d244 1
d248 4
a251 2
	t = (char *)emalloc(strlen(s)+1); /* +1 for '\0' */
	return ((const char*)strcpy(t,s));
d686 1
d688 3
a690 2
	new_msg = (char *)emalloc(sizeof(MSG_PREFIX) + strlen(msg) + 1);
	(void)strcpy(new_msg,MSG_PREFIX);
d735 1
a735 1
			new_msg = sp->u.str;
@


1.9
log
@In the install() function, initialize the builtin flag to zero.
@
text
@d420 1
a420 1
		return (0.0);
d429 1
a429 1
		return ((*end_ptr == '\0') ? 0.0 : result);
d432 1
a432 1
		return (0.0);
d507 1
a507 1
	sp = install(s, VAR, 0.0);
d819 1
a819 1
		sp = install(s, STRVAR, 0.0);
d856 1
a856 1
		sp = install(s, STRVAR, 0.0);
@


1.8
log
@Simplify the switch statement in dump_one_type() by omitting
token types that can fall into the default case.

Add calls to dump_one_type() for several functions defined in
the grammar, rather than in the built-in tables in init.c.

Add two new cases to the switch statement in make_pname() for
newly-added functions defined in the grammar.
@
text
@d463 1
@


1.7
log
@Add new egrow() function for dynamic array support.

Add new functions: get_number(), get_string(), is_debug(),
is_immutable(), update_const_number(), and update_const_string().

Add new cases in make_pname() for new grammar tokens.
@
text
@a118 10
		case BLTIN0:		/* FALL THROUGH */
		case BLTIN1:		/* FALL THROUGH */
		case BLTIN2:		/* FALL THROUGH */
		case HEX:		/* FALL THROUGH */
		case STRBLTIN0:		/* FALL THROUGH */
		case STRBLTIN1:		/* FALL THROUGH */
		case STRBLTIN2:
			prtext("\n");
			break;

a122 1
			prtext("\n");
a130 6
			prtext("\n");
			break;

		case FUNCTION:		/* FALL THROUGH */
		case PROCEDURE:
			prtext("\n");
d136 1
d194 6
d202 1
d204 3
d644 2
@


1.6
log
@Split delete_symbol() into two parts, with the actual deletion
down in delete_symbol_unchecked().  Make both return 1 on
success, and 0 on failure. delete_symbol() now checks for
allowable deletions, so that it can also be used for processing
of the -Uname command-line option.
@
text
@d2 1
a2 1
#include "y.tab.h"
d16 3
d236 17
d339 1
a339 1
erealloc(void *p, size_t new_size)
d344 2
a345 1
	(void)memcpy(p, old_p, new_size); /* NB: might read uninitialized memory! */
d376 1
a376 1
erealloc(void *p, size_t new_size)
d416 46
d520 9
d537 8
d631 1
d635 2
d639 5
d647 4
a650 1
	case STRBLTIN2:
d790 37
@


1.5
log
@Add code to is_match() to prevent matches with triple-underscore
(i.e., hidden) symbols unless the prefix also starts with
triple underscore.
@
text
@d24 1
d37 1
a37 1
void
d39 14
a52 1
{
d65 1
a65 1
			return;
d68 2
@


1.4
log
@Add new function delete_symbol(), needed to support the new command-line
-Uname option.
@
text
@d447 1
d455 1
d457 2
a458 1
	if (strlen(name) < len_prefix)
d460 9
a468 1
	return (strncmp(name,prefix,len_prefix) == 0);
@


1.3
log
@Major update, with several new functions.
@
text
@d36 20
@


1.2
log
@There are many changes in this file.

Make the code conform to C and C++ Standards.

Protect header file inclusion with feature-test conditionals.

New functions:
        cmpsym()
        dump_one_type()
        dump_syms()
        dupstr()
        install_const_number()
        install_const_string()
        install_number()
        install_string()
        set_string()

The dump_xxx() functions support the new who() function, which
was inspired by a similar feature in the Matlab linear algebra
system.
@
text
@d4 4
a11 4
#if defined(HAVE_STDLIB_H)
#include <stdlib.h>
#endif

d16 5
a20 1
static Symbol *symlist = (Symbol*)NULL;	/* symbol table: linked list */
d22 16
a37 2
Symbol*
lookup(const char* s)	/* find s in symbol table */
d40 4
d45 1
d47 310
a356 3
		if (strcmp(sp->name, s) == 0)
			return sp;
	return (Symbol*)NULL;	/* 0 ==> not found */
d360 1
a360 1
install(const char* s, int t, double d)  /* install s in symbol table */
d375 1
a375 1
install_number(const char* s, double d)	/* install s in symbol table */
d380 1
a380 1
	sp->immutable = 0;
d385 1
a385 1
install_const_number(const char* s, double d)  /* install s in symbol table */
d389 2
a390 2
	sp = install(s, VAR, d);
	sp->immutable = 1;
d395 1
a395 1
install_const_string(const char* s, const char *value)  /* install s in symbol table */
d399 2
a400 2
	sp = install_string(s, value);
	sp->immutable = 1;
d416 7
a422 4
void*
emalloc(unsigned n)	/* check return from malloc */
{
	char *p;
d424 14
a437 4
	p = (char*)malloc(n);
	if (p == 0)
		execerror("out of memory", (const char *)NULL);
	return p;
d440 2
a441 2
const char *
dupstr(const char *s)
d443 10
a452 1
	char *t;
d454 3
a456 5
	if (s == (const char*)NULL)	/* treat NULL like "" */
		s = "";
	t = (char *)emalloc((unsigned)(strlen(s)+1)); /* +1 for '\0' */
	return ((const char*)strcpy(t,s));
}
d458 24
a481 2
#if defined(__cplusplus) || defined(c_plusplus)
extern "C"
d483 2
d486 2
a487 2
int
cmpsym(const void *v1, const void *v2)
d489 2
a490 1
	return (strcmp((*(Symbol**)v1)->name, (*(Symbol**)v2)->name));
d493 17
a509 3
#if !defined(MAX_SYMBOLS)
#define MAX_SYMBOLS 4096		/* should be plenty big enough */
#endif
d511 4
a514 8
static void
dump_one_type(int is_constant, int type)
{
	Symbol *sp;
	int precision;
	Symbol *symtab[MAX_SYMBOLS];
	size_t k;
	size_t n_symtab;
a515 1
	precision = (int)lookup("PREC")->u.val;
d517 6
a522 12
	/* First build a table of matching symbols that we can later sort */
	for (n_symtab = 0, sp = symlist; sp != (Symbol *)NULL; sp = sp->next)
	{
		if (type != sp->type)
			continue;
		if (is_constant && !sp->immutable)
			continue;
		if (!is_constant && sp->immutable)
			continue;
		if ((sp->name != (const char*)NULL) && *sp->name && (n_symtab < MAX_SYMBOLS))
			symtab[n_symtab++] = sp;
	}
d524 2
a525 10
	qsort(symtab, n_symtab, sizeof(Symbol*), cmpsym);
	for (k = 0; k < n_symtab; ++k)
	{
		(void)printf("\t\t%-23s", symtab[k]->name);
		switch (symtab[k]->type)
		{
		case HEX:		/* FALL THROUGH */
		case BLTIN0:		/* FALL THROUGH */
		case BLTIN1:		/* FALL THROUGH */
		case BLTIN2:	(void)printf("\n"); break;
d527 2
a528 2
		case NUMBER:		/* FALL THROUGH */
		case VAR:	(void)printf("= %.*g\n", precision, symtab[k]->u.val); break;
d530 1
a530 2
		case STRVAR:		/* FALL THROUGH */
		case STRING:	(void)printf("= \"%s\"\n", symtab[k]->u.str); break;
d532 8
a539 3
		case FUNCTION:		/* FALL THROUGH */
		case PROCEDURE:	(void)printf("\n"); break;
		default: break;
d541 2
d544 4
d550 38
a587 2
void
dump_syms(void)
d589 8
a596 1
	int old_precision;
d598 12
a609 2
	old_precision = get_precision();
	set_precision(default_precision());
d611 11
a621 1
	(void)printf("Symbols:\n");
d623 4
a626 39
	(void)printf("\tNumeric named constants:\n");
	dump_one_type(1, NUMBER);
	dump_one_type(1, VAR);
	(void)printf("\n");

	(void)printf("\tString named constants:\n");
	dump_one_type(1, STRING);
	dump_one_type(1, STRVAR);
	(void)printf("\n");

	(void)printf("\tNumeric variables:\n");
	dump_one_type(0, NUMBER);
	dump_one_type(0, VAR);
	(void)printf("\n");

	(void)printf("\tString variables:\n");
	dump_one_type(0, STRING);
	dump_one_type(0, STRVAR);
	(void)printf("\n");

	(void)printf("\tBuilt-in functions (zero arguments):\n");
	dump_one_type(0, BLTIN0);
	(void)printf("\n");

	(void)printf("\tBuilt-in functions (one argument):\n");
	dump_one_type(0, BLTIN1);
	(void)printf("\n");

	(void)printf("\tBuilt-in functions (two arguments):\n");
	dump_one_type(0, BLTIN2);
	(void)printf("\n");

	(void)printf("\tUser-defined functions:\n");
	dump_one_type(0, FUNCTION);
	(void)printf("\n");

	(void)printf("\tUser-defined procedures:\n");
	dump_one_type(0, PROCEDURE);
	(void)printf("\n");
d628 2
a629 1
	set_precision(old_precision);
d639 1
a639 1
		free((void*)s->u.str);
d644 44
@


1.1
log
@Initial revision
@
text
@a0 1
#include <stdlib.h>
d4 13
a16 1
static Symbol *symlist = 0;  /* symbol table: linked list */
d19 1
a19 1
lookup(char* s)	/* find s in symbol table */
d23 1
a23 1
	for (sp = symlist; sp != (Symbol *) 0; sp = sp->next)
d26 1
a26 1
	return 0;	/* 0 ==> not found */	
d30 1
a30 1
install(char* s, int t, double d)  /* install s in symbol table */
d34 3
a36 3
	sp = emalloc(sizeof(Symbol));
	sp->name = emalloc(strlen(s)+1); /* +1 for '\0' */
	strcpy(sp->name, s);
d44 42
d91 1
a91 1
	p = malloc(n);
d93 1
a93 1
		execerror("out of memory", (char *) 0);
d96 139
@
