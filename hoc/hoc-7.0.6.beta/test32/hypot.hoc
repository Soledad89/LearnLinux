### -*-hoc-*-
### ====================================================================
### Test hypot() with certain special arguments.
###
### The test functions will be cleaner and simpler when hoc is
### extended to support function/procedure arguments of string type.
### [10-Dec-2001]
### ====================================================================

__MAXULPS = 1				# allow only 1 one bit of error

### func scaled_hypot_check() return (hypot(__SCALE__*$1,__SCALE__*$2) == __SCALE__*$3)

func scaled_hypot_check() \
{
	global __MAXULPS, __SCALE__, __TEST__

	__x = $1
	__y = $2
	__z = $3
	__u = hypot(__SCALE__*__x,__SCALE__*__y)
	__v = __SCALE__*__z

	if (isnan(__u) || isnan(__v)) \
		return 0 \
	else if (isinf(__u) && isinf(__v)) \
		return 1 \
	else \
		return (__absulperr(__u, __v) < __MAXULPS)
}

proc test_scaled_hypot() \
{
	global __SCALE__, __TEST__

	__SCALE__ = $1

	## print "DEBUG:", __NTEST__, __SCALE__, "\n"

	__TEST__ = "scaled_hypot_check(3,4,5)"
	__assert(scaled_hypot_check(3,4,5))

	__TEST__ = "scaled_hypot_check(5,12,13)"
	__assert(scaled_hypot_check(5,12,13))

	__TEST__ = "scaled_hypot_check(20,21,29)"
	__assert(scaled_hypot_check(20,21,29))

	__SCALE__ = 1			# reset to default
}


__TEST__ = "isinf(hypot(+Infinity,+NaN))"
__assert(isinf(hypot(+Infinity,+NaN)))

__TEST__ = "isinf(hypot(+Infinity,-NaN))"
__assert(isinf(hypot(+Infinity,-NaN)))

__TEST__ = "isinf(hypot(+NaN,+Infinity))"
__assert(isinf(hypot(+NaN,+Infinity)))

__TEST__ = "isinf(hypot(+NaN,-Infinity))"
__assert(isinf(hypot(+NaN,-Infinity)))

__TEST__ = "isinf(hypot(-Infinity,+NaN))"
__assert(isinf(hypot(-Infinity,+NaN)))

__TEST__ = "isinf(hypot(-Infinity,-NaN))"
__assert(isinf(hypot(-Infinity,-NaN)))

__TEST__ = "isinf(hypot(-NaN,+Infinity))"
__assert(isinf(hypot(-NaN,+Infinity)))

__TEST__ = "isinf(hypot(-NaN,-Infinity))"
__assert(isinf(hypot(-NaN,-Infinity)))


__TEST__ = "isnan(hypot(+NaN,+NaN))"
__assert(isnan(hypot(+NaN,+NaN)))

__TEST__ = "isnan(hypot(+NaN,-NaN))"
__assert(isnan(hypot(+NaN,-NaN)))

__TEST__ = "isnan(hypot(-NaN,+NaN))"
__assert(isnan(hypot(-NaN,+NaN)))

__TEST__ = "isnan(hypot(-NaN,-NaN))"
__assert(isnan(hypot(-NaN,-NaN)))


__TEST__ = "isnan(hypot(NaN,1.0))"
__assert(isnan(hypot(NaN,1.0)))

__TEST__ = "isnan(hypot(NaN,-1.0))"
__assert(isnan(hypot(NaN,-1.0)))


__TEST__ = "hypot(Infinity,0) == Infinity"
__assert(hypot(Infinity,0) == Infinity)

__TEST__ = "hypot(0,Infinity) == Infinity"
__assert(hypot(0,Infinity) == Infinity)


__TEST__ = "hypot(0,0) == 0"
__assert(hypot(0,0) == 0)

__TEST__ = "hypot(4,0) == 4"
__assert(hypot(4,0) == 4)


__TEST__ = "hypot(+3,+4) == 5"
__assert(hypot(+3,+4) == 5)

__TEST__ = "hypot(+5,+12) == 13"
__assert(hypot(+5,+12) == 13)

__TEST__ = "hypot(+20,+21) == 29"
__assert(hypot(+20,+21) == 29)


__TEST__ = "hypot(+3,-4) == 5"
__assert(hypot(+3,-4) == 5)

__TEST__ = "hypot(+5,-12) == 13"
__assert(hypot(+5,-12) == 13)

__TEST__ = "hypot(+20,-21) == 29"
__assert(hypot(+20,-21) == 29)


__TEST__ = "hypot(-3,-4) == 5"
__assert(hypot(-3,-4) == 5)

__TEST__ = "hypot(-5,-12) == 13"
__assert(hypot(-5,-12) == 13)

__TEST__ = "hypot(-20,-21) == 29"
__assert(hypot(-20,-21) == 29)


__TEST__ = "hypot(-3,+4) == 5"
__assert(hypot(-3,+4) == 5)

__TEST__ = "hypot(-5,+12) == 13"
__assert(hypot(-5,+12) == 13)

__TEST__ = "hypot(-20,+21) == 29"
__assert(hypot(-20,+21) == 29)


if (__IEEE_754__) \
{
	### Since the absolute value of the largest argument to
	### hypot() in the tests above is less than 2^5 == 32,
	### and we require a sum of two of them, as long as the scale
	### factor does not get within 2*2^5 == 2^6 == 64 of the
	### overflow limit, we cannot get overflow

	### Test large numbers close to, but below, the IEEE 754
	### 64-bit overflow limit
	test_scaled_hypot((1 - 2^(-53))*2^(506))

	### Test small numbers close to, but above, the IEEE 754
	### 64-bit underflow limit for x^2
	test_scaled_hypot(2^(-511))

	### Test small numbers close to, but above, the IEEE 754
	### 64-bit underflow limit for x
	test_scaled_hypot(2^(-1021))

	test_scaled_hypot(2^(-1022))

	### Test small numbers close to, but below, the IEEE 754
	### 64-bit underflow limit for normalized x
	test_scaled_hypot(2^(-1027))

	### Test values that should cause underflow, even with
	### subnormal numbers:
	test_scaled_hypot(2^(-1075))

	### Test values that should cause overflow with IEEE 754
	### 64-bit overflow limit
	test_scaled_hypot(2^(1023))
}
