head	1.1;
access;
symbols;
locks
	beebe:1.1; strict;
comment	@# @;


1.1
date	2002.08.06.13.37.22;	author beebe;	state Exp;
branches;
next	;


desc
@Original version.
@


1.1
log
@Initial revision
@
text
@### -*-hoc-*-
### ====================================================================
### Test macheps(), without unprotected assumptions about the host
### floating-point systems.
### [26-Jan-2002]
### ====================================================================

### First determine the floating-point base, using the algorithm from
### ELEFUNT's machar() subroutine:

a = 2
while ((((a + 1) - a) - 1) == 0) \
	a += a

b = 2
while (((a + b) - a) == 0) \
	b += b

base = int((a + b) - a)

__TEST__ = "base == BASE"
__assert   (base == BASE)

__TEST__ = "isnan(macheps(+Inf))"
__assert(isnan(macheps(+Inf)))

__TEST__ = "isnan(macheps(-Inf))"
__assert(isnan(macheps(-Inf)))

__TEST__ = "isnan(macheps(+NaN))"
__assert(isnan(macheps(+NaN)))

__TEST__ = "isnan(macheps(-NaN))"
__assert(isnan(macheps(-NaN)))

__TEST__ = "macheps(0)/2 == 0"
__assert(macheps(0)/2 == 0)

__TEST__ = "(1 + macheps(1)/base) == 1"
__assert((1 + macheps(1)/base) == 1)

__TEST__ = "(1 - macheps(1)/4) == 1"
__assert((1 - macheps(1)/4) == 1)

__TEST__ = "base*macheps(-1) == macheps(1)"
__assert(base*macheps(-1) == macheps(1))

__epsone = macheps(1)

### The range 2^-255 .. 2^+255 is representable with IBM S/360
### hexadecimal normalized floating-point arithmetic, which is the
### smallest of all current architectures, so this test should be
### portable across all systems.  We use an extended range in the IEEE
### 754 section below.  This suggests that perhaps the exponent limits
### and base need to be parametrized and made available standardly in
### hoc [[25-Jan-2002]: Added EBIAS, EBITS, EMIN, EMAX, and P.]
for (k = EMIN; k <= EMAX; ++k) \
{
	x = 2^k
	__TEST__ = "macheps(2^" k ") == macheps(1) * 2^" k
	__assert   (macheps(x) == __epsone * x)
}

func hassubnormals() \
{
	return (issubnormal(1/MAXNORMAL))
}

if (__IEEE_754__) \
{
	__TEST__ = "(EBIAS == 127) || (EBIAS == 1023) || (EBIAS == 16383)"
	__assert   ((EBIAS == 127) || (EBIAS == 1023) || (EBIAS == 16383))

	__TEST__ = "(EBITS == 8) || (EBITS == 11) || (EBITS == 15)"
	__assert   ((EBITS == 8) || (EBITS == 11) || (EBITS == 15))

	__TEST__ = "(EMAX == 127) || (EMAX == 1023) || (EMAX == 16383)"
	__assert   ((EMAX == 127) || (EMAX == 1023) || (EMAX == 16383))

	__TEST__ = "(EMIN == -126) || (EMIN == -1022) || (EMIN == -16382)"
	__assert   ((EMIN == -126) || (EMIN == -1022) || (EMIN == -16382))

	__TEST__ = "(P == 24) || (P == 53) || (P == 64) || (P == 113)"
	__assert   ((P == 24) || (P == 53) || (P == 64) || (P == 113))

	__TEST__ = "macheps(1) == 2^(-(P - 1))"
	__assert   (macheps(1) == 2^(-(P - 1)))

	__TEST__ = "(macheps(0) == 2^(EMIN)) || (macheps(0) == 2^((EMIN - P + 1)))"
	__assert((macheps(0) == 2^(EMIN)) || (macheps(0) == 2^((EMIN - P + 1))))

	if (hassubnormals()) \
		__lower_limit = (EMIN - (P - 1)) + (P - 1) \
	else \
		__lower_limit = EMIN + (P - 1)

	for (k = __lower_limit; k < EMAX; ++k) \
	{
		x = 2^k
		__TEST__ = "macheps(2^" k ") == macheps(1) * 2^" k
		__assert   (macheps(x) == __epsone * x)
	}

	## Test boundary cases
	__TEST__ = "macheps(0)/2 == 0"
	__assert   (macheps(0)/2 == 0)
	if (hassubnormals()) \
	{
		__TEST__ = "macheps(MINSUBNORMAL) == MINSUBNORMAL"
		__assert   (macheps(MINSUBNORMAL) == MINSUBNORMAL)
	} \
	else \
	{
		__TEST__ = "macheps(MINNORMAL) == MINNORMAL"
		__assert   (macheps(MINNORMAL) == MINNORMAL)
	}

	if (hassubnormals()) \
	{
		__TEST__ = "macheps(-MINSUBNORMAL) == MINSUBNORMAL"
		__assert   (macheps(-MINSUBNORMAL) == MINSUBNORMAL)
	} \
	else \
	{
		__TEST__ = "macheps(-MINNORMAL) == MINNORMAL"
		__assert   (macheps(-MINNORMAL) == MINNORMAL)
	}

	__TEST__ = "isinf(MAXNORMAL + macheps(MAXNORMAL))"
	__assert   (isinf(MAXNORMAL + macheps(MAXNORMAL)))

	__TEST__ = "isinf(-MAXNORMAL - macheps(-MAXNORMAL))"
	__assert   (isinf(-MAXNORMAL - macheps(-MAXNORMAL)))
}
@
