### -*-hoc-*-
### ====================================================================
### Test sqrt() with certain special arguments.
###
### The test functions will be cleaner and simpler when hoc is
### extended to support function/procedure arguments of string type.
### [10-Dec-2001]
### ====================================================================

### On Compaq/DEC Alpha, OSF/1 4.0 and OSF/1 5.0, pow(x,y) misbehaves:
### 
### 	% hoc
### 	hoc> (-Infinity)^2
### 	NaNQ
### 	hoc> (-Infinity)*(-Infinity)
### 	Inf
### 
### The correct answer, from all other systems, is
### 
### 	./hoc
### 	hoc> (-Infinity)^2
### 	Inf
### 	hoc> (-Infinity)*(-Infinity)
### 	Inf
###
### Thus, we use squaring, not powers, in the body of sqrt_pair()

func sqrt_pair(x,y) return sqrt(x*x + y*y)

func scaled_sqrt_check(x,y,z) \
{
	global __SCALE__
	return (sqrt_pair(__SCALE__ * x, __SCALE__ * y) == __SCALE__ * z)
}

proc test_scaled_sqrt_pair(scale) \
{
	global __SCALE__, __TEST__
	__SCALE__ = scale

	## print "DEBUG:", scale

	__TEST__ = "scaled_sqrt_check(3,4,5)"
	__assert   (scaled_sqrt_check(3,4,5))

	__TEST__ = "scaled_sqrt_check(5,12,13)"
	__assert   (scaled_sqrt_check(5,12,13))

	__TEST__ = "scaled_sqrt_check(20,21,29)"
	__assert   (scaled_sqrt_check(20,21,29))

	__SCALE__ = 1			# reset to default
}

proc test_scaled_sqrt_pair_two(scale) \
{
	### Make some tests that have only a few zero or one bits in the operands.

	global __SCALE__, __TEST__

	__SCALE__ = scale

	n = -log2(macheps(1))
	for (k = 0 ; k <= n; ++k) \
	{
		__TEST__ = "sqrt(1 + 2*2^(-k) + 2^(-2*k)) == 1 + 2^(-k)"
		__assert   (sqrt(1 + 2*2^(-k) + 2^(-2*k)) == 1 + 2^(-k))
		__TEST__ = "sqrt(1 - 2*2^(-k) + 2^(-2*k)) == 1 - 2^(-k)"
		__assert   (sqrt(1 - 2*2^(-k) + 2^(-2*k)) == 1 - 2^(-k))
	}
	__SCALE__ = 1
}

__TEST__ = "isinf(sqrt_pair(Infinity,+NaN))"
__assert   (isnan(sqrt_pair(Infinity,+NaN)))

__TEST__ = "isnan(sqrt_pair(Infinity,-NaN))"
__assert   (isnan(sqrt_pair(Infinity,-NaN)))

__TEST__ = "isnan(sqrt_pair(+NaN,Infinity))"
__assert   (isnan(sqrt_pair(+NaN,Infinity)))

__TEST__ = "isnan(sqrt_pair(+NaN,-Infinity))"
__assert   (isnan(sqrt_pair(+NaN,-Infinity)))

__TEST__ = "isnan(sqrt_pair(-Infinity,+NaN))"
__assert   (isnan(sqrt_pair(-Infinity,+NaN)))

__TEST__ = "isnan(sqrt_pair(-Infinity,-NaN))"
__assert   (isnan(sqrt_pair(-Infinity,-NaN)))

__TEST__ = "isnan(sqrt_pair(-NaN,Infinity))"
__assert   (isnan(sqrt_pair(-NaN,Infinity)))

__TEST__ = "isnan(sqrt_pair(-NaN,-Infinity))"
__assert   (isnan(sqrt_pair(-NaN,-Infinity)))


__TEST__ = "isnan(sqrt_pair(+NaN,+NaN))"
__assert   (isnan(sqrt_pair(+NaN,+NaN)))

__TEST__ = "isnan(sqrt_pair(+NaN,-NaN))"
__assert   (isnan(sqrt_pair(+NaN,-NaN)))

__TEST__ = "isnan(sqrt_pair(-NaN,+NaN))"
__assert   (isnan(sqrt_pair(-NaN,+NaN)))

__TEST__ = "isnan(sqrt_pair(-NaN,-NaN))"
__assert   (isnan(sqrt_pair(-NaN,-NaN)))


__TEST__ = "isnan(sqrt_pair(NaN,1.0))"
__assert   (isnan(sqrt_pair(NaN,1.0)))

__TEST__ = "isnan(sqrt_pair(NaN,-1.0))"
__assert   (isnan(sqrt_pair(NaN,-1.0)))


__TEST__ = "sqrt_pair(Infinity,0) == Infinity"
__assert   (sqrt_pair(Infinity,0) == Infinity)

__TEST__ = "sqrt_pair(0,Infinity) == Infinity"
__assert   (sqrt_pair(0,Infinity) == Infinity)


__TEST__ = "sqrt_pair(Infinity,Infinity) == Infinity"
__assert   (sqrt_pair(Infinity,Infinity) == Infinity)

__TEST__ = "sqrt_pair(Infinity,Infinity) == Infinity"
__assert   (sqrt_pair(Infinity,Infinity) == Infinity)


__TEST__ = "sqrt_pair(Infinity,-Infinity) == Infinity"
__assert   (sqrt_pair(Infinity,-Infinity) == Infinity)

__TEST__ = "sqrt_pair(-Infinity,Infinity) == Infinity"
__assert   (sqrt_pair(-Infinity,Infinity) == Infinity)


__TEST__ = "sqrt_pair(0,0) == 0"
__assert   (sqrt_pair(0,0) == 0)

__TEST__ = "sqrt_pair(4,0) == 4"
__assert   (sqrt_pair(4,0) == 4)


__TEST__ = "sqrt_pair(+3,+4) == 5"
__assert   (sqrt_pair(+3,+4) == 5)

__TEST__ = "sqrt_pair(+5,+12) == 13"
__assert   (sqrt_pair(+5,+12) == 13)

__TEST__ = "sqrt_pair(+20,+21) == 29"
__assert   (sqrt_pair(+20,+21) == 29)


__TEST__ = "sqrt_pair(+3,-4) == 5"
__assert   (sqrt_pair(+3,-4) == 5)

__TEST__ = "sqrt_pair(+5,-12) == 13"
__assert   (sqrt_pair(+5,-12) == 13)

__TEST__ = "sqrt_pair(+20,-21) == 29"
__assert   (sqrt_pair(+20,-21) == 29)


__TEST__ = "sqrt_pair(-3,-4) == 5"
__assert   (sqrt_pair(-3,-4) == 5)

__TEST__ = "sqrt_pair(-5,-12) == 13"
__assert   (sqrt_pair(-5,-12) == 13)

__TEST__ = "sqrt_pair(-20,-21) == 29"
__assert   (sqrt_pair(-20,-21) == 29)


__TEST__ = "sqrt_pair(-3,+4) == 5"
__assert   (sqrt_pair(-3,+4) == 5)

__TEST__ = "sqrt_pair(-5,+12) == 13"
__assert   (sqrt_pair(-5,+12) == 13)

__TEST__ = "sqrt_pair(-20,+21) == 29"
__assert   (sqrt_pair(-20,+21) == 29)

if (__IEEE_754__) \
{
	### Since the absolute value of the largest argument to
	### sqrt_pair() in the tests above is less than 2^5 == 32,
	### and we require a sum of two of them, as long as the scale
	### factor does not get within 2*2^5 == 2^6 == 64 of the
	### overflow limit, we cannot get overflow

	### Test large numbers close to, but below, the IEEE 754
	### 64-bit overflow limit
	test_scaled_sqrt_pair((1 - 2^(-53))*2^(506))

	### Test small numbers close to, but above, the IEEE 754
	### 64-bit underflow limit for x^2
	test_scaled_sqrt_pair(2^(-511))

	### Test small numbers close to, but below, the IEEE 754
	### 64-bit underflow limit for normalized x^2
	test_scaled_sqrt_pair(2^(-513))

	### Test values that should cause underflow, even with
	### subnormal numbers:
	test_scaled_sqrt_pair(2^(507))
}

test_scaled_sqrt_pair_two((1 - 2^(-53))*2^(506))
test_scaled_sqrt_pair_two(2^(-511))
test_scaled_sqrt_pair_two(2^(-513))
test_scaled_sqrt_pair_two(2^(507))
