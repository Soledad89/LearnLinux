head	1.4;
access;
symbols;
locks
	beebe:1.4; strict;
comment	@# @;


1.4
date	2002.08.06.13.38.33;	author beebe;	state Exp;
branches;
next	1.3;

1.3
date	2001.12.19.14.27.07;	author beebe;	state Exp;
branches;
next	1.2;

1.2
date	2001.12.13.16.40.22;	author beebe;	state Exp;
branches;
next	1.1;

1.1
date	2001.12.11.15.21.56;	author beebe;	state Exp;
branches;
next	;


desc
@Original version.
@


1.4
log
@Update to used named, rather than numbered, function/procedure
arguments.
@
text
@### -*-hoc-*-
### ====================================================================
### Initialize test variables for "make check" runs, and define
### functions for logging successes and failures.
### [10-Dec-2001]
### ====================================================================

__NFAIL__ = 0
__NOKAY__ = 0
__NTEST__ = 0
__SCALE__ = 1
__TEST__  = ""

__MACHEPS = macheps(1)
__MAXULPS = 1			# allow only 1 bit (1 ULP) of error

proc __fail() \
{
	global __NFAIL__, __NTEST__, __SCALE__, __TEST__
	__NFAIL__++
	__NTEST__++
	print "Test", __NTEST__, "failed: [" __TEST__ "]"
	if (__SCALE__ != 1) print " argument scaled by", __SCALE__
	print "\n"
}

proc __fail_relerr() \
{
	global __ABSULPERR, __NFAIL__, __NTEST__, __SCALE__, __TEST__
	__NFAIL__++
	__NTEST__++
	print "Test", __NTEST__, "failed: [" __TEST__ "]"
	print " error =", int(__ABSULPERR), "ulps =", ceil(log2(__ABSULPERR)), "bits"
	if (__SCALE__ != 1) print " argument scaled by", __SCALE__
	print "\n"
}

proc __okay() \
{
	global __NFAIL__, __NTEST__
	__NOKAY__++
	__NTEST__++
}

proc __assert(a)		{ if (a) __okay() else __fail() }

proc __assert_small_relerr(a)	{ if (a) __okay() else __fail_relerr() }

func __absrelerr(a,b) \
{
	global __ABSRELERR

	if (b == 0) \
		__ABSRELERR = 0 \
	else \
		__ABSRELERR = abs((a - b)/b)
	return (__ABSRELERR)
}

func __absulperr(a,b) \
{
	global __ABSULPERR, __MACHEPS

	__ABSULPERR = __absrelerr(a,b) / __MACHEPS
	return (__ABSULPERR)
}

proc __match(a,b) \
{
	global __MAXULPS

	if (isnan(a) || isnan(b)) \
		__assert_small_relerr(0) \
	else if (isinf(a) && isinf(b)) \
		__assert_small_relerr(1) \
	else \
		__assert_small_relerr(__absulperr(a, b) <= __MAXULPS)
}
@


1.3
log
@Comment out macheps(), since it now resides in the hoc kernel in math.c.
@
text
@d19 1
d22 2
a23 2
	print "Test ", __NTEST__, "failed: [", __TEST__, "]"
	if (__SCALE__ != 1) print " argument scaled by ", __SCALE__
d29 1
d32 3
a34 3
	print "Test ", __NTEST__, "failed: [", __TEST__, "]"
	print " error = ", int(__ABSULPERR), "ulps = ", ceil(log2(__ABSULPERR)), "bits"
	if (__SCALE__ != 1) print " argument scaled by ", __SCALE__
d40 1
d45 1
a45 1
proc __assert()			{ if ($1) __okay() else __fail() }
d47 1
a47 1
proc __assert_small_relerr()	{ if ($1) __okay() else __fail_relerr() }
d49 1
a49 1
func __absrelerr() \
d51 3
a53 1
	if ($2 == 0) \
d56 1
a56 1
		__ABSRELERR = abs(($1 - $2)/$2)
d60 1
a60 1
func __absulperr() \
d62 3
a64 1
	__ABSULPERR = __absrelerr($1,$2) / __MACHEPS
d68 3
a70 1
### proc __match() __assert_small_relerr(__absulperr($1,$2) <= __MAXULPS)
d72 1
a72 3
proc __match() \
{
	if (isnan($1) || isnan($2)) \
d74 1
a74 1
	else if (isinf($1) && isinf($2)) \
d77 1
a77 1
		__assert_small_relerr(__absulperr($1, $2) <= __MAXULPS)
a78 41

### Borrowed from ../hoc.rc:
### macheps(x): return the generalized machine epsilon of x
### [16-Dec-2001]: Moved code into hoc kernel in math.c, since we
### 		   now need it for other purposes there
### OLD	func macheps() \
### OLD	{
### OLD		## NB: This code guarantees these results:
### OLD		##	macheps(Inf)  -> NaN
### OLD		##	macheps(-Inf) -> NaN
### OLD		##	macheps(NaN)  -> NaN
### OLD		##	macheps(-NaN) -> -NaN
### OLD	
### OLD		__x = $1
### OLD		if (isnan(__x)) \
### OLD			return (__x)
### OLD
### OLD		if (isinf(__x)) \
### OLD			return (NaN)
### OLD	
### OLD		if (__x == 0) \
### OLD			__epsilon = 1.0 \
### OLD		else \
### OLD			__epsilon = abs(__x)
### OLD	
### OLD		while ((__x + __epsilon/2.0) != __x) \
### OLD			__epsilon /= 2.0
### OLD	
### OLD		# purify __epsilon to eliminate all but high-order bit
### OLD		__temp = __x + __epsilon
### OLD		if (isinf(__temp)) \
### OLD		{	# Generate NaN by subtracting infinities
### OLD			__epsilon = __x - __epsilon
### OLD		} \
### OLD		else \
### OLD		{
### OLD			__epsilon = __x + __epsilon
### OLD			__epsilon = __epsilon - __x
### OLD		}
### OLD		return (__epsilon)
### OLD	}
@


1.2
log
@Report bits in error in __fail_relerr().

Rename internal variables in macheps() to have __macheps_ prefix.
@
text
@a73 1

d75 38
a112 33
func macheps() \
{
	## NB: This code guarantees these results:
	##	macheps(Inf)  -> NaN
	##	macheps(-Inf) -> NaN
	##	macheps(NaN)  -> NaN
	##	macheps(-NaN) -> -NaN
	__macheps_x = $1

	if (isnan(__macheps_x)) \
		return (__macheps_x)

	if (__macheps_x == 0) \
		__macheps_epsilon = 1.0 \
	else \
		__macheps_epsilon = abs(__macheps_x)

	while ((__macheps_x + __macheps_epsilon/2.0) != __macheps_x) \
		__macheps_epsilon /= 2.0

	# purify __macheps_epsilon to eliminate all but high-order bit
	__macheps_temp = __macheps_x + __macheps_epsilon
	if (isinf(__macheps_temp)) \
	{	# Generate NaN by subtracting infinities
		__macheps_epsilon = __macheps_x - __macheps_epsilon
	} \
	else \
	{
		__macheps_epsilon = __macheps_x + __macheps_epsilon
		__macheps_epsilon -= __macheps_x
	}
	return (__macheps_epsilon)
}
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
__MAXULPS = 128			# allow 7 bits (2^7 ULPs) of error
d31 1
a31 1
	print " error = ", int(__ABSULPERR), "ulps"
d47 1
a47 1
{	
d61 11
a71 1
proc __match() __assert_small_relerr(__absulperr($1,$2) < __MAXULPS)
d83 1
d85 2
a86 3
	__x = $1
	if (isnan(__x)) \
		return (__x)
d88 2
a89 2
	if (__x == 0) \
		__epsilon = 1.0 \
d91 1
a91 1
		__epsilon = abs(__x)
d93 2
a94 2
	while ((__x + __epsilon/2.0) != __x) \
		__epsilon /= 2.0
d96 3
a98 3
	# purify __epsilon to eliminate all but high-order bit
	__temp = __x + __epsilon
	if (isinf(__temp)) \
d100 1
a100 1
		__epsilon = __x - __epsilon
d104 2
a105 2
		__epsilon = __x + __epsilon
		__epsilon = __epsilon - __x
d107 1
a107 1
	return (__epsilon)
@
