head	1.1;
access;
symbols;
locks
	beebe:1.1; strict;
comment	@# @;


1.1
date	2002.08.06.13.39.45;	author beebe;	state Exp;
branches;
next	;


desc
@Original version.
@


1.1
log
@Development snapshot.
@
text
@### -*-hoc-*-
### ====================================================================
### Test the cpulimit() function.  Because the time limit interrupt
### aborts execution, which flushes the current input file, the
### companion input file cpulimit.hoc is needed to regain control, and
### report on the test.  This file is invoked via the cpulimit.opt file.
### [30-Dec-2001]
### ====================================================================

### Code borrows from ../hoc.rc: needed here because this file
### is executed before any other files on the command line!

### factorial(n) = n*(n-1)*(n-2)*...*1
func factorial() \
{
	$1 = int($1)
	if ($1 < 0) \
		abort("factorial() called with illegal negative argument\n") \
	if ($1 == 0) \
		return (1) \
	else \
	{
		return ($1 * factorial($1 - 1))
	}
}

__NTEST__ = 1

oldlimit = cpulimit(1)

### factorial(33) (== 8.6833176188118859e+36) is below the overflow
### limit on all known floating-point architectures.

### Typical machines produce:
###	1400 MHz AMD Athlon		63573
###	1267 MHz Intel Pentium III	54340
###	 333 MHz Intel Pentium III	13053
###	 750 MHz Sun UltraSPARC III	14073
###	 466 MHz Compaq/DEC Alpha 21164	 9268
###	  50 MHz SuperSPARC		 1171
###
### On the slowest system above, in the absence of a CPU time limit,
### it took 235 sec to reach the limit: thus, a worst case for this
### test is about 5 min, but all systems at the development site have
### resource limits, and for them, the test takes only one second.

n_factorial33_limit = 95000

for (n_factorial33_calls = 1; \
     n_factorial33_calls < n_factorial33_limit; \
     ++n_factorial33_calls) \
	factorial(33)
@
