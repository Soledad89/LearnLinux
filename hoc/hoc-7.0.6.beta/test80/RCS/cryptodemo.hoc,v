head	1.1;
access;
symbols;
locks
	beebe:1.1; strict;
comment	@# @;


1.1
date	2002.08.08.16.48.38;	author beebe;	state Exp;
branches;
next	;


desc
@Original version.
@


1.1
log
@Initial revision
@
text
@### -*-hoc-*-
### ====================================================================
### Test a one-time pad symmetric-key encryption algorithm.
### [23-Jul-2002]
### ====================================================================

### Usage: encrypt(key,plaintext)
### The printed output is an encrypted text stream: the ciphertext.
proc encrypt(key,plaintext) \
{
    plaintext = (plaintext char(255))		# add message terminator
    while (length(plaintext) < 32) \
	plaintext = (plaintext char(randint(1,255))) # pad to 32*n characters
    setrand(key)				# restart the generator
    n = 0
    for (k = 1; k <= length(plaintext); ++k) \
    {
	## Output 32-character lines in 4 chunks of 8 characters each
	if ((n > 0) && (n % 32 == 0)) \
	    println "" \
	else if ((n > 0) && (n % 4 == 0)) \
	    print " "
	printf "%02x", ((ichar(substr(plaintext,k,1)) + randint(0,255)) % 256)
	n++
    }
    println ""
}

### Usage: isprint(c)
### Return 1 if c is printable, and 0 otherwise.
func isprint(c) \
{
    return ((c == 9) || (c == 10) || ((32 <= c) && (c < 127)))
}

__hex_decrypt = "0123456789abcdef"

### Usage: decrypt(key,ciphertext)
### The printed output is the original plaintext message.
proc decrypt(key,ciphertext) \
{
    global __hex_decrypt
    setrand(key)
    for (k = 1; k < length(ciphertext); k++) \
    {
	n = index(__hex_decrypt,substr(ciphertext,k,1))
	if (n > 0) \
	{				# have hex digit: decode hex pair
	    k++
	    c = 16 * (n - 1) + index(__hex_decrypt,substr(ciphertext,k,1)) - 1
	    n = int((c + 256 - randint(0,255)) % 256) # recover plaintext char
	    if (n == 255) \
		break;
	    if (!isprint(n)) \
		n = ichar("?")	# mask unprintable characters
	    printf "%c", n
	}
    }
    println ""
}



proc hrule() { println "------------------------------------------------------------------------" }


println "*******************************************************************************"
println "*******************************************************************************"
println "** Demonstration of a simple one-time pad symmetric-key encryption algorithm **"
println "*******************************************************************************"
println "*******************************************************************************"
println ""

hrule()
println "The encryption does not reveal message length, although it DOES reveal"
println "common plaintext prefixes:\n"
println "encrypt(123,\"A\")"
encrypt(123,"A")
println ""
println "encrypt(123,\"AB\")"
encrypt(123,"AB")
println ""
println "encrypt(123,\"ABC\")"
encrypt(123,"ABC")
println ""
println "encrypt(123,\"ABCD\")"
encrypt(123,"ABCD")
println ""

hrule()
println "The encryption does not reveal letter repetititions:\n"
println "encrypt(123,\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\")"
encrypt(123,"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA")
println ""

hrule()
println "Now encrypt a famous message from American revolutionary history:\n"
println "encrypt(123, \"One if by land, two if by sea: Paul Revere's Ride, 16 April 1775\")"
println ""

encrypt(123, "One if by land, two if by sea: Paul Revere's Ride, 16 April 1775")
println ""

ciphertext = "\t3973974d 63a8ac49 af5cb3e8 da3efdbb f5b63ece\
\t68a21434 19cca7e0 7730dc80 8e9c265c 5be7476c\
\tc51605d1 af1a6d82 9114c057 620da15b 0670bb1d\
\t3c95c30b ed"

hrule()
println "Attempt to decrypt the ciphertext with a nearby key.  Decryption DOES"
println "reveal the message length, although that flaw could easily be fixed:\n"
println "decrypt(122, ciphertext)"
decrypt(122, ciphertext)
println ""

hrule()
println "Attempt to decrypt the ciphertext with the correct key:\n"
println "decrypt(123, ciphertext)"
decrypt(123, ciphertext)
println ""

hrule()
println "Attempt to decrypt the ciphertext with a nearby key:\n"
println "decrypt(123, ciphertext)"
decrypt(124, ciphertext)
println ""

hrule()
@
